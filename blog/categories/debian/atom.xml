<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debian | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/debian/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2018-02-26T21:33:17+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ufw 再入門]]></title>
    <link href="http://blog.n-z.jp/blog/2018-02-25-ufw.html"/>
    <updated>2018-02-25T11:11:11+09:00</updated>
    <id>http://blog.n-z.jp/blog/ufw</id>
    <content type="html"><![CDATA[<p><a href="https://debianjp.connpass.com/event/79989/">第 132 回関西 Debian 勉強会</a>で ufw についての発表をしました。
その資料のファイル形式を変換したものです。</p>

<!--more-->


<h2>はじめに</h2>

<p>ufw はバージョンアップに伴い、機能が追加されてできることが増えています。
そこで、現在の Debian の stable である stretch に入っている ufw 0.35-4 を元に基本的な機能やちょっと複雑なネットワークでの使用方法を紹介します。</p>

<h2>ufw とは?</h2>

<p>iptables のラッパーのようなもので、ファイアウォールの設定を簡単にできるようにするためのものです。
ちなみに名前の ufw は Uncomplicated Firewall の略で、Ubuntu Firewall ではありません。</p>

<h2>使用開始</h2>

<p>まず「ufw enable」で有効にします。 (「ufw disable」で戻せます。)
有効にするとすぐに反映されて、次回起動時からも有効になります。
ssh で接続している場合は、「ufw enable」の前に、そのポートを許可しておくと良いでしょう。
最近は大丈夫のようですが、昔は enable した直後に反応がなくなって切れてしまうことがあったので、再接続できるように許可しておいたり、他の接続手段も確保しておいたりしておく方が安全です。</p>

<pre><code>  $ sudo ufw allow 22/tcp
  Rules updated
  Rules updated (v6)
  $ sudo ufw enable
  Command may disrupt existing ssh connections. Proceed with operation (y|n)? y
  Firewall is active and enabled on system startup
</code></pre>

<h2>デフォルトの挙動</h2>

<p>デフォルトでは外向きは許可、内向きは拒否という一般的に推奨される構成になっています。
許可などの設定は IP アドレスなどの指定がない場合、IPv4 と IPv6 の両方を同時に設定できるので、iptables と ip6tables を別々に設定して二度手間になるようなことがありません。</p>

<h2>基本的な使い方</h2>

<p>ポート番号のみを指定すると TCP/UDP 両方許可できます。
例えば DNS なら、以下のようになります。</p>

<pre><code>  $ sudo ufw allow 53
  Rule added
  Rule added (v6)
</code></pre>

<p>TCP のみ許可するには「ポート番号/tcp」と指定します。
例えば http なら、以下のようになります。</p>

<pre><code>  $ sudo ufw allow 80/tcp
  Rule added
  Rule added (v6)
</code></pre>

<p>UDP のみ許可するには「ポート番号/udp」と指定します。
ポート番号には「:」区切りで範囲を指定できます。
例えば mosh で使われる範囲を許可するなら、以下のようになります。</p>

<pre><code>  $ sudo ufw allow 60000:61000/udp
  Rule added
  Rule added (v6)
</code></pre>

<p>連続しないポート番号を「,」区切りでまとめて指定することもできます。
(「,」で区切られた中に範囲を指定することもできます。)
例えば SMTP などを許可するなら、以下のようになります。</p>

<pre><code>  $ sudo ufw allow 25,465,587/tcp
  Rule added
  Rule added (v6)
</code></pre>

<h2>設定確認</h2>

<p>「ufw status」で設定を確認できます。
「ufw status verbose」でデフォルトポリシーなどを含めた設定の確認ができます。
「ufw status numbered」で delete や insert で使う番号が確認できます。</p>

<pre><code>  $ sudo ufw status
  Status: active

  To                         Action      From
  --                         ------      ----
  22/tcp                     ALLOW       Anywhere
  53                         ALLOW       Anywhere
  80/tcp                     ALLOW       Anywhere
  60000:61000/udp            ALLOW       Anywhere
  25,465,587/tcp             ALLOW       Anywhere
  22/tcp (v6)                ALLOW       Anywhere (v6)
  53 (v6)                    ALLOW       Anywhere (v6)
  80/tcp (v6)                ALLOW       Anywhere (v6)
  60000:61000/udp (v6)       ALLOW       Anywhere (v6)
  25,465,587/tcp (v6)        ALLOW       Anywhere (v6)

  $ sudo ufw status verbose
  Status: active
  Logging: on (low)
  Default: deny (incoming), allow (outgoing), disabled (routed)
  New profiles: skip

  To                         Action      From
  --                         ------      ----
  22/tcp                     ALLOW IN    Anywhere
  53                         ALLOW IN    Anywhere
  80/tcp                     ALLOW IN    Anywhere
  60000:61000/udp            ALLOW IN    Anywhere
  25,465,587/tcp             ALLOW IN    Anywhere
  22/tcp (v6)                ALLOW IN    Anywhere (v6)
  53 (v6)                    ALLOW IN    Anywhere (v6)
  80/tcp (v6)                ALLOW IN    Anywhere (v6)
  60000:61000/udp (v6)       ALLOW IN    Anywhere (v6)
  25,465,587/tcp (v6)        ALLOW IN    Anywhere (v6)

  $ sudo ufw status numbered
  Status: active

       To                         Action      From
       --                         ------      ----
  [ 1] 22/tcp                     ALLOW IN    Anywhere
  [ 2] 53                         ALLOW IN    Anywhere
  [ 3] 80/tcp                     ALLOW IN    Anywhere
  [ 4] 60000:61000/udp            ALLOW IN    Anywhere
  [ 5] 25,465,587/tcp             ALLOW IN    Anywhere
  [ 6] 22/tcp (v6)                ALLOW IN    Anywhere (v6)
  [ 7] 53 (v6)                    ALLOW IN    Anywhere (v6)
  [ 8] 80/tcp (v6)                ALLOW IN    Anywhere (v6)
  [ 9] 60000:61000/udp (v6)       ALLOW IN    Anywhere (v6)
  [10] 25,465,587/tcp (v6)        ALLOW IN    Anywhere (v6)
</code></pre>

<h2>ルールの削除</h2>

<p>「ufw delete 追加した時のルール」や「ufw delete ルール番号」でルールを削除できます。</p>

<pre><code>  $ sudo ufw delete allow 25,465,587/tcp
  Rule deleted
  Rule deleted (v6)
  $ sudo ufw delete allow 60000:61000/udp
  Rule deleted
  Rule deleted (v6)
</code></pre>

<h2>ルールの表記方法</h2>

<p>今まで使ってきた「ufw  [&ndash;dry-run] [delete] [insert NUM] allow|deny|reject|limit [in|out] [log|log-all] [ PORT[/PROTOCOL] | APP‐NAME ] [comment COMMENT]」という省略記法の他に、「ufw [&ndash;dry-run] [rule] [delete] [insert NUM] allow|deny|reject|limit  [in|out  [on  INTERFACE]]  [log|log-all] [proto  PROTOCOL]  [from  ADDRESS [port PORT | app APPNAME ]] [to ADDRESS [port PORT | app APPNAME ]] [comment COMMENT]」という細かく指定する書き方もあります。
IP アドレスを指定するには後者の表記方法を使う必要があります。
詳細は man を参照してください。</p>

<h2>特定 IP アドレスのみ拒否</h2>

<p>前述のように IP アドレスを指定するには「ポート番号/プロトコル」という指定の仕方では無理なので、細かく指定していきます。
また、許可より前に拒否するルールがないといけないので、「insert」 を使います。ここで先ほどの「ufw status numbered」の出力をみると 3 より前にあれば良いとわかるので、「insert 3」と指定します。
ポート番号を指定するときは IP アドレスの指定は必須なので、特に制限する必要がないときは「any」を使います。</p>

<pre><code>  $ sudo ufw insert 3 deny from 192.0.2.0/24 to any port 80 proto tcp
  Rule inserted
  $ sudo ufw status numbered
  Status: active

       To                         Action      From
       --                         ------      ----
  [ 1] 22/tcp                     ALLOW IN    Anywhere
  [ 2] 53                         ALLOW IN    Anywhere
  [ 3] 80/tcp                     DENY IN     192.0.2.0/24
  [ 4] 80/tcp                     ALLOW IN    Anywhere
  [ 5] 22/tcp (v6)                ALLOW IN    Anywhere (v6)
  [ 6] 53 (v6)                    ALLOW IN    Anywhere (v6)
  [ 7] 80/tcp (v6)                ALLOW IN    Anywhere (v6)

  $ sudo ufw delete deny from 192.0.2.0/24 to any port 80 proto tcp
  Rule deleted
  $ sudo ufw insert 3 deny from 192.0.2.0/24 to any port 80 proto tcp
  Rule inserted
  $ sudo ufw delete 3
  Deleting:
   deny from 192.0.2.0/24 to any port 80 proto tcp
  Proceed with operation (y|n)? y
  Rule deleted
</code></pre>

<p>「from」で IPv4 アドレスを指定したので、ルールは自動的に IPv4 の方だけになって IPv6 には何も影響していません。</p>

<h2>on INTERFACE</h2>

<p>特定のネットワークインターフェイスを通るパケットだけ対象にしたい場合は「on INTERFACE」を使います。
例えばプロキシを必須にするなどで外部の 80,443 は直接繋がせない、とする場合は以下のようになります。
外部への通信なので「out」もつけています。</p>

<p>また、内部から外部への通信は「deny」で無視すると応答がなくなって、タイムアウト待ちなどでトラブルシューティングに時間がかかるので、すぐに拒否される「reject」を使うのがおすすめです。</p>

<p>インターフェイスは iptables と同様に「ppp+」で「ppp0」や「ppp1」などをまとめて指定できます。
そのため「enp0s3」だったり「ens3」だったりする stretch では「en+」でまとめて指定するとハードウェア構成に依存せずに設定を共有しやすくなると思います。</p>

<pre><code>  $ sudo ufw reject out on en+ to any port 80,443 proto tcp
  Rule added
  Rule added (v6)
  $ sudo ufw status
  Status: active

  To                         Action      From
  --                         ------      ----
  22/tcp                     ALLOW       Anywhere
  53                         ALLOW       Anywhere
  80/tcp                     ALLOW       Anywhere
  22/tcp (v6)                ALLOW       Anywhere (v6)
  53 (v6)                    ALLOW       Anywhere (v6)
  80/tcp (v6)                ALLOW       Anywhere (v6)

  80,443/tcp                 REJECT OUT  Anywhere on en+
  80,443/tcp (v6)            REJECT OUT  Anywhere (v6) on en+

  $ curl --head www.debian.org
  curl: (7) Failed to connect to www.debian.org port 80: Connection refused
  $ sudo ufw delete reject out on en+ to any port 80,443 proto tcp
  Rule deleted
  Rule deleted (v6)
</code></pre>

<p>deny だと応答がなくなったので Ctrl+C で止めました。</p>

<pre><code>  $ sudo ufw deny out on en+ to any port 80,443 proto tcp
  Rule added
  Rule added (v6)
  $ curl --head www.debian.org
  ^C
  $ sudo ufw delete deny out on en+ to any port 80,443 proto tcp
  Rule deleted
  Rule deleted (v6)
</code></pre>

<h2>アプリケーションで指定</h2>

<p>「/etc/ufw/applications.d/」にアプリケーション名で設定するための情報が入っていて、「sudo ufw app list」で一覧できます。</p>

<pre><code>  $ sudo ufw app list
  Available applications:
    AIM
    Bonjour
    CIFS
    DNS
    Deluge
    IMAP
    IMAPS
    IPP
    KTorrent
    Kerberos Admin
    Kerberos Full
    Kerberos KDC
    Kerberos Password
    LDAP
    LDAPS
    LPD
    MSN
    MSN SSL
    Mail submission
    NFS
    OpenSSH
    POP3
    POP3S
    PeopleNearby
    SMTP
    SSH
    Socks
    Telnet
    Transmission
    Transparent Proxy
    VNC
    WWW
    WWW Cache
    WWW Full
    WWW Secure
    XMPP
    Yahoo
    qBittorrent
    svnserve
  $ ls /etc/ufw/applications.d/
  openssh-server  ufw-chat             ufw-dnsserver   ufw-loginserver  ufw-printserver  ufw-webserver
  ufw-bittorent   ufw-directoryserver  ufw-fileserver  ufw-mailserver   ufw-proxyserver
  $ cat /etc/ufw/applications.d/openssh-server
  [OpenSSH]
  title=Secure shell server, an rshd replacement
  description=OpenSSH is a free implementation of the Secure Shell protocol.
  ports=22/tcp
  $ cat /etc/ufw/applications.d/ufw-webserver
  [WWW]
  title=Web Server
  description=Web server
  ports=80/tcp

  [WWW Secure]
  title=Web Server (HTTPS)
  description=Web Server (HTTPS)
  ports=443/tcp

  [WWW Full]
  title=Web Server (HTTP,HTTPS)
  description=Web Server (HTTP,HTTPS)
  ports=80,443/tcp

  [WWW Cache]
  title=Web Server (8080)
  description=Web Server (8080)
  ports=8080/tcp
</code></pre>

<p>アプリ名をポート番号とプロトコルの組み合わせの代わりに使うことができます。
スペースが入っているアプリ名の場合はシェルで引数が分割されないようにクォートする必要があるので、注意が必要です。</p>

<pre><code>  $ sudo ufw reject out OpenSSH
  Rule added
  Rule added (v6)
  $ sudo ufw reject out to 10.0.0.0/8 app 'WWW Full'
  Rule added
  $ sudo ufw status
  Status: active

  To                         Action      From
  --                         ------      ----
  22/tcp                     ALLOW       Anywhere
  53                         ALLOW       Anywhere
  80/tcp                     ALLOW       Anywhere
  22/tcp (v6)                ALLOW       Anywhere (v6)
  53 (v6)                    ALLOW       Anywhere (v6)
  80/tcp (v6)                ALLOW       Anywhere (v6)

  OpenSSH                    REJECT OUT  Anywhere
  10.0.0.0/8 WWW Full        REJECT OUT  Anywhere
  OpenSSH (v6)               REJECT OUT  Anywhere (v6)
  $ sudo ufw delete reject out to 10.0.0.0/8 app WWW Full
  ERROR: Wrong number of arguments
  $ sudo ufw delete reject out to 10.0.0.0/8 app 'WWW Full'
  Rule deleted
  $ sudo ufw delete reject out OpenSSH
  Rule deleted
  Rule deleted (v6)
</code></pre>

<h2>limit</h2>

<p>拒否の仕方に deny と reject があるのと似た感じで、許可の方にも allow と limit の2種類があります。
limit は brute force attack の緩和に使えます。
30 秒間に 6 回までしか新規接続ができない、という設定になるようです。
正常な接続かどうかに関わらず、iptables の層で拒否してしまうので、例えば構成管理ツールなどで自分が短時間に頻繁に接続する可能性がある場合は避けた方が良いです。</p>

<pre><code>  $ sudo ufw limit 22/tcp
  Rule updated
  Rule updated (v6)
  $ sudo ufw status
  Status: active

  To                         Action      From
  --                         ------      ----
  22/tcp                     LIMIT       Anywhere
  53                         ALLOW       Anywhere
  80/tcp                     ALLOW       Anywhere
  22/tcp (v6)                LIMIT       Anywhere (v6)
  53 (v6)                    ALLOW       Anywhere (v6)
  80/tcp (v6)                ALLOW       Anywhere (v6)
</code></pre>

<p>「/etc/ufw/user.rules」に設定されている内容は以下の通りです。</p>

<pre><code>  ### tuple ### limit tcp 22 0.0.0.0/0 any 0.0.0.0/0 in
  -A ufw-user-input -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set
  -A ufw-user-input -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 30 --hitcount 6 -j ufw-user-limit
  -A ufw-user-input -p tcp --dport 22 -j ufw-user-limit-accept
</code></pre>

<h2>コマンドラインで指定できない設定を入れる方法</h2>

<p>「/etc/ufw/before.rules」と「/etc/ufw/before6.rules」が ufw のルールの前に読み込まれる iptables-restore と ip6tables-restore のルールファイルになっているので、
IPsec の ESP の許可などの ufw コマンドで設定できないルールはこのファイルを直接編集すれば良いでしょう。
ufw で設定したルールより後に読み込まれる「after.rules」と「after6.rules」もあるので、用途によってはこちらを使っても良いでしょう。</p>

<h2>NAT 設定</h2>

<p>ちょっと複雑なネットワークだと、例えば POSTROUTING の MASQUERADE 設定はよく使うと思うのですが、「ufw」のコマンドラインでは nat テーブルの設定はできないので、「before.rules」などに追加することになります。</p>

<p>以下のような設定を「*filter」より上 (または COMMIT より下) に追加すると NAT の設定ができます。
反映させるには「ufw reload」を実行する必要があります。
また、「-F」の行が重要で、入れていないと「ufw reload」を実行するたびに nat テーブルの設定が増えていくことになります。</p>

<pre><code>  # NAT table rules
  ,*nat
  :POSTROUTING ACCEPT [0:0]
  -F
  # Allow traffic from OpenVPN client to enp0s3
  -A POSTROUTING -s 192.168.10.0/24 -o en+ -j MASQUERADE
  # Allow traffic from 192.168.1.0/24 (server's LAN subnet) to OpenVPN client
  -A POSTROUTING -s 192.168.1.0/24 -o tun0 -j MASQUERADE
  COMMIT
</code></pre>

<p>iptables-restore で直接設定したものになるので、確認は「sudo iptables -t nat -nL」になります。</p>

<pre><code>  $ sudoedit /etc/ufw/before.rules
  (-F がない場合)
  $ sudo ufw reload
  Firewall reloaded
  $ sudo ufw reload
  Firewall reloaded
  $ sudo iptables -t nat -nL
  Chain PREROUTING (policy ACCEPT)
  target     prot opt source               destination

  Chain INPUT (policy ACCEPT)
  target     prot opt source               destination

  Chain OUTPUT (policy ACCEPT)
  target     prot opt source               destination

  Chain POSTROUTING (policy ACCEPT)
  target     prot opt source               destination
  MASQUERADE  all  --  192.168.10.0/24      0.0.0.0/0
  MASQUERADE  all  --  192.168.1.0/24       0.0.0.0/0
  MASQUERADE  all  --  192.168.10.0/24      0.0.0.0/0
  MASQUERADE  all  --  192.168.1.0/24       0.0.0.0/0
  $ sudoedit /etc/ufw/before.rules
  (-F を追加)
  $ sudo ufw reload
  Firewall reloaded
  $ sudo iptables -t nat -nL
  Chain PREROUTING (policy ACCEPT)
  target     prot opt source               destination

  Chain INPUT (policy ACCEPT)
  target     prot opt source               destination

  Chain OUTPUT (policy ACCEPT)
  target     prot opt source               destination

  Chain POSTROUTING (policy ACCEPT)
  target     prot opt source               destination
  MASQUERADE  all  --  192.168.10.0/24      0.0.0.0/0
  MASQUERADE  all  --  192.168.1.0/24       0.0.0.0/0
</code></pre>

<h2>routed の有効化</h2>

<p>初期状態では disabled になっていますが、「/etc/ufw/sysctl.conf」でも「/etc/sysctl.conf」でも「/etc/sysctl.d/*.conf」でも良いので、カーネルの設定を有効にすると「disabled」ではなくなります。</p>

<pre><code>  $ sudo ufw status verbose | grep Default
  Default: deny (incoming), allow (outgoing), disabled (routed)
  $ sudo tee /etc/sysctl.d/50-local.conf
  net.ipv4.ip_forward=1
  net.ipv6.conf.all.forwarding=1
  $ sudo sysctl -p /etc/sysctl.d/50-local.conf
  net.ipv4.ip_forward = 1
  net.ipv6.conf.all.forwarding = 1
  $ sudo ufw status verbose | grep Default
  Default: deny (incoming), allow (outgoing), deny (routed)
</code></pre>

<h2>FORWARD チェインの設定</h2>

<p>「ufw route」で iptables の FORWARD チェインの設定もできます。
「ufw route」は changelog によると ufw 0.34 から追加されているので、Debian だと jessie の 0.33-2 だと使えなくて stretch の 0.35-4 から使えるようです。</p>

<p>iptables の FORWARD チェインに対する設定になる以外は INPUT や OUTPUT チェインに対する操作と変わりません。</p>

<pre><code>  $ sudo ufw route allow from 192.168.10.0/24 to 10.0.0.0/8 port 80 proto tcp
  Rule added
  $ sudo ufw status
  Status: active

  To                         Action      From
  --                         ------      ----
  22/tcp                     LIMIT       Anywhere
  53                         ALLOW       Anywhere
  80/tcp                     ALLOW       Anywhere
  22/tcp (v6)                LIMIT       Anywhere (v6)
  53 (v6)                    ALLOW       Anywhere (v6)
  80/tcp (v6)                ALLOW       Anywhere (v6)

  10.0.0.0/8 80/tcp          ALLOW FWD   192.168.10.0/24
  $ sudo ufw route delete allow from 192.168.10.0/24 to 10.0.0.0/8 port 80 proto tcp
  Rule deleted
</code></pre>

<h2>デフォルトポリシーの変更</h2>

<p>「 <code>ufw [--dry-run] default allow|deny|reject [incoming|outgoing|routed]</code> 」でチェーンのデフォルトのポリシーを変更できます。</p>

<p>stretch の ufw では、「default reject」は「 <code>ufw*-reject-*</code> 」チェーンで reject していて、FORWARD チェインなどの指定した組み込みのチェーンの policy が REJECT に変わるわけではないようです。</p>

<pre><code>  $ sudo ufw status verbose | grep Default
  Default: deny (incoming), allow (outgoing), deny (routed)
  $ grep FORWARD /etc/default/ufw
  DEFAULT_FORWARD_POLICY="DROP"
  $ sudo iptables -nL | grep FORWARD
  Chain FORWARD (policy DROP)
  $ sudo iptables -nL | grep -A2 'Chain.*reject-forward'
  Chain ufw-reject-forward (1 references)
  target     prot opt source               destination

  $ sudo ufw default reject routed
  Default routed policy changed to 'reject'
  (be sure to update your rules accordingly)
  $ grep FORWARD /etc/default/ufw
  DEFAULT_FORWARD_POLICY="REJECT"
  $ sudo iptables -nL | grep FORWARD
  Chain FORWARD (policy DROP)
  $ sudo ufw status verbose | grep Default
  Default: deny (incoming), allow (outgoing), reject (routed)
  $ sudo iptables -nL | grep -A2 'Chain.*reject-forward'
  Chain ufw-reject-forward (1 references)
  target     prot opt source               destination
  REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-port-unreachable
  $ sudo ufw default deny routed
  Default routed policy changed to 'deny'
  (be sure to update your rules accordingly)
</code></pre>

<h2>コメント</h2>

<p>今の ufw のルールにはコメントがつけられるようになっています。
コメントは ufw のルールに紐づいていて、 iptables の方には特に何も影響はないようです。</p>

<pre><code>  $ sudo ufw allow 60000:61000/udp comment "mobile shell"
  Rule added
  Rule added (v6)
  $ sudo ufw status | grep 60000
  60000:61000/udp            ALLOW       Anywhere                   # mobile shell
  60000:61000/udp (v6)       ALLOW       Anywhere (v6)              # mobile shell
  $ sudo grep 60000 /etc/ufw/user*.rules
  /etc/ufw/user6.rules:### tuple ### allow udp 60000:61000 ::/0 any ::/0 in comment=6d6f62696c65207368656c6c
  /etc/ufw/user6.rules:-A ufw6-user-input -p udp -m multiport --dports 60000:61000 -j ACCEPT
  /etc/ufw/user.rules:### tuple ### allow udp 60000:61000 0.0.0.0/0 any 0.0.0.0/0 in comment=6d6f62696c65207368656c6c
  /etc/ufw/user.rules:-A ufw-user-input -p udp -m multiport --dports 60000:61000 -j ACCEPT
</code></pre>

<h2>ufw show REPORT</h2>

<p>ufw の man の REPORTS セクションで紹介されているように、「ufw show REPORT」で設定状態などを表示できます。
「sudo ufw show listening」は実際に待ち受けしているポートを ufw の設定状況と一緒に一覧できるので、便利そうです。</p>

<ul>
<li>sudo ufw show raw</li>
<li>sudo ufw show builtins</li>
<li>sudo ufw show before-rules</li>
<li>sudo ufw show user-rules</li>
<li>sudo ufw show after-rules</li>
<li>sudo ufw show logging-rules</li>
<li>sudo ufw show listening</li>
<li>sudo ufw show added</li>
</ul>


<pre><code>  $ sudo ufw show listening
  tcp:
    111 * (rpcbind)
    22 * (sshd)
     [ 1] allow 22/tcp

  tcp6:
    111 * (rpcbind)
    22 * (sshd)
     [ 2] allow 22/tcp

  udp:
    1015 * (rpcbind)
    111 * (rpcbind)
    68 * (dhclient)
  udp6:
    1015 * (rpcbind)
    111 * (rpcbind)
</code></pre>

<h2>ログレベル</h2>

<p>デフォルトだと拒否された時のログが rate limit 付きで /var/log/ufw.log などに残りますが、「 <code>ufw [--dry-run] logging on|off|LEVEL</code> 」で、どのくらいログを残すのか設定できます。</p>

<p>設定できるのは on, off, low, medium, high, full のようです。
詳細は man を参照してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[webhook でサイトの git pull をする設定をした]]></title>
    <link href="http://blog.n-z.jp/blog/2018-01-03-webhook-git-pull.html"/>
    <updated>2018-01-03T18:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/webhook-git-pull</id>
    <content type="html"><![CDATA[<p>GitLab.com に git push した時に webhook で通知を受け取って git pull という設定をしました。</p>

<p>方針としては Web サーバーの実行ユーザー権限の cgi で通知用のファイルを更新して、 systemd の <code>*.path</code> で監視して、別途ディレクトリの所有者権限でアップデートのシェルスクリプトを実行して、アップデートのログは journald に任せるという感じにしました。</p>

<!--more-->


<h2>GitLab.com の設定</h2>

<p>Webhook が使えるシステムなら GitHub などでも同様に設定可能だと思います。</p>

<ul>
<li>Settings - Integrations で Webhooks 設定</li>
<li>URL: <code>https://lilo.linux.or.jp/trigger/update.cgi</code> のような感じ</li>
<li>Secret Token あり</li>
<li>Trigger : Push events のみ</li>
<li>Enable SSL verification はチェックありのまま</li>
</ul>


<h2>trigger cgi</h2>

<p>URL がわかっていても Secret Token がちゃんと設定されていないリクエストはエラーを返すようにしました。</p>

<p>内容はチェックせずに通知用のファイルにリクエスト内容をそのまま書き込んでデバッグ用に使えるようにしました。</p>

<p><code>/home/www</code> は CGI の権限で書き込めるディレクトリです。</p>

<pre><code class="sh">#!/bin/sh
set -e
if [ x"$HTTP_X_GITLAB_TOKEN" = x"XXXXXXXXXXXXXXXXXXXX" ]; then
  cat &gt; /home/www/trigger_update_web
  echo "Content-Type: text/plain; charset=utf-8"
  echo
  echo OK
else
  echo "Status: 403"
  echo "Content-Type: text/plain; charset=utf-8"
  echo
  echo NG
fi
</code></pre>

<h2>systemd の設定追加</h2>

<p>後述のファイルを以下のように追加して設定しました。</p>

<pre><code>  sudo cp lilo_web_update.path /etc/systemd/system
  sudo cp lilo_web_update.service /etc/systemd/system
  sudo systemctl daemon-reload
  sudo systemctl start lilo_web_update.path
</code></pre>

<p>2018-01-28 追記: 以下のように enable もしておかないと再起動後に止まってしまっていました。</p>

<pre><code>  sudo systemctl enable lilo_web_update.path
</code></pre>

<h2><code>lilo_web_update.path</code></h2>

<p><code>trigger_update_web</code> ファイルを <code>PathModified</code> で監視して変化があれば <code>lilo_web_update.service</code> を実行するようにしました。</p>

<pre><code>[Unit]
Description=Trigger update web

[Path]
PathModified=/home/www/trigger_update_web

[Install]
WantedBy=multi-user.target
</code></pre>

<p>2018-01-28 追記: WantedBy の target 名が間違っていたのを修正しました。</p>

<h2><code>lilo_web_update.service</code></h2>

<p>Web コンテンツに書き込めるユーザーでシェルスクリプトを実行します。</p>

<pre><code>[Unit]
Description=Update web

[Service]
Type=oneshot
ExecStart=/path/to/lilo_web_update.sh
User=someuser
Group=someuser
</code></pre>

<h2><code>lilo_web_update.sh</code></h2>

<p>flock コマンドで同時実行を抑制 (同時実行は後の方が失敗終了) した上で、何か変更されていたらそれを捨てて、 <code>git pull</code> でリモートのコンテンツで上書きするようにしています。</p>

<p>とりあえず自分が知っているコマンドの中でクリーンにできるものとして <code>git checkout .</code> と <code>git clean -dfx</code> を使っているだけなので、もっと良い方法があるかもしれません。</p>

<pre><code class="bash">#!/bin/bash
set -euxo pipefail
exec {lock_fd}&lt;"$0"
flock --nonblock "${lock_fd}"
cd "$(dirname "$0")/.."
git checkout .
git clean -dfx
git pull
</code></pre>

<h2>apache2 設定</h2>

<p>trigger ディレクトリに cgi-bin の設定を参考にして ExecCGI と AddHandler の設定をしました。</p>

<pre><code>&lt;Directory /path/to/trigger/&gt;
        AllowOverride None
        Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
        Require all granted
        AddHandler cgi-script .cgi
&lt;/Directory&gt;
</code></pre>

<p><code>/etc/apache2/conf-enabled/security.conf</code> の <code>.svn*</code> へのアクセスを禁止する設定を参考にして、 <code>.git*</code> へのアクセスを禁止しました。</p>

<pre><code>&lt;DirectoryMatch "/\.git"&gt;
   Require all denied
&lt;/DirectoryMatch&gt;
</code></pre>

<h2>動作確認</h2>

<ul>
<li><code>sudo -u someuser /path/to/lilo_web_update.sh</code> で git pull の動作確認</li>
<li><code>touch /home/www/trigger_update_web</code> と <code>sudo systemctl status lilo_web_update.service</code> で PathModified 経由での実行確認</li>
<li><code>curl -H 'X-Gitlab-Token: XXXXXXXXXXXXXXXXXXXX' https://lilo.linux.or.jp/trigger/update.cgi</code> で webhook 経由での動作確認</li>
</ul>


<h2>まとめ</h2>

<p>git push で webhook 経由でコンテンツを更新して、 journald でログを確認できるシステムを構築しました。
Unix 的にそれぞれは大した設定はしていないのですが、組み合わせるとそれなりの設定量になりました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 129 回関西 Debian 勉強会 に参加しました]]></title>
    <link href="http://blog.n-z.jp/blog/2017-11-26-kansai-debian-meeting.html"/>
    <updated>2017-11-26T21:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/kansai-debian-meeting</id>
    <content type="html"><![CDATA[<p><a href="https://wiki.debian.org/KansaiDebianMeeting/20171126">第 129 回関西 Debian 勉強会</a> に参加しました。
一般ユーザー権限で LXC を使ってみるという内容でした。</p>

<!--more-->


<h2>会場</h2>

<p>いつもの福島区民センターでした。</p>

<h2>事前課題</h2>

<pre><code> lxc libvirt0 libpam-cgroup libpan-cgroup libpam-cgfs bridge-utils
</code></pre>

<p>とあったうち libpan-cgroup というのは間違いだったようです。</p>

<p><a href="https://wiki.debian.org/LXC">https://wiki.debian.org/LXC</a> 参照。</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Eucalyptus_%28software%29">Eucalyptus (software)</a> は開発が止まっている?</li>
<li><a href="https://ja.wikipedia.org/wiki/Xen_%28%E4%BB%AE%E6%83%B3%E5%8C%96%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%29#Hyper-V.E3.81.A8.E3.81.AE.E9.96.A2.E4.BF.82">Hyper-Vとの関係</a> によると Microsoft と XenSource は共同でやっているかも。</li>
</ul>


<h2>仮想化について</h2>

<p><a href="http://www.kernelvm.org/ima-made-no-matome/kaneru-vm-mian-qiang-hui-guan-xi-qino-can">カーネル/VM勉強会@関西 其の参 - カーネル／VM探検隊</a> から「BHyVeってなんや」を参考にしながら概要を解説</p>

<h2>Debian Stretch で LXC を使う</h2>

<ul>
<li>vagrant で <a href="https://app.vagrantup.com/bento/boxes/debian-9.2">bento/debian-9.2</a> の box を使って試しました</li>
<li>lxc-net を有効にするために <code>/etc/default/lxc</code> で <code>USE_LXC_BRIDGE="true"</code> に変更 (Debian Wiki は記述が古い (testing の時のパッケージが変更途中の内容?) のか <code>/etc/default/lxc-net</code> と書いてあるがそんなファイルはなかった)</li>
<li>lxc-net の変更を反映するために再起動した (<code>sudo systemctl start lxc-net</code> とかでも反映できるかもしれないが未確認)</li>
<li><code>lxc-checkconfig</code> でチェック (今の安定版は全部緑の enabled になるはず (昔はカーネルが対応していなくてダメなものがあったはず) )</li>
<li><code>sudo sh -c 'echo "kernel.unprivileged_userns_clone=1" &gt; /etc/sysctl.d/80-lxc-userns.conf'</code></li>
<li><code>sudo sysctl --system</code></li>
<li><p><code>kernel.unprivileged_userns_clone</code> の設定は Debian 固有のパッチの設定らしい? (1の方がバニラカーネルのデフォルト動作っぽい?)</p></li>
<li><p><code>sudo usermod --add-subuids 1258512-1324047 $USER</code> と <code>sudo usermod --add-subgids 1258512-1324047 $USER</code> はしなくても <code>/etc/subuid</code> と <code>/etc/subgid</code> に入っていた (<code>usermod</code> の引数は端の値の指定で <code>/etc/sub[ug]id</code> ファイルに書かれているのは開始 id と個数で別の意味なので注意)</p></li>
</ul>


<pre><code>vagrant@debian-9:~$ cat /etc/subuid
vagrant:100000:65536
vagrant@debian-9:~$ cat /etc/subgid
vagrant:100000:65536
</code></pre>

<ul>
<li><code>echo "$USER veth lxcbr0 10"| sudo tee -i /etc/lxc/lxc-usernet</code> で一般ユーザー権限で作成できるブリッジの数を制限するらしい (<code>lxcbr0</code> の部分はブリッジ名依存)</li>
<li><code>mkdir -p .config/lxc</code></li>
<li><code>.config/lxc/default.conf</code> を作成</li>
<li><code>id_map</code> の部分は subuid と subgid と同じ値にする必要あり</li>
<li><code>lxcbr0</code> の部分も <code>ip</code> コマンドなどで確認して合わせる必要あり</li>
</ul>


<pre><code>vagrant@debian-9:~$ cat .config/lxc/default.conf
lxc.include = /etc/lxc/default.conf
# Subuids and subgids mapping
lxc.id_map = u 0 100000 65536
lxc.id_map = g 0 100000 65536
# "Secure" mounting
lxc.mount.auto = proc:mixed sys:ro cgroup:mixed

# Network configuration
lxc.network.type = veth
lxc.network.link = lxcbr0
lxc.network.flags = up
#lxc.network.hwaddr = 00:16:3e:xx:xx:xx
</code></pre>

<ul>
<li>hwaddr は <a href="https://ja.wikipedia.org/wiki/MAC%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">MACアドレス</a> 参照</li>
<li>コメントアウトしてみると自動設定になった</li>
</ul>


<h2>lxc-create</h2>

<p>特権だと <code>/var/lib/lxc</code> を使われるが、一般ユーザー権限だと普通は書き込めないのでディレクトリ指定をする必要あり (絶対パスじゃないとダメらしい)</p>

<pre><code>vagrant@debian-9:~$ lxc-create -n stretch -t download -P ~/work/lxc
Setting up the GPG keyring
Downloading the image index

---
DIST    RELEASE ARCH    VARIANT BUILD
---
(略)
debian  stretch amd64   default 20171124_22:42
(略)
---
Distribution: debian
Release: stretch
Architecture: amd64

Downloading the image index
Downloading the rootfs
Downloading the metadata
The image cache is now ready
Unpacking the rootfs

---
You just created a Debian container (release=stretch, arch=amd64, variant=default)

To enable sshd, run: apt-get install openssh-server

For security reason, container images ship without user accounts
and without a root password.

Use lxc-attach or chroot directly into the rootfs to set a root password
or create user accounts.
vagrant@debian-9:~$
</code></pre>

<h2>起動</h2>

<pre><code>vagrant@debian-9:~$ lxc-ls --fancy -P ~/work/lxc
NAME    STATE   AUTOSTART GROUPS IPV4 IPV6
stretch STOPPED 0         -      -    -
vagrant@debian-9:~$ lxc-start -d -n stretch -P ~/work/lxc
vagrant@debian-9:~$ lxc-ls --fancy -P ~/work/lxc
NAME    STATE   AUTOSTART GROUPS IPV4 IPV6
stretch RUNNING 0         -      -    -
vagrant@debian-9:~$ lxc-ls --fancy -P ~/work/lxc
NAME    STATE   AUTOSTART GROUPS IPV4       IPV6
stretch RUNNING 0         -      10.0.3.146 -
</code></pre>

<h2>接続して動作確認</h2>

<pre><code>vagrant@debian-9:~$ lxc-attach -n stretch
You lack access to /home/vagrant/.local/share/lxc
vagrant@debian-9:~$ lxc-attach -n stretch -P ~/work/lxc
root@stretch:/# apt update
...
1 package can be upgraded. Run 'apt list --upgradable' to see it.
root@stretch:/# ls -al /var/lib/apt/lists/
total 65872
drwxr-xr-x 3 root root     4096 Nov 26 06:32 .
drwxr-xr-x 5 root root     4096 Nov 24 22:47 ..
-rw-r--r-- 1 root root 38923281 Oct  7 09:04 deb.debian.org_debian_dists_stretch_main_binary-amd64_Packages
-rw-r--r-- 1 root root 26443489 Oct  7 09:04 deb.debian.org_debian_dists_stretch_main_i18n_Translation-en
-rw-r--r-- 1 root root   117945 Oct  7 09:46 deb.debian.org_debian_dists_stretch_Release
-rw-r--r-- 1 root root     2479 Oct  7 09:52 deb.debian.org_debian_dists_stretch_Release.gpg
-rw-r----- 1 root root        0 Nov 26 06:32 lock
drwx------ 2 _apt root     4096 Nov 26 06:32 partial
-rw-r--r-- 1 root root    62959 Nov 25 10:01 security.debian.org_dists_stretch_updates_InRelease
-rw-r--r-- 1 root root  1257072 Nov 21 22:08 security.debian.org_dists_stretch_updates_main_binary-amd64_Packages
-rw-r--r-- 1 root root   624275 Nov 21 22:08 security.debian.org_dists_stretch_updates_main_i18n_Translation-en
root@stretch:/# exit
vagrant@debian-9:~$ ls -al ~/work/lxc/stretch/rootfs/var/lib/apt/lists/
total 65872
drwxr-xr-x 3 100000 100000     4096 Nov 26 06:32 .
drwxr-xr-x 5 100000 100000     4096 Nov 24 22:47 ..
-rw-r--r-- 1 100000 100000 38923281 Oct  7 09:04 deb.debian.org_debian_dists_stretch_main_binary-amd64_Packages
-rw-r--r-- 1 100000 100000 26443489 Oct  7 09:04 deb.debian.org_debian_dists_stretch_main_i18n_Translation-en
-rw-r--r-- 1 100000 100000   117945 Oct  7 09:46 deb.debian.org_debian_dists_stretch_Release
-rw-r--r-- 1 100000 100000     2479 Oct  7 09:52 deb.debian.org_debian_dists_stretch_Release.gpg
-rw-r----- 1 100000 100000        0 Nov 26 06:32 lock
drwx------ 2 100104 100000     4096 Nov 26 06:32 partial
-rw-r--r-- 1 100000 100000    62959 Nov 25 10:01 security.debian.org_dists_stretch_updates_InRelease
-rw-r--r-- 1 100000 100000  1257072 Nov 21 22:08 security.debian.org_dists_stretch_updates_main_binary-amd64_Packages
-rw-r--r-- 1 100000 100000   624275 Nov 21 22:08 security.debian.org_dists_stretch_updates_main_i18n_Translation-en
</code></pre>

<h2>NAT</h2>

<p><a href="https://wiki.debian.org/LXC/SimpleBridge">https://wiki.debian.org/LXC/SimpleBridge</a> の</p>

<pre><code>up iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
</code></pre>

<p>は</p>

<pre><code>down iptables -t nat -D POSTROUTING -o wlan0 -j MASQUERADE
</code></pre>

<p>もないと up down を繰り返すと増えそう。</p>

<p>lxc-net で試した環境は自動で NAT 設定が入っていた。</p>

<pre><code>vagrant@debian-9:~$ sudo iptables -nL -t nat
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination

Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
MASQUERADE  all  --  10.0.3.0/24         !10.0.3.0/24
</code></pre>

<h2>停止</h2>

<p>資料にはなかったけど、個人的に停止と削除も試しました。</p>

<pre><code>vagrant@debian-9:~$ lxc-stop -n stretch -P ~/work/lxc
vagrant@debian-9:~$ lxc-ls --fancy -P ~/work/lxc
NAME    STATE   AUTOSTART GROUPS IPV4 IPV6
stretch STOPPED 0         -      -    -
</code></pre>

<h2>削除</h2>

<pre><code>vagrant@debian-9:~$ lxc-destroy -n stretch -P ~/work/lxc
Destroyed container stretch
vagrant@debian-9:~$ lxc-ls --fancy -P ~/work/lxc
vagrant@debian-9:~$ ls work/lxc/
lxc-monitord.log
</code></pre>

<h2>休憩中の話</h2>

<ul>
<li><a href="https://www.ubuntu.com/server/maas">https://www.ubuntu.com/server/maas</a></li>
</ul>


<h2>ネットワーク図</h2>

<ul>
<li>ネットワーク図を書いて議論</li>
<li><a href="https://twitter.com/YukiharuYABUKI/status/934688472845058054">https://twitter.com/YukiharuYABUKI/status/934688472845058054</a></li>
</ul>


<h2>次回</h2>

<ul>
<li>2017/12/24(日)</li>
</ul>


<h2>まとめ</h2>

<p>発表者の佐々木さんが病欠で、時間に余裕があったので、資料や Wiki の記述や不足点などをツッコミを入れたりするような感じになっていました。
その後は、ネットワーク図を書いて色々と議論をして、少し早めに終わりました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hyper-V のゲスト環境で systemd timer がうまく動いていなかった]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-07-hyperv-systemd-timer.html"/>
    <updated>2017-07-07T00:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/hyperv-systemd-timer</id>
    <content type="html"><![CDATA[<p>Hyper-V のゲストとしてインストールした Linux 環境で systemd timer の <code>RandomizedDelaySec</code> がおかしくて timer が実行されないことがあったのですが、Hyper-V の時刻の同期との相性が悪いのが原因でした。</p>

<!--more-->


<h2>環境</h2>

<ul>
<li>ホスト: Windows Server 2012</li>
<li>ゲスト: Ubuntu 16.04.2 LTS (xenial) と Debian GNU/Linux 9.0 (stretch)</li>
</ul>


<h2>現象</h2>

<p>journalctl で過去のログを確認してみると</p>

<pre><code> 6月 28 12:07:56 hostname systemd[9928]: Time has been changed
 6月 28 12:07:59 hostname systemd[9928]: Time has been changed
 6月 28 12:08:04 hostname systemd[9928]: Time has been changed
 6月 28 12:08:09 hostname systemd[9928]: Time has been changed
 6月 28 12:08:14 hostname systemd[9928]: Time has been changed
 6月 28 12:08:19 hostname systemd[9928]: Time has been changed
</code></pre>

<p>のように Time has been changed が頻繁に記録されていました。</p>

<p>再起動した後からは RandomizedDelaySec が設定されている timer のランダムな時間挿入が Time has been changed の直後におきていました。</p>

<pre><code> 6月 28 15:07:51 hostname systemd[1]: Time has been changed
 6月 28 15:07:51 hostname systemd[1]: apt-daily-upgrade.timer: Adding 46min 16.478521s random time.
 6月 28 15:07:51 hostname systemd[1]: apt-daily.timer: Adding 3h 45min 54.621700s random time.
 6月 28 15:07:56 hostname systemd[1]: Time has been changed
 6月 28 15:07:56 hostname systemd[1]: apt-daily-upgrade.timer: Adding 25min 59.320458s random time.
 6月 28 15:07:56 hostname systemd[1]: apt-daily.timer: Adding 11h 34min 9.012513s random time.
 6月 28 15:08:01 hostname systemd[1]: Time has been changed
 6月 28 15:08:01 hostname systemd[1]: apt-daily-upgrade.timer: Adding 42min 37.932995s random time.
 6月 28 15:08:01 hostname systemd[1]: apt-daily.timer: Adding 4h 48min 31.255279s random time.
 6月 28 15:08:06 hostname systemd[1]: Time has been changed
 6月 28 15:08:06 hostname systemd[1]: apt-daily-upgrade.timer: Adding 13min 44.192537s random time.
 6月 28 15:08:06 hostname systemd[1]: apt-daily.timer: Adding 38min 56.349412s random time.
</code></pre>

<p>自作した timer が実行されなくて <code>journalctl -u local-backup.timer</code> のように調べた時に「Adding &hellip; random time.」のログで埋まっていて、他の動いている timer との違いも特になくて悩んでいましたが、ふと <code>journalctl</code> (引数なし) を実行してみたら「Time has been changed」とセットでおきていることに気づきました。</p>

<h2>解決策</h2>

<p>「Time has been changed」で検索して最初に出てきた <a href="https://askubuntu.com/questions/888493/var-log-syslog-systemd1-time-has-been-changed-message-every-5-seconds">16.04 - /var/log/syslog &lsquo;systemd[1]: Time has been changed&rsquo; message every 5 seconds - Ask Ubuntu</a> に</p>

<blockquote><p>I encountered this issue of &ldquo;systemd[&hellip;]Time has been changed&rdquo; messages logged every five seconds in /var/log/syslog on a 16.04 server running under Windows 8.1 Hyper-V. To fix it, I disabled time synchronization on the Hyper-V side. In Hyper-V Manager, I highlighted the VM, selected &ldquo;Settings&hellip;&rdquo;, then &ldquo;Integration Services&rdquo;, unchecked &ldquo;Time synchronization&rdquo;, and clicked Apply. The messages stopped instantly - no VM restart was required.</p></blockquote>

<p>と書いてあったので、「設定&hellip;」から「統合サービス」の「時刻の同期」のチェックを外して (再起動なしで) 解決しました。</p>

<h2>解決確認</h2>

<p>「Time has been changed」も出なくなって「Adding &hellip; random time.」も出なくなって、翌日まで待ってみるとちゃんと実行されていたので、解決したようです。</p>

<h2>まとめ</h2>

<p>ntp サーバー機能も必要で、 ntp パッケージを入れている環境で発生したので、時刻の同期の仕方によっては発生しないのかもしれませんが、「Time has been changed」で検索して出てきた他の方法はログを無視するだけとか、根本的な解決になっていないものが多そうだったので、Hyper-V との組み合わせなら systemd-timesyncd でも発生するのかもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debian/Ubuntuで暗号化 LVM を使いつつ自動起動する]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-01-cryptsetup.html"/>
    <updated>2017-07-01T14:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/cryptsetup</id>
    <content type="html"><![CDATA[<p>さくらの VPS 環境でも ssh などの秘密鍵を置くなら、ディスクの暗号化は使いたいので、リリースされたばかりの Debian 9 の ISO をアップロードしてインストールして、暗号化されていない <code>/boot</code> に鍵ファイルを置いて自動起動を設定しました。</p>

<p>自動起動を設定するということはセキュリティ的には弱くなりますが、そこはホストを信用するということにしています。</p>

<p>自動起動設定時に <code>/etc/crypttab</code> の設定ミスで起動しなくなるということがあったので、そういう時の直し方も含めてまとめてみました。</p>

<!--more-->


<h2>確認環境</h2>

<ul>
<li>Debian GNU/Linux 9.0 (stretch)</li>
</ul>


<p>Ubuntu でも debian-installer ベースのインストーラーを使った場合は同じだと思います。
(Live 環境が起動するデスクトップ版のインストーラーの場合は暗号化 LVM でのインストールができるかどうか確認していないのでわかりません。)</p>

<p>他のバージョンの Debian でも luks 対応の cryptsetup があれば同じだと思います。</p>

<h2>インストール</h2>

<p>普通に netinst の iso でインストールします。</p>

<p>ただし途中の「ディスクのパーティショニング」で「ガイド - ディスク全体を使い、暗号化 LVM をセットアップする」を選んだ場合が対象です。
パーティションは <code>/</code> (と <code>/boot</code>) だけを想定しています。
暗号化のパスフレーズは鍵ファイル設定前の起動時と、鍵ファイルの追加時などしか使わないので、長くて強いものにしておくと良いと思います。</p>

<p>VirtualBox などの仮想環境で試す時は、暗号化前のランダムなデータで上書きでデータ用のパーティション全体に書き込みが発生するので、可変サイズのディスクではなく固定サイズのディスクにしておくと良いかもしれません。</p>

<h2>鍵ファイル作成</h2>

<p>まず、鍵ファイルを作成します。
内容作成前に root しか読み書きできないようにするために、touch して chmod しておきます。
次に urandom から読んだランダムデータを鍵ファイルに書き込みます。
前回設定したときは count=1 で 1024 バイトにしていましたが、今回は 4096 バイトにしてみました。
最後に root はパーミッションだと書き込み禁止できないので、誤操作防止 (削除やヒストリーから dd を再実行してしまうなど) のために chattr で ext2 の immutable 属性をつけておきます。(確認は <code>sudo lsattr /boot/keyfile</code>)</p>

<pre><code>sudo touch /boot/keyfile
sudo chmod 400 /boot/keyfile
sudo dd if=/dev/urandom of=/boot/keyfile bs=1024 count=4
sudo chattr +i /boot/keyfile
</code></pre>

<h2>情報確認</h2>

<ul>
<li><code>/etc/fstab</code>: <code>/dev/mapper/HOSTNAME--vg-root</code> が <code>/</code> に、 <code>/dev/mapper/HOSTNAME--vg_swap_1</code> がスワップパーティションに設定されています (<code>HOSTNAME</code> はインストーラーで設定したホスト名)</li>
<li><code>/etc/crypttab</code>: <code>vda5_crypt UUID=... none luks</code> で UUID で指定された <code>/dev/vda5</code> の暗号化が解除された状態が <code>/dev/mapper/vda5_crypt</code> として見えるということがわかります</li>
<li><code>lsblk</code>: ツリー上にみえます (<code>lsblk -f</code> だと UUID も表示されました)</li>
<li><code>ls -l /dev/disk/by-uuid</code>: uuid とデバイスの対応を確認できます (これで確認できる vda1 のパスをあとで使います)</li>
<li><code>sudo cryptsetup luksDump /dev/vda5</code>: luks の情報が表示できます (最初は Key Slot 0 だけ ENABLED で 1 から 7 は DISABLED になっています)</li>
</ul>


<h2>鍵追加</h2>

<p><code>cryptsetup luksAddKey</code> で鍵を追加します。
ここで最初に設定したパスフレーズが必要です。
なぜか <code>Key slot 0 unlocked.</code> が2回でましたが、特に問題はなさそうです。</p>

<pre><code>$ sudo cryptsetup -v luksAddKey /dev/vda5 /boot/keyfile
Enter any passphrase:
Key slot 0 unlocked.
Key slot 0 unlocked.
Command successful.
</code></pre>

<h2>鍵削除</h2>

<p>違うファイルを登録してしまったり、同じ鍵を複数回追加してしまったりしたときには <code>cryptsetup luksRemoveKey</code> で削除できます。
この場合はその鍵自身で unlock されるようなので、パスフレーズは不要でした。</p>

<pre><code>$ sudo cryptsetup -v luksRemoveKey /dev/vda5 /boot/keyfile
Key slot 1 unlocked.
Key slot 1 selected for deletion.
Command successful.
</code></pre>

<p>特定の Key Slot を DISABLED に戻したいときは <code>cryptsetup luksKillSlot</code> が使えます。
この場合はパスフレーズが必要でした。</p>

<pre><code>$ sudo cryptsetup -v luksKillSlot /dev/vda5 2
Key slot 2 selected for deletion.
Enter any remaining passphrase:
Key slot 0 unlocked.
Command successful.
</code></pre>

<h2>自動起動設定</h2>

<p>この段階ではまだ暗号化解除に使える鍵が増えただけで、再起動してもパスフレーズを要求されるままです。</p>

<p><code>/etc/crypttab</code> を以下のように書き換えます。</p>

<pre><code>vda5_crypt UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /dev/disk/by-uuid/yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy:/keyfile luks,keyscript=/lib/cryptsetup/scripts/passdev
</code></pre>

<p>xxx&hellip; の方の UUID は <code>/dev/vda5</code> の UUID なので、そのまま書き換えません。
第3項目の <code>none</code> を <code>/boot</code> パーティションのデバイスを UUID を使って指定したパス + <code>:</code> + <code>/boot</code> パーティション内での <code>keyfile</code> へのパスに書き換えます。
第4項目の <code>luks</code> は <code>luks,keyscript=/lib/cryptsetup/scripts/passdev</code> に書き換えます。
<code>passdev</code> は <code>cryptsetup</code> パッケージで用意されているファイルなので、そのまま書きます。</p>

<h2>initramfs 更新</h2>

<p>書き換えてもまだブートプロセスに反映されていないので、再起動してもパスフレーズを要求されるままなので、
最後に initramfs を更新します。</p>

<pre><code>sudo update-initramfs -u
</code></pre>

<p>これで再起動すると自動起動するようになります。</p>

<p>keyscript のパスが間違っていると以下のように WARNING が出るので、再起動する前に気づくことができますが、
keyfile の指定は間違っていても何も出ないので注意する必要があります。</p>

<pre><code>$ sudo update-initramfs -u
update-initramfs: Generating /boot/initrd.img-4.9.0-3-amd64
cryptsetup: WARNING: target vda5_crypt has an invalid keyscript, skipped
cryptsetup: WARNING: target vda5_crypt has an invalid keyscript, skipped
</code></pre>

<h2>起動失敗した場合</h2>

<p><code>/etc/crypttab</code> の設定をミスして起動しなくなった場合、 netinst の ISO からレスキューモードで起動すればパスフレーズでマウントできます。
そしてルートファイルシステムとして <code>/dev/HOSTNAME-vg/root</code> (<code>HOSTNAME</code> はインストーラーで設定したホスト名) を選び、 <code>/boot</code> パーティションもマウントしてシェルを起動します。</p>

<p>シェルは <code>/bin/sh -i</code> なので使いにくければ <code>bash</code> を起動して、<code>/etc/crypttab</code> を修正して <code>update-initramfs -u</code> で反映させます。
そして exit で抜けて再起動します。</p>

<p>レスキュー環境での修正が難しそうなら、 <code>none</code> と <code>luks</code> だけに戻して、パスフレーズを使う通常起動にしてから直すという方法もあります。</p>

<h2>最後に</h2>

<p>知らないところで暗号化が解除できてしまうのは、コンソール接続が毎回必要になることとのトレードオフですが、鍵ファイルでも解約時に <code>chattr -i /boot/keyfile; shred --remove /boot/keyfile</code> でディスク全体の削除に似た効果を期待できます。ただし <a href="https://linuxjm.osdn.jp/html/GNU_coreutils/man1/shred.1.html">Man page of SHRED</a>の警告に書いてあるように上書きを期待しているので、 ext2 になっている <code>/boot</code> はファイルシステム的には大丈夫だとしても、その下のブロックデバイスで上書きされていない可能性は残りそうです。</p>

<h2>まとめ</h2>

<p>暗号化 LVM を使うことで macOS の FileVault や Windows BitLocker のように簡単にディスクほぼ全体 (<code>/boot</code> を除く) を暗号化できました。
そして、再起動したい時に常にコンソールに接続できるとは限らない環境向けに鍵ファイルで自動起動の設定もできました。</p>

<p>トレードオフもちゃんと考えた上で設定すれば、安全な環境が簡単に作れると思いました。</p>
]]></content>
  </entry>
  
</feed>
