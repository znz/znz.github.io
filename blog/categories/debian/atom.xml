<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debian | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/debian/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2014-07-20T11:09:48+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vagrant CloudからWheezyを入れてみた]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-18-wheezy-from-vagrant-cloud.html"/>
    <updated>2014-07-18T21:30:25+09:00</updated>
    <id>http://blog.n-z.jp/blog/wheezy-from-vagrant-cloud</id>
    <content type="html"><![CDATA[<p>Debian 7.6 がリリースされたので、新しい box がないか探してみたところ、
<a href="http://www.vagrantbox.es/" title="A list of base boxes for Vagrant - Vagrantbox.es">A list of base boxes for Vagrant &ndash; Vagrantbox.es</a>
から探すのではなく
<a href="https://vagrantcloud.com/">Vagrant Cloud</a>
を使えば良いということがわかりました。</p>

<!--more-->


<h2>動作確認バージョン</h2>

<ul>
<li>VirtualBox 4.3.12</li>
<li>Vagrant 1.6.3</li>
<li><a href="https://vagrantcloud.com/ffuenf/debian-7.6.0-amd64" title="Debian Wheezy 7.6.0 x86_64">Debian Wheezy 7.6.0 x86_64</a> 0.0.27</li>
</ul>


<h2>書き換え</h2>

<p>古い box は</p>

<p><code>
  config.vm.box = ENV["VM_BOX"] || "opscode_debian-7.4_chef-provisionerless"
  config.vm.box_url = ENV["VM_BOX_URL"] || "http://opscode-vm-bento.s3.amazonaws.com/vagrant/virtualbox/opscode_debian-7.4_chef-provisionerless.box"
</code></p>

<p>と指定していたのを
<a href="https://github.com/ffuenf/vagrant-boxes" title="ffuenf/vagrant-boxes">ffuenf/vagrant-boxes</a>
からリンクされている
<a href="https://vagrantcloud.com/ffuenf/debian-7.6.0-amd64" title="ffuenf/debian-7.6.0-amd64">ffuenf/debian-7.6.0-amd64</a>
の説明通り <code>vagrant init ffuenf/debian-7.6.0-amd64</code> で作成された
<code>Vagrantfile</code> を参考にして、</p>

<p><code>
  config.vm.box = "ffuenf/debian-7.6.0-amd64"
</code></p>

<p>に書き換えました。</p>

<p>以前の box を使っている 古い VM を <code>vagrant destroy</code> ですべて破棄した後、
<code>vagrant box remove opscode_debian-7.4_chef-provisionerless</code>
で box も削除しました。</p>

<h2>余談</h2>

<p><code>vagrant box outdated</code> や <code>vagrant box update</code> の使い方がわからなかったのですが、
<code>box_url</code> でダウンロードしてきた box で使うものではなく Vagrant Cloud から
ダウンロードしてきた box で使うものだったようです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apt-cacher-ngでliveイメージ作成を繰り返す時の無駄なダウンロードを減らす]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-14-apt-cacher-ng.html"/>
    <updated>2014-07-14T23:53:14+09:00</updated>
    <id>http://blog.n-z.jp/blog/apt-cacher-ng</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/znz/rubylive-builder" title="rubylive-builder">rubylive-builder</a>
で
<a href="https://github.com/znz/rubylive" title="RubyLive">RubyLive</a>
という Debian wheezy ベースの Live イメージを作成するときに
<code>apt-get update</code> などで何度も無駄にダウンロードしてしまうので、
<code>apt-cacher-ng</code> で Live イメージ作成を繰り返す時の無駄なダウンロードを減らすことにしました。</p>

<!--more-->


<h2>Vagrant の provision でインストール</h2>

<p>Vagrantfile では</p>

<p>```ruby Vagrantfile
  config.vm.provision :shell do |shell|</p>

<pre><code>shell.path = "provision.sh"
</code></pre>

<p>  end
```</p>

<p>のようにシェルスクリプトでプロビジョニングしているだけだったので、
その中で以下のようにインストールして設定するようにしました。</p>

<p><code>bash provision.sh
apt-get install -y apt-cacher-ng
echo 'Acquire::http::Proxy "http://localhost:3142/";' &gt;/etc/apt/apt.conf.d/02proxy
</code></p>

<p>Vagrantfile で以下のようにポートフォワーディングを設定していれば
<a href="http://gihyo.jp/admin/serial/01/ubuntu-recipe/0315" title="第315回　apt-cacher-ngを使ってAPT用キャッシュプロキシの構築：Ubuntu Weekly Recipe｜gihyo.jp … 技術評論社">第315回　apt-cacher-ngを使ってAPT用キャッシュプロキシの構築：Ubuntu Weekly Recipe｜gihyo.jp … 技術評論社</a>
の2ページ目に説明があるようにヒット率などを確認できます。</p>

<p><code>ruby Vagrantfile
  # apt-cacher-ng
  config.vm.network "forwarded_port", guest: 3142, host: 3142
</code></p>

<h2>rake コマンドで環境変数を渡す</h2>

<p><code>APT_HTTP_PROXY=http://localhost:3142 rake</code> でも良かったのですが、
rake コマンドは引数の <code>FOO=bar</code> を <code>ENV</code> に設定してくれるので、
<code>rake APT_HTTP_PROXY=http://localhost:3142</code> で渡して、
Rakefile の中では以下のように受け取って <code>lb config</code> に渡しました。</p>

<p>```ruby Rakefile
desc &ldquo;config RubyLive&rdquo;
task :config => [:clean] do
  sh &lsquo;lb config&rsquo;
  if ENV[&lsquo;APT_HTTP_PROXY&rsquo;]</p>

<pre><code>sh "lb config --apt-http-proxy #{ENV['APT_HTTP_PROXY']}"
</code></pre>

<p>  end
end
```</p>

<h2>live-build で apt-cacher-ng を使う</h2>

<p>既に出てきたように
<code>lb config</code> の <code>--apt-http-proxy</code> オプションや <code>--apt-ftp-proxy</code> オプションで指定すると
Live イメージ作成の時に proxy を使ってくれるようになります。
今回は apt-line に <code>http</code> しか使っていないので
<code>--apt-http-proxy</code> だけ指定しています。</p>

<p>もちろん、作成後の Live イメージには proxy 設定は残りません。</p>

<h2>感想</h2>

<p>live-build は cache ディレクトリにも、かなりキャッシュしてくれるのですが、
<code>apt-get update</code> などの proxy じゃないとキャッシュしにくいものもあるので、
どんな場合でもダウンロード量削減に役に立ちそうだと思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyLiveを仮想環境で作成]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-13-build-rubylive-on-vm.html"/>
    <updated>2014-07-13T09:35:02+09:00</updated>
    <id>http://blog.n-z.jp/blog/build-rubylive-on-vm</id>
    <content type="html"><![CDATA[<p>最近流行りの仮想環境を使ってクリーンな wheezy 環境で RubyLive を作成できるようにしました。</p>

<p>VirtualBox + Vagrant は特殊な制限のない仮想環境なので Live イメージが作成できたのですが、
docker は後述の制限のために作成できませんでした。</p>

<!--more-->


<h2>RubyLive を Vagrant で作成</h2>

<p>Vagrant を使ってクリーンな wheezy 環境で RubyLive の ISO を作成できるようにしました。
こちらは問題なく作成できました。</p>

<h3>動作確認バージョン</h3>

<ul>
<li>VirtualBox 4.3.12</li>
<li>Vagrant 1.6.3</li>
</ul>


<h3>使い方</h3>

<ul>
<li>VirtualBox と Vagrant をインストールしておきます。</li>
<li><code>git clone https://github.com/znz/rubylive-builder</code> で取得します。</li>
<li><code>cd rubylive-builder</code> で中に入ります。</li>
<li><code>VM_MEMORY=512 vagrant up</code> のように適当なメモリ容量を指定して起動します。 (指定なしなら 1024)

<ul>
<li>他の項目も環境変数である程度変更できるようにしています。</li>
<li>初回起動時は box をダウンロードするので非常に時間がかかります。</li>
<li>provision で live-build などの必要なパッケージをインストールしています。</li>
</ul>
</li>
<li><code>vagrant ssh</code> でゲストにログインします。</li>
<li><code>/vagrant/rubylive.sh</code> を実行すると <code>/home/vagrant/rubylive</code> で RubyLive のイメージを作成します。

<ul>
<li>実行するたびにタイムスタンプの入ったファイル名の ISO ファイルが作成されます。</li>
<li>ネットワークの速度やマシンスペックに影響を受けると思いますが、試した環境では約1時間かかりました。</li>
</ul>
</li>
<li>作成できた <code>/home/vagrant/rubylive/*.iso</code> を <code>/vagrant</code> にコピーまたは移動して、ホスト OS 側に取り出します。</li>
<li>取り出した ISO ファイルを使用します。</li>
</ul>


<p>なぜか</p>

<pre><code>chroot: failed to run command `/usr/bin/env': No such file or directory
</code></pre>

<p>で失敗することがありましたが、再度 <code>/vagrant/rubylive.sh</code> を実行すれば問題なく作成できました。</p>

<h3>片付け方</h3>

<ul>
<li><code>vagrant destroy</code> で VM を破棄します。</li>
<li><code>git clone</code> した作業ディレクトリを削除します。</li>
<li>wheezy の box が不要なら <code>vagrant box remove opscode_debian-7.4_chef-provisionerless</code> で削除します。</li>
<li>Vagrant や VirtualBox も不要ならアンインストールします。</li>
</ul>


<h2>RubyLive を Docker で作成 (失敗)</h2>

<p>docker 環境の中では <code>chroot /rubylive/chroot mount -t proc proc /proc</code> が <code>EPERM</code> で失敗するため、作成できませんでした。</p>

<h3>動作確認バージョン</h3>

<ul>
<li>docker 1.1.1</li>
</ul>


<h3>試し方</h3>

<ul>
<li>docker をインストールしておきます。</li>
<li><code>git clone https://github.com/znz/rubylive-builder</code> で取得します。</li>
<li><code>docker build rubylive-builder</code> で作成に挑戦します。

<ul>
<li>または <code>cd rubylive-builder</code> で中に入って <code>docker build .</code> です。</li>
</ul>
</li>
<li><code>docker ps -a</code> で最近の CREATED の IMAGE を確認します。

<ul>
<li>もしくは <code>docker images</code> で確認します。</li>
<li>最後の失敗した後の状態は残っていないようでした。</li>
</ul>
</li>
<li><code>docker run -i -t --rm 4b8bc4523794 /bin/bash</code> のように中に入ります。

<ul>
<li>4b8bc4523794 のところは確認した IMAGE の ID にしてください。</li>
</ul>
</li>
<li><code>cd rubylive</code> で rubylive ディレクトリに入って <code>rake</code> で作成に再挑戦します。</li>
<li><code>less /rubylive/chroot/debootstrap/debootstrap.log</code> でログを確認したり、
<code>chroot /rubylive/chroot mount -t proc proc /proc</code> や
<code>mount -t proc proc /rubylive/chroot/proc</code> を直接実行してみたりして
原因を確認します。</li>
</ul>


<h3>失敗部分のメッセージ</h3>

<pre><code>W: Failure trying to run: chroot /rubylive/chroot mount -t proc proc /proc
W: See /rubylive/chroot/debootstrap/debootstrap.log for details
P: Begin unmounting filesystems...
P: Saving caches...
/usr/bin/env: apt-get: No such file or directory
rake aborted!
Command failed with status (1): [sudo lb build...]
</code></pre>

<p><code>/rubylive/chroot/debootstrap/debootstrap.log</code> をみると <code>mount: permission denied</code> と出ていました。</p>

<h3>Dockerfile 直接指定 (失敗)</h3>

<p><code>docker build https://raw.githubusercontent.com/znz/rubylive-builder/master/Dockerfile</code>
のように直接 URL を指定する方法は
<code>sources.list</code> を国内ミラーに差し替える部分が失敗して使えませんでした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debian 7 (wheezy) の RubyLive をカスタマイズ中]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-12-debian-ruby-live.html"/>
    <updated>2014-07-12T10:08:26+09:00</updated>
    <id>http://blog.n-z.jp/blog/debian-ruby-live</id>
    <content type="html"><![CDATA[<p>今年の
<a href="https://k-of.jp/2014/" title="KOF 2014：関西オープンフォーラム2014">KOF 2014：関西オープンフォーラム2014</a>
に向けて
<a href="https://github.com/znz/rubylive" title="RubyLive">RubyLive</a>
を作成しています。
fork 元の <a href="https://github.com/no6v/rubylive">no6v 版</a> との違いをまとめていきます。</p>

<!--more-->


<h2>カスタマイズの基本</h2>

<p>README から今回に関係する部分を引用しておくと以下のようになっています。</p>

<ul>
<li>config/hooks/

<ul>
<li>インストールの最後の方で実行するフックスクリプトを置くディレクトリ。</li>
<li>拡張子を .chroot にして実行権限を付けておく。</li>
</ul>
</li>
<li>config/includes.chroot/

<ul>
<li>このディレクトリを root に見立てて LiveCD 環境にコピーしたいファイルを置くディレクトリ。</li>
</ul>
</li>
<li>config/package-lists/

<ul>
<li>特別にインストールしたいパッケージのリストを置くディレクトリ。</li>
<li>拡張子を .list.chroot にしてパッケージ名を列挙する。</li>
</ul>
</li>
</ul>


<h2>壁紙などの変更</h2>

<p><code>resources.yml</code> で設定されたファイルは <code>url</code> から自動ダウンロードして <code>path</code> に置くようになっています。</p>

<p><code>size</code> と <code>sha256sum</code> をチェックするだけで違っていても削除はしないようなので、
ダウンロードに失敗した時は<code>path</code> のファイルは手動で削除する必要がありました。</p>

<p><code>path</code> を変更した時も古いファイルが残ってしまうので、削除する必要がありました。</p>

<h2>dconf の設定</h2>

<p><code>config/includes.chroot/etc/skel/.config/dconf/user</code>
に設定変更後のバイナリが置かれていて、
これはひどいと思ったので、
<code>config/includes.chroot/etc/skel/.gnomerc</code>
で <code>gsettings set</code> を使って設定するようにしました。</p>

<h3>壁紙の変更</h3>

<p>起動後の <code>dconf-editor</code> で選択肢を確認しつつ、
<code>gsettings set org.gnome.desktop.background picture-options centered</code>
にしたり、
<code>gsettings set org.gnome.desktop.background picture-uri 'file:///usr/share/images/desktop-base/RubyKaigi2014-commonLogo.svg</code>
にしたりしました。</p>

<p>2014-07-13 追記:
生成後のイメージに CC-BY 3.0 の説明がないのは良くないと思って、
<code>config/includes.chroot/etc/skel/README.txt</code>
に説明を追加することにしました。</p>

<h3>デスクトップのアイコン</h3>

<p>以前は <code>gnome-panel</code> (上のバーのところ) に起動用のアイコンを追加していたようですが、
<code>gsettings set</code> で設定しようとすると
<code>org.gnome.gnome-panel.layout object-id-list</code> の他に
<code>org.gnome.gnome-panel.layout.objects.object-0</code> や
<code>org.gnome.gnome-panel.layout.objects.object-0.instance-config</code> などの
複数設定が必要で管理の手間もかかりそうだったので、
<code>gsettings set org.gnome.desktop.background show-desktop-icons true</code>
でデスクトップのアイコンが見えるように変更しました。</p>

<h3>スクリーンセーバーの停止</h3>

<p><code>gsettings set org.gnome.desktop.screensaver idle-activation-enabled false</code>
で止めました。</p>

<h2>chm の変更</h2>

<p><a href="http://ruby.morphball.net/refm-remix.html" title="Rubyリファレンスマニュアル chm版リミックス">Rubyリファレンスマニュアル chm版リミックス</a>
の標準テーマのRuby 2.1.0向け chm に差し替えました。
zip ファイルなので、先ほどの <code>.gnomerc</code> でデスクトップに展開するようにしました。</p>

<p>xCHM v. 1.20 で背景画像や色とかがつかないようなので、サイズが小さい標準を選びました。</p>

<h2>パッケージ変更</h2>

<p><code>jfbterm</code> の代わりに <code>fbterm</code> にしたり、
<code>ruby-build</code> でビルドに必要なパッケージを追加したり、
<code>config/includes.chroot/etc/iceweasel/profile/prefs.js</code> の代わりに <code>iceweasel-l10n-ja</code> を追加したり、
<code>bash-completion</code> などを追加したりしました。</p>

<h2>ruby-build で ruby 2.1.2 のインストール</h2>

<p><a href="http://qiita.com/takahashim/items/406421d515ef1d4f1189" title="[ReVIEW Tips] DockerでRe:VIEW - Qiita">[ReVIEW Tips] DockerでRe:VIEW &ndash; Qiita</a>
を参考にして rbenv は使わずに ruby-build だけ使って <code>/usr/local</code> に ruby 2.1.2 をインストールしました。</p>

<h2>localepurge</h2>

<p>locale の設定は live-config で起動時にやっていて hook の中で
<code>DEBIAN_FRONTEND=noninteractive dpkg-reconfigure localepurge</code>
としても起動後と違って ja locale の設定がなかったので、
起動後や設定した後に <code>debconf-show localepurge</code> で確認した値を使って、
<code>localepurge/nopurge</code> が <code>NEEDSCONFIGFIRST</code> のままなら
<code>echo localepurge localepurge/nopurge string "ja, ja_JP.UTF-8" | debconf-set-selections</code>
で設定することにしました。</p>

<p>これで約 200MB ぐらい小さくなりました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[caffでキーサインした]]></title>
    <link href="http://blog.n-z.jp/blog/2014-06-22-key-sign-caff.html"/>
    <updated>2014-06-22T19:07:19+09:00</updated>
    <id>http://blog.n-z.jp/blog/key-sign-caff</id>
    <content type="html"><![CDATA[<p><a href="https://wiki.debian.org/KansaiDebianMeeting/20140622" title="第 85 回 関西 Debian 勉強会">第 85 回 関西 Debian 勉強会</a>
で
<a href="https://launchpad.net/~mocchi">坂本さん</a>とキーサインをしたので、そのメモです。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Ubuntu 12.04.4 LTS</li>
<li>gnupg 1.4.11-3ubuntu2.5</li>
<li>signing-party 1.1.4-1</li>
</ul>


<h2>事前準備</h2>

<p>事前にキーサインをするとわかっていれば <code>gpg-key2ps</code> コマンドで fingerprint の紙を用意しておくと良いと思います。
今回は少人数だったので、
fingerprint は画面上で見せて確認してもらいました。</p>

<h2>本人確認</h2>

<p>対面で運転免許証などの写真付きの身分証明書で名前を確認して、
それと署名対象の鍵の uid に入っている名前が一致するのを確認しておきます。
また、後で署名するために fingerprint の情報も入手しておきます。</p>

<h2>caff の設定</h2>

<p>基本的には
<a href="http://tokyodebian.alioth.debian.org/pdf/debianmeetingresume200910-presentation.pdf">Why GPG Key sign? 東京エリア Debian 勉強会 in OSC 2009 Tokyo/Fall</a>
の PDF の内容のままです。</p>

<h3>.caffrc</h3>

<p>自分の鍵 ID を <code>gpg --list-secret-keys</code> で確認すると、
<code>4096R/B4222F7A</code> とわかるので、
<code>gpg --fingerprint B4222F7A</code>
で fingerprint 全体を確認しておきます。
(fingerprint の末尾が鍵 ID です。)</p>

<p>spam よけのために email のところはちょっと改変していますが、
<code>~/.caffrc</code> は以下のように設定しています。
<code>keyid</code> は fingerprint の末尾のうち、
設定例と同じ長さだけ普通の鍵 ID よりちょっと長めに取り出して設定しています。
<code>owner</code> と <code>email</code> はメール送信の時に使われます。</p>

<p>```perl ~/.caffrc</p>

<pre><code># .caffrc -- vim:ft=perl:
# This file is in perl(1) format - see caff(1) for details.

$CONFIG{'owner'} = 'Kazuhiro NISHIYAMA';
$CONFIG{'email'} = 'zn mbf.nifty.com';
#$CONFIG{'reply-to'} = 'foo@bla.org';

# You can get your long keyid from
#   gpg --with-colons --list-key &lt;yourkeyid|name|emailaddress..&gt;
#
# If you have a v4 key, it will simply be the last 16 digits of
# your fingerprint.
#
# Example:
#   $CONFIG{'keyid'} = [ qw{FEDCBA9876543210} ];
#  or, if you have more than one key:
#   $CONFIG{'keyid'} = [ qw{0123456789ABCDEF 89ABCDEF76543210} ];
$CONFIG{'keyid'} = [ qw{262ED8DBB4222F7A} ];

# Select this/these keys to sign with
#$CONFIG{'local-user'} = [ qw{EE739B28C657086C 9B585538ED7E1B73 262ED8DBB4222F7A C9429DABCB28285B} ];

# Additionally encrypt messages for these keyids
#$CONFIG{'also-encrypt-to'} = [ qw{EE739B28C657086C 9B585538ED7E1B73 262ED8DBB4222F7A C9429DABCB28285B} ];

# Mail template to use for the encrypted part
#$CONFIG{'mail-template'} = &lt;&lt; 'EOM';
#Hi,
#
#please find attached the user id{(scalar @uids &gt;= 2 ? 's' : '')}
#{foreach $uid (@uids) {
#    $OUT .= "\t".$uid."\n";
#};}of your key {$key} signed by me.
#
#If you have multiple user ids, I sent the signature for each user id
#separately to that user id's associated email address. You can import
#the signatures by running each through `gpg --import`.
#
#Note that I did not upload your key to any keyservers. If you want this
#new signature to be available to others, please upload it yourself.
#With GnuPG this can be done using
#       gpg --keyserver pool.sks-keyservers.net --send-key {$key}
#
#If you have any questions, don't hesitate to ask.
#
#Regards,
#{$owner}
#EOM
</code></pre>

<p>```</p>

<h3>~/.caff/gnupghome/gpg.conf の設定</h3>

<p>以前参考にした設定のまま</p>

<p><code>text ~/.caff/gnupghome/gpg.conf
keyserver pgp.mit.edu
cert-digest-algo SHA256
personal-digest-preferences SHA256
</code></p>

<p>となっていました。
PDF では SHA512 になっていたので、
SHA256 から SHA512 に変更しました。
今日の caff での署名した時点では SHA256 のままだったので、
次回から変わる予定です。</p>

<p><code>text ~/.caff/gnupghome/gpg.conf
keyserver pgp.mit.edu
cert-digest-algo SHA512
personal-digest-preferences SHA512
</code></p>

<h2>caff -u で署名</h2>

<p>spam よけのためメールアドレスの所は改変した状態のログは以下の通りです。
「本当に署名しますか? (y/N)」のところで身分証明書と一緒に確認した fingerprint と合っているか確認します。</p>

<p>最後にメールを送信して終了です。
相手の鍵で暗号化されたメールが localhost の SMTP サーバー送信されます。</p>

<p>```console</p>

<pre><code>% caff -u B4222F7A D66FD341
[INFO] Importing key 262ED8DBB4222F7A from your normal GnuPGHome.
[INFO] fetching keys, this will take a while...
[INFO] Sign the following keys according to your policy, then exit gpg with 'save' after signing each key
gpg --local-user B4222F7A --homedir=/home/kazu/.caff/gnupghome --secret-keyring /home/kazu/.gnupg/secring.gpg --no-auto-check-trustdb --trust-model=always --edit 25DA5B9699F132DB74BD2270B5A586C7D66FD341 sign
gpg (GnuPG) 1.4.11; Copyright (C) 2010 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.


pub  4096R/D66FD341  作成: 2014-06-22  満了: 無期限       利用法: SC
sub  4096R/5D3BA622  作成: 2014-06-22  満了: 無期限       利用法: E
[ unknown] (1). Takashi Sakamoto &lt;o-takashi sakamocchi.jp&gt;


pub  4096R/D66FD341  作成: 2014-06-22  満了: 無期限       利用法: SC
 主鍵の指紋: 25DA 5B96 99F1 32DB 74BD  2270 B5A5 86C7 D66F D341

     Takashi Sakamoto &lt;o-takashi sakamocchi.jp&gt;

本当にこの鍵にあなたの鍵“Kazuhiro NISHIYAMA &lt;zn mbf.nifty.com&gt;”で署名してよいですか
(B4222F7A)

本当に署名しますか? (y/N) y

次のユーザーの秘密鍵のロックを解除するには
パスフレーズがいります:“Kazuhiro NISHIYAMA &lt;zn mbf.nifty.com&gt;”
4096ビットRSA鍵, ID B4222F7A作成日付は2010-06-27


gpg&gt; save
[INFO] B5A586C7D66FD341 1 Takashi Sakamoto &lt;o-takashi sakamocchi.jp&gt; done.
[INFO] key 25DA5B9699F132DB74BD2270B5A586C7D66FD341 done.
Mail signature for Takashi Sakamoto &lt;o-takashi sakamocchi.jp&gt; to 'o-takashi sakamocchi.jp'? [Y/n]
%
</code></pre>

<p>```</p>

<h2>caff からのメールを受け取った相手のすべきこと</h2>

<p>暗号化されたメールが届くので、
対応する秘密鍵を使って復号してメールを確認します。
さらにその中にある署名を自分の鍵束にインポートしてキーサーバーに送信します。</p>

<p>caff のやり方はここでメールアドレスの到達性もチェックしているようなので、
署名した側はキーサーバーに送信する必要はなさそうです。
むしろそういうことをしないようにするために
<code>~/.caff/gnupghome</code> に独自の鍵束を用意しているように思いました。</p>
]]></content>
  </entry>
  
</feed>
