<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: devise | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/devise/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2014-07-18T22:12:26+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[doorkeeper providerサンプルアプリに対応するOAuthクライアントをdeviseで作成した]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-15-doorkeeper-devise-client.html"/>
    <updated>2014-07-15T18:50:40+09:00</updated>
    <id>http://blog.n-z.jp/blog/doorkeeper-devise-client</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/znz/doorkeeper-provider-app">doorkeeper-provider-app</a>
を使って SSO (Single Sign On) のように使うクライアントアプリを作成しました。
<a href="https://github.com/znz/doorkeeper-devise-client-app">doorkeeper-devise-client-app</a>
で公開しています。</p>

<p>SSO は OAuth 2.0 の本来の使い方ではないので、不便な部分もありますが、
クライアント側の例として参考になると思います。</p>

<!--more-->


<h2>動作確認バージョン</h2>

<ul>
<li>ruby 2.1.2</li>
<li>rails 4.1.4</li>
<li>bootstrap 3.2.0</li>
<li>devise 3.2.4</li>
<li>omniauth 1.2.2</li>
<li>omniauth-oauth2 1.2.0</li>
<li>bootstrap-sass 3.2.0.0</li>
<li>dotenv-rails 0.11.1</li>
</ul>


<h2>簡単な役割解説</h2>

<p>provider は doorkeeper gem を入れている rails アプリ側で認証や認可を受け持ちます。
(OAuth の仕様的には認証と認可が別々のサーバーのこともあります。)</p>

<p>ここでいう OAuth クライアントは devise + omniauth + omniauth-oauth2 を使った rails アプリのことです。
ブラウザーなどのユーザー側にあるクライアントではなく、ユーザーから見れば、これもサーバーです。</p>

<p>詳しいことは OAuth 2.0 の仕様を調べてください。</p>

<h2>大まかな流れ</h2>

<ol>
<li><code>lib/omniauth/strategies/doorkeeper.rb</code> 作成</li>
<li><code>config/initializers/devise.rb</code> で <code>config.omniauth :doorkeeper, ...</code></li>
<li><code>app/controllers/users/omniauth_callbacks_controller.rb</code> 作成
(<code>uid</code> でユーザーを自動作成したり、 <code>access_token</code> (<code>credentials.token</code>) を保存したり)</li>
<li><code>config/routes.rb</code> に設定</li>
<li><code>user</code> に <code>provider</code> を追加</li>
<li><code>app/models/user.rb</code> で <code>devise :omniauthable</code> や <code>uid</code> を使った処理を実装</li>
<li><code>OAuth2::AccessToken</code> を生成</li>
<li>それを使って API アクセス</li>
</ol>


<p><code>access_token</code> を session に保存するかデータベースに保存するかは
アプリケーションのポリシー次第になります。
このアプリでは session に保存しています。</p>

<p>別途 callback uri として <code>http://localhost:3000/users/auth/doorkeeper/callback</code> のような URL を指定して
doorkeeper 側の <code>oauth/applications</code> に登録しておく必要があります。</p>

<h2><code>lib/omniauth/strategies/doorkeeper.rb</code> 作成</h2>

<p>例として
<a href="https://github.com/doorkeeper-gem/doorkeeper-devise-client" title="Dookreeper Devise+Omniauth Client">Dookreeper Devise+Omniauth Client</a>
と比較して <code>info</code> に <code>name</code> を増やしています。</p>

<p>コントローラーを <code>users</code> の下の <code>Users::OmniauthCallbacksController</code> にしたので、
戻り先の <code>authorize_path</code> は <code>'/oauth/authorize'</code> ではなく <code>'/users/oauth/authorize'</code> になっています。</p>

<p>info のハッシュはサーバーから受け取れていて、後の処理でもっと欲しい情報があれば自由に増やせます。</p>

<p>```ruby lib/omniauth/strategies/doorkeeper.rb
module OmniAuth
  module Strategies</p>

<pre><code>class Doorkeeper &lt; OmniAuth::Strategies::OAuth2
  option :name, :doorkeeper

  option :client_options, {
    site: 'http://localhost:4000',
    authorize_path: '/users/oauth/authorize'
  }

  uid do
    raw_info['id']
  end

  info do
    {
      email: raw_info['email'],
      name: raw_info['name'],
    }
  end

  def raw_info
    @raw_info ||= access_token.get('/api/v1/me.json').parsed || {}
  end
end
</code></pre>

<p>  end
end
```</p>

<h2><code>config/initializers/devise.rb</code> で設定</h2>

<p><a href="https://github.com/doorkeeper-gem/doorkeeper-devise-client">サンプルアプリ</a>
では</p>

<p><code>ruby config/initializers/devise.rb
  config.omniauth :doorkeeper,  DOORKEEPER_APP_ID, DOORKEEPER_APP_SECRET, :client_options =&gt;  {:site =&gt; DOORKEEPER_APP_URL}
</code></p>

<p>となっていました。</p>

<p><code>scope</code> も追加すると以下のようになります。
<code>dotenv</code> を使って <code>ENV</code> から取るようにしました。</p>

<p><code>ruby config/initializers/devise.rb
  config.omniauth :doorkeeper, ENV['DOORKEEPER_APP_ID'], ENV['DOORKEEPER_APP_SECRET'], client_options: {site: ENV['DOORKEEPER_APP_URL'] }, scope: 'public write'
</code></p>

<p><code>scope</code> は <code>'public,write'</code> だと <code>The requested scope is invalid, unknown, or malformed.</code> というエラーになってしまったので、
<code>,</code> 区切りではなくスペース区切りにしています。</p>

<h2><code>app/controllers/users/omniauth_callbacks_controller.rb</code> 作成</h2>

<p>callback で認証結果を受け取る部分を作成します。
ここで認証結果を受け取って、ユーザーを必要に応じてひも付けたり、
後で API アクセスに使うアクセストークンを保存したりします。</p>

<p>認証に失敗した時はログイン画面 (あれば) か <code>root_path</code> に戻すようにしています。</p>

<p>```ruby app/controllers/users/omniauth_callbacks_controller.rb
class Users::OmniauthCallbacksController &lt; Devise::OmniauthCallbacksController
  # <a href="https://github.com/plataformatec/devise/issues/2432">https://github.com/plataformatec/devise/issues/2432</a>
  protect_from_forgery except: :doorkeeper
  skip_filter :auto_authenticate_omniauth_user!, only: :doorkeeper</p>

<p>  def doorkeeper</p>

<pre><code># You need to implement the method below in your model (e.g. app/models/user.rb)
oauth_data = request.env['omniauth.auth']
@user = User.find_or_create_for_doorkeeper_oauth(oauth_data)
session[:doorkeeper_token] = oauth_data['credentials']['token']

if @user.persisted?
  sign_in_and_redirect @user, :event =&gt; :authentication #this will throw if @user is not activated
  if is_navigational_format?
    set_flash_message(:notice, :success, kind: ENV['DOORKEEPER_APP_NAME'] || 'Doorkeeper')
    # hide flash message after auto sign in
    #flash.delete(:notice)
  end
else
  session['devise.doorkeeper_data'] = request.env['omniauth.auth']
  if respond_to?(:new_user_registration_url)
    redirect_to new_user_registration_url
  else
    redirect_to root_url
  end
end
</code></pre>

<p>  end</p>

<p>  def after_omniauth_failure_path_for(scope)</p>

<pre><code>if respond_to?(:new_session_path)
  new_session_path(scope)
else
  root_path
end
</code></pre>

<p>  end
end
```</p>

<p>自動ログイン後のメッセージが不要なら <code>set_flash_message</code> の部分を <code>flash.delete(:notice)</code> に置き換えます。
「Doorkeeper でログインしました」だとどのサイトか区別がつかないので、
<code>ENV['DOORKEEPER_APP_NAME']</code> で表示用の名前を設定できるようにしています。</p>

<h2><code>config/routes.rb</code> に設定</h2>

<p><code>config/routes.rb</code> で <code>omniauth_callbacks</code> として独自のものを使うように設定します。</p>

<p>今回は認証必須なので不要ですが、
例として <code>sign_in</code> と <code>sign_out</code> の URL も入れました。
実際に試してみるとすぐに自動ログインで再ログインしてしまいます。</p>

<p><code>sign_out</code> が <code>get</code> か <code>delete</code> か違うことがあるので、
<code>sign_out_via</code> を使ってどちらでも対応できるようにしました。</p>

<p>```ruby config/routes.rb
  devise_for :users, controllers: { omniauth_callbacks: &lsquo;users/omniauth_callbacks&rsquo; }
  devise_scope :user do</p>

<pre><code>get 'sign_in',  to: 'devise/sessions#new',     as: :new_user_session
__send__ Devise.sign_out_via, 'sign_out', to: 'devise/sessions#destroy', as: :destroy_user_session
</code></pre>

<p>  end
```</p>

<h2>timeoutable 設定</h2>

<p>SSO 的に使うのは
OAuth 2.0 の本来の目的ではないので、
ログアウトは難しい問題です。
たとえば
doorkeeper
と連携するアプリが複数あるときにまとめてログアウト出来ないなどの問題があります。</p>

<p>そのため、このアプリでは一定時間で再ログインが必要になるように <code>timeoutable</code> を使って、
こまめに認証し直すようにしてログアウト問題を緩和しています。</p>

<p>その副作用として入力に時間のかかるフォームがあると入力途中でタイムアウトしてしまって
投稿に失敗するなどの問題も起きるので、その点を考慮しておく必要があります。</p>

<p><code>ruby config/initializers/devise.rb
  # Default is 30 minutes.
  config.timeout_in = 1.minutes if Rails.env.development?
  config.expire_auth_token_on_timeout = true
</code></p>

<h2>app/models/user.rb に実装</h2>

<p><code>find_or_create_for_doorkeeper_oauth</code> の実装は <code>concerns</code> に分けてみました。
<code>omniauthable</code> に <code>omniauth_providers</code> も設定して余計な route が生成されないようにしています。
<code>timeoutable</code> も入れています。</p>

<p><code>ruby app/models/user.rb
  devise :omniauthable, omniauth_providers: [:doorkeeper]
  devise :timeoutable
  include DoorkeeperOauthFinder
</code></p>

<p>ログインしたときに <code>name</code> や <code>email</code> が変わっていたら反映するようにしています。</p>

<p><code>id</code> を統一したいのなら、 <code>create</code> のときに <code>id</code> まで指定すると
doorkeeper gem による OAuth provider 側とユーザーの ID を統一できます。</p>

<p>SSO 的に使うのならパスワードは不要なので、
ここではコメントアウトしています。</p>

<p>```ruby app/models/concerns/doorkeeper_oauth_finder.rb
module DoorkeeperOauthFinder
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def find_or_create_for_doorkeeper_oauth(oauth_data)
  uid = oauth_data.uid.to_s
  id = uid.to_i
  user = self.where(provider: oauth_data.provider, uid: uid).first
  if user
    user.name = oauth_data.info.name
    user.email = oauth_data.info.email
    user.save! if user.changed?
  else
    user = self.create!({
      id: id, # use same id
      name: oauth_data.info.name,
      provider: oauth_data.provider,
      uid: uid,
      email: oauth_data.info.email,
      #password: Devise.friendly_token[0,20]
    })
  end
  user
end
</code></pre>

<p>  end
end
```</p>

<p>データベースの migration の方でも削除して unique index の制約なども不要なものは外しておきます。</p>

<p>```ruby db/migrate/*_devise_create_users.rb</p>

<pre><code>  ## Database authenticatable
  t.string :email,              null: false, default: ""
  # t.string :encrypted_password, null: false, default: ""
</code></pre>

<p>```</p>

<p>代わりに <code>provider</code> と <code>uid</code> と <code>name</code> を追加しました。
このアプリは Doorkeeper 専用なので、直接 <code>users</code> に追加していますが、
複数プロバイダに対応するには <code>provider</code> と <code>uid</code> の組を別テーブルにします。</p>

<p>```ruby db/migrate/*_add_omniauth_columns_to_users.rb
class AddOmniauthColumnsToUsers &lt; ActiveRecord::Migration
  def change</p>

<pre><code>add_column :users, :provider, :string
add_column :users, :uid, :string
add_column :users, :name, :string
add_index :users, [:provider, :uid], unique: true
</code></pre>

<p>  end
end
```</p>

<h2><code>OAuth2::AccessToken</code> を生成</h2>

<p><code>OAuth2::Client</code> と保存しておいた <code>access_token</code> を引数にして <code>OAuth2::AccessToken</code> を生成します。
ここでは <code>concerns</code> に分けて必要なコントローラーでだけ <code>include DoorkeeperApiV1</code> するようにしました。
全体で使いたいのなら <code>ApplicationController</code> に <code>include</code> すれば良いと思います。</p>

<p>```ruby app/controllers/concerns/doorkeeper_api_v1.rb
module DoorkeeperApiV1
  private</p>

<p>  def access_token</p>

<pre><code>return @access_token if defined?(@access_token)
config = Devise.omniauth_configs[:doorkeeper]
strategy = config.strategy_class.new(*config.args)
token = session[:doorkeeper_token]
@access_token = OAuth2::AccessToken.new(strategy.client, token)
</code></pre>

<p>  end</p>

<p>  def get_me</p>

<pre><code>access_token.get("/api/v1/me.json").parsed
</code></pre>

<p>  end</p>

<p>  def get_microposts</p>

<pre><code>access_token.get("/api/v1/microposts.json").parsed
</code></pre>

<p>  end</p>

<p>  MICROPOST_CONTENT_MAX_LENGTH = 140</p>

<p>  def post_micropost(micropost)</p>

<pre><code>micropost[:content] = micropost[:content].truncate(MICROPOST_CONTENT_MAX_LENGTH)
access_token.post("/api/v1/microposts", params: { micropost: micropost }).parsed
</code></pre>

<p>  end
end
```</p>

<p>使い方は <code>get_me</code> などを呼び出すだけなので省略します。</p>

<h2>ログインを強制する</h2>

<p>常に Doorkeeper の方でログインさせておきたいアプリの場合は、
User クラスを使っている場合の devise での戻り先の <code>session[:user_return_to]</code> に URL を保存しておいて、
<code>user_omniauth_authorize_path(:doorkeeper)</code> に強制的にリダイレクトしています。
<code>main_app.</code> をつけているのは route で mount している engine の中で問題が起きたことがあったためです。</p>

<p><code>ruby app/controllers/application_controller.rb
  include AuthDoorkeeper
  before_action :auto_authenticate_omniauth_user!
</code></p>

<p>```ruby app/controllers/concerns/auth_doorkeeper.rb
module AuthDoorkeeper
  private</p>

<p>  def auto_authenticate_omniauth_user!</p>

<pre><code>return if current_user
session[:user_return_to] = request.original_url
redirect_to main_app.user_omniauth_authorize_path(:doorkeeper)
</code></pre>

<p>  end
end
```</p>

<h2>テストについて</h2>

<p>API 呼び出しの部分の対処が出来ていなくて、まだテストが通る状態には出来ていません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 4.1 で Doorkeeper を使った OAuth2 Provider のサンプルを実装した]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-11-doorkeeper-provider-example-app.html"/>
    <updated>2014-07-11T23:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/doorkeeper-provider-example-app</id>
    <content type="html"><![CDATA[<p>ソースは github の
<a href="https://github.com/znz/doorkeeper-provider-app" title="znz/doorkeeper-provider-app">znz/doorkeeper-provider-app</a>
で公開しています。</p>

<p>基本的にはソースをみて参考にしてもらうと良いと思いますが、
説明が必要な部分を続きに書いてみました。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>ruby 2.1.2</li>
<li>rails 4.1.4</li>
<li>bootstrap-sass 3.2.0.0</li>
<li>devise 3.2.4</li>
<li>devise-i18n-views 0.2.8</li>
<li>doorkeeper 1.3.1</li>
<li>cancancan 1.8.4</li>
<li>rolify 3.4.0</li>
<li>rspec-rails 3.0.1</li>
</ul>


<h2>試し方</h2>

<p>README に書いたようにローカルで動かすか heroku に deploy して
<a href="https://github.com/doorkeeper-gem/doorkeeper/wiki/Example-Applications" title="Example Applications">Example Applications</a>
にある Client examples の Sinatra and OAuth2 gem の
<a href="https://github.com/doorkeeper-gem/doorkeeper-sinatra-client" title="Doorkeeper Sinatra Client">Doorkeeper Sinatra Client</a>
を使って試しました。</p>

<h2>初期設定</h2>

<p>devise, doorkeeper, cancancan, rolify, rspec の個別の初期設定は普通に <code>rails generate</code> を使いました。</p>

<h2>ユーザー情報追加</h2>

<p>とれる情報を増やすために <code>User</code> に <code>name</code> を追加しました。
<code>devise-i18n-views</code> を使っている関係で view のカスタマイズはしていないので、
<code>rake db:seed</code> で設定したユーザーだけ <code>name</code> が設定されています。</p>

<p>必要に応じて view もカスタマイズしてください。</p>

<p>また <code>devise-i18n</code> の ja.yml を devise.ja.yml として入れています。
これは flash のメッセージやメールのメッセージなど、
<code>app/views</code> 以外の翻訳になるようです。</p>

<p><code>devise-i18n-views</code> は <code>app/views</code> を翻訳可能な view にするプロジェクトです。
なぜ <code>devise</code> とは別プロジェクトでやっているのかはよくわかりません。</p>

<h2><code>I18n.available_locales</code></h2>

<p><code>devise-i18n-views</code> を入れてしまうと <code>I18n.available_locales</code> が増えてしまうので、
困るのなら、カスタマイズ用の view を generate して、必要な言語だけ取り込んで
<code>Gemfile</code> から外してしまうのが良いと思います。</p>

<p>今回はそのまま残して右上の <code>Locale</code> で選択できるようにしています。
選択肢の翻訳は Wikipedia の左や www.debian.org の下などを参考にしたのですが <code>es-AR</code> はわからなかったので、
<code>es</code> と同じになってしまっています。</p>

<h2><code>/oauth/applications</code> のアクセス制限</h2>

<p><code>cancancan</code> と <code>rolify</code> を使って admin role があるユーザーだけに制限しています。
secret も見えてしまうので、 read 権限までしっかり制限する必要があるようです。</p>

<p><code>load_and_authorize_resource</code> でのロードと親クラス (<code>Doorkeeper::ApplicationsController</code>) の中でのロードでモデルの読み込みが二重になってしまうのですが、変更を少なくするためにそこは許容しました。</p>

<h2><code>GET /api/v1/me.json</code></h2>

<p>Doorkeeper gem の Wiki の例にあるようにユーザー情報をとれるようにしています。
制限していないと以下のような情報がとれました。</p>

<p><code>json
{ "id": 1,
  "email": "admin@example.com",
  "created_at": "2014-07-11T06:32:22.077Z",
  "updated_at": "2014-07-11T09:33:42.143Z",
  "name": "admin" }
</code></p>

<p>制限したり関連するモデルの情報を増やしたりするなら
<a href="http://sugamasao.hatenablog.com/entry/20100914/1284415669" title="Rails のモデル関係と to_json(to_xml) - すがブロ">Rails のモデル関係と to_json(to_xml) &ndash; すがブロ</a>
に書いてあるように <code>respond_with</code> に <code>:only</code> をつけたり <code>:include</code> をつけたりすると出来るようです。</p>

<p>入ったり入らなかったりする条件がよくわからなかったのですが、
<code>devise</code> 関連では <code>authentication_token</code> が入っていることがあったので、
User モデルにいろんな情報を入れているなら、
きちんと制限した方が良さそうに思いました。</p>

<h2>microposts</h2>

<p><a href="http://railstutorial.jp/" title="Ruby on Rails チュートリアル：実例を使って Rails を学ぼう">Ruby on Rails チュートリアル：実例を使って Rails を学ぼう</a>
のように <code>Micropost</code> モデルを作成して、 API からも投稿できるようにしました。</p>

<p>投稿は scope で制限していて、デフォルトの <code>public</code> のみでは書き込めずに <code>write</code> も必要にしています。</p>

<p>API としては</p>

<ul>
<li><code>GET /api/v1/microposts</code> で投稿一覧</li>
<li><code>POST /api/v1/microposts</code> で新規投稿</li>
</ul>


<p>を用意しています。</p>

<h3><code>Can't verify CSRF token authenticity</code></h3>

<p>(2014-07-15 追記)</p>

<p>新規投稿の <code>POST</code> は <code>CSRF</code> チェックにひっかかってしまうので、
<code>skip_before_action :verify_authenticity_token</code>
を入れました。</p>

<p>以前から doorkeeper gem を使っているアプリでは
<code>Can't verify CSRF token authenticity</code>
というメッセージが出るだけで投稿自体は出来ていたのですが、
サンプルアプリでは投稿できなかったので、
<code>skip_before_action</code> を入れました。
(Rails 4 なので <code>skip_before_filter</code> ではなく <code>skip_before_action</code>)</p>

<h2>その後の変更点 (2014-07-15 追記)</h2>

<p>その後 <code>kaminari</code> 対応などを入れました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[devise で通常ログイン出来るユーザーが他の複数サービス連携でログインできるようにした]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-08-devise-omniauth.html"/>
    <updated>2014-07-08T08:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/devise-omniauth</id>
    <content type="html"><![CDATA[<p><code>devise</code> でデータベース認証を実装している Rails アプリに Twitter などでもログインできるように
実装を追加してみました。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>ruby 2.1.2</li>
<li>rails 4.1.4</li>
<li>devise 3.2.4</li>
<li>omniauth 1.2.1</li>
<li>omniauth-facebook 1.6.0</li>
<li>omniauth-github 1.1.2</li>
<li>omniauth-google-oauth2 0.2.4</li>
<li>omniauth-twitter 1.0.1</li>
<li>(dotenv 0.11.1) (key と secret の管理)</li>
<li>(font-awesome-sass 4.1.0) (view での <code>icon</code> メソッド)</li>
</ul>


<h2>前提条件</h2>

<ul>
<li>devise で通常の User モデルにメールアドレスとパスワードによる認証は実装されている。</li>
<li>複数サービスとの連携をするために User モデルには連携サービスの情報は直接持たずに UserAuth モデルに分ける。</li>
<li>連携対象サービスは Facebook, GitHub, Google+, Twitter</li>
<li>連携サービスからの追加情報はメールアドレスなども含めて一切とらずに認証だけに利用する。</li>
<li>どの連携サービス (provider) かと識別するための ID だけ保存する。</li>
<li>key や secret は環境変数で渡す。 (今回は dotenv を使ったが、 config/secrets.yml 経由でも良さそう)</li>
<li>今回はテストは未実装 (連携部分のテストの書き方をまだ調べていないため)</li>
<li>今回の実装範囲では I18n は使わずにメッセージは日本語固定</li>
</ul>


<h2>実装</h2>

<p>今回は以下のように実装を追加すると連携サービスでログインできるようになりました。</p>

<h3>Gemfile</h3>

<p>OmniAuth と使用するサービスを追加します。</p>

<p>```ruby Gemfile</p>

<pre><code>gem 'omniauth'
gem 'omniauth-facebook'
gem 'omniauth-github'
gem 'omniauth-google-oauth2'
gem 'omniauth-twitter'
</code></pre>

<p>```</p>

<h3>initializer 追加</h3>

<p>key と secret があれば provider 登録するようにしました。</p>

<p>view で使うために、
登録されている provider の情報の取り方がわからなかったのと
追加で名前や Font Awesome のアイコン名も入れたかったので、
<code>AUTH_PROVIDERS</code> という配列にハッシュを入れるようにしています。</p>

<p>```ruby config/initializers/omniauth.rb</p>

<pre><code>AUTH_PROVIDERS = []

Rails.application.config.middleware.use OmniAuth::Builder do
  key, secret = ENV['FACEBOOK_KEY'], ENV['FACEBOOK_SECRET']
  if key &amp;&amp; secret
    provider :facebook, key, secret
    AUTH_PROVIDERS &lt;&lt; {
      provider: :facebook,
      name: 'Facebook',
    }
  end

  key, secret = ENV['GITHUB_CONSUMER_KEY'], ENV['GITHUB_CONSUMER_SECRET']
  if key &amp;&amp; secret
    provider :github, key, secret
    AUTH_PROVIDERS &lt;&lt; {
      provider: :github,
      name: 'GitHub',
    }
  end

  key, secret = ENV['GOOGLE_CLIENT_ID'], ENV['GOOGLE_CLIENT_SECRET']
  if key &amp;&amp; secret
    provider :google_oauth2, key, secret
    AUTH_PROVIDERS &lt;&lt; {
      provider: :google_oauth2,
      name: 'Google',
      icon: :google
    }
  end

  key, secret = ENV['TWITTER_CONSUMER_KEY'], ENV['TWITTER_CONSUMER_SECRET']
  if key &amp;&amp; secret
    provider :twitter, key, secret
    AUTH_PROVIDERS &lt;&lt; {
      provider: :twitter,
      name: 'Twitter',
    }
  end

  AUTH_PROVIDERS.each do |provider|
    provider[:icon] ||= provider[:provider]
  end
end
</code></pre>

<p>```</p>

<h3>UserAuth モデル作成</h3>

<p><code>rails g model UserAuth user:references uid:string provider:string</code> で作成します。</p>

<p>モデルクラスは生成されたまま使いましたが、
validation を追加した方が良さそうです。</p>

<p>```ruby app/models/user_auth.rb</p>

<pre><code>class UserAuth &lt; ActiveRecord::Base
  belongs_to :user
end
</code></pre>

<p>```</p>

<p>データベースの方は <code>null: false</code> や index を追加しました。</p>

<p>```ruby db/migrate/*_create_user_auths.rb</p>

<pre><code>class CreateUserAuths &lt; ActiveRecord::Migration
  def change
    create_table :user_auths do |t|
      t.references :user, index: true, null: false
      t.string :uid, null: false
      t.string :provider, null: false

      t.timestamps
    end

    add_index :user_auths, [:uid, :provider], unique: true
  end
end
</code></pre>

<p>```</p>

<h3><code>rake db:migrate</code></h3>

<p><code>rake db:migrate</code> で反映しておきます。</p>

<h3>User クラス側</h3>

<p><code>has_many</code> を追加しておきます。</p>

<p>```ruby app/models/user.rb</p>

<pre><code>  has_many :user_auths, dependent: :destroy
</code></pre>

<p>```</p>

<h3>ルーティング追加</h3>

<p>まず、どう使われるのか把握するためにルーティングを追加します。</p>

<p><code>auth_help</code> は後でプライバシーポリシーなどを書いています。</p>

<p>```ruby config/routes.rb</p>

<pre><code>  get '/auth/help' =&gt; 'auth#help', as: :auth_help
  get '/auth/:provider/callback' =&gt; 'auth#create'
  delete '/auth/destroy/:provider' =&gt; 'auth#destroy', as: :destroy_connection
</code></pre>

<p>```</p>

<p>ここには出てきていませんが、
OmniAuth で <code>/auth/:provider</code> がルーティングされるようです。</p>

<h3>AuthController 実装</h3>

<p>参考サイトの実装例を参考にして AuthController を実装しました。</p>

<p>help は静的な情報を表示するだけなので、実装は空です。</p>

<p>```ruby</p>

<pre><code># -*- coding: utf-8 -*-
class AuthController &lt; ApplicationController
  skip_before_filter :authenticate_user!

  def create
    auth = request.env['omniauth.auth']
    uid = auth['uid']
    provider = auth['provider']
    auth = UserAuth.where(uid: uid, provider: provider).first
    if auth
      flash[:notice] = "#{provider}でログインしました。"
      sign_in_and_redirect auth.user, event: :authentication
    else
      authenticate_user!
      UserAuth.create!(uid: uid, provider: provider, user_id: current_user.id)
      redirect_to root_url, notice: "#{provider}と連携しました。"
    end
  end

  def destroy
    provider = params.require(:provider)
    authenticate_user!
    auth = UserAuth.where(provider: provider, user_id: current_user.id).first
    auth.destroy if auth
    redirect_to root_url, notice: "#{provider}と連携解除しました。"
  end

  def help
  end
end
</code></pre>

<p>```</p>

<p>まだ連携を登録していない状態で</p>

<ul>
<li>ログアウト状態</li>
<li>連携サービスで認証・連携許可</li>
<li>戻ってきて通常ログイン</li>
<li><code>auth/failure</code> に飛ばされる</li>
</ul>


<p>ということがおきているのですが、
<code>auth/failure</code>
を実装していないので、デフォルトの 404 エラー画面になってしまいます。</p>

<h3>view helpers 実装</h3>

<p>以前から使っていた <code>link_to_sign_in_or_out</code> の実装も同じファイルに持ってきて、
<code>link_to_provider</code> という汎用的なメソッドを実装しました。
使い方は後述します。</p>

<p><code>AUTH_PROVIDERS</code> のハッシュはここで使っています。</p>

<p>```ruby app/helpers/link_to_auth_helper.rb</p>

<pre><code># -*- coding: utf-8 -*-
module LinkToAuthHelper
  def link_to_sign_in_or_out(html_options={})
    if user_signed_in?
      body = icon(:'sign-out') + t(:"devise.shared.links.sign_out", default: "Sign out")
      html_options = { method: :delete }.merge(html_options)
      link_to body, :destroy_user_session, html_options
    else
      body = icon(:'sign-in') + t(:"devise.shared.links.sign_in", default: "Sign in")
      link_to body, :new_user_session, html_options
    end
  end

  def link_to_provider(provider, html_options={})
    if current_user
      if UserAuth.where(user_id: current_user.id, provider: provider[:provider]).exists?
        html_options = { method: :delete }.merge(html_options)
        link_to icon(provider[:icon])+"#{provider[:name]}との連携を解除", destroy_connection_path(provider: provider[:provider]), html_options
      else
        link_to icon(provider[:icon])+"#{provider[:name]}と連携", "/auth/#{provider[:provider]}", html_options
      end
    else
      link_to icon(provider[:icon])+"#{provider[:name]}でログイン", "/auth/#{provider[:provider]}", html_options
    end
  end
end
</code></pre>

<p>```</p>

<h3>view に追加</h3>

<p>ナビゲーションに以下のように追加しました。
認証連携がないときは従来のログイン・ログアウトだけ表示しています。</p>

<p><code>AUTH_PROVIDERS</code> に登録されているときだけ連携のリンクを表示するようにしています。</p>

<p>```text app/views/layouts/_navigation.html.slim</p>

<pre><code>    li.dropdown
      a.dropdown-toggle data-toggle="dropdown"
        = icon(:user) + 'ログイン管理'
        b.caret
      ul.dropdown-menu
        li= link_to_sign_in_or_out
        - unless AUTH_PROVIDERS.empty?
          li= link_to icon(:info)+"認証連携のヘルプ", auth_help_path
        - AUTH_PROVIDERS.each do |provider|
          li= link_to_provider(provider)
</code></pre>

<p>```</p>

<h3>twitter 連携</h3>

<p>Twitter は複数アカウントを使うことも通常の使用範囲として想定されていて、
アプリ専用のアカウントもとりやすいので、
Twitter 連携から試してみました。</p>

<p><a href="https://apps.twitter.com/">https://apps.twitter.com/</a> から <code>Create New App</code> で作成します。</p>

<ul>
<li>Name: Twitter 全体で一意になるアプリケーションの ID 的にも使われるもの。ツイートの時にツイートしたアプリ名としても埋め込まれるが、今回は認証のみなので、他とぶつからないような名前という以上はこだわらなかった。</li>
<li>Description: 認証のときに出てくる説明。</li>
<li>Website: たとえば <code>http://app.127.0.0.1.xip.io:3000/</code> など</li>
<li>Callback URL: たとえば <code>http://app.127.0.0.1.xip.io:3000/auth/twitter/callback</code> のように <code>/auth/twitter/callback</code> にする。実サイトなら <code>https</code> にすべき。</li>
</ul>


<p>作成後には <code>Allow this application to be used to Sign in with Twitter</code> のチェックを入れておきます。
チェックがないと Twitter 連携でのログインがうまくいかないようです。</p>

<p>アイコンや Organization なども必要に応じて変更します。</p>

<p>API keys タブで key と secret を取得します。</p>

<ul>
<li>API key : 環境変数 <code>TWITTER_CONSUMER_KEY</code> に設定</li>
<li>API secret : 環境変数 <code>TWITTER_CONSUMER_SECRET</code> に設定</li>
</ul>


<p>dotenv を使っているので <code>.env</code> に以下のような感じで設定しました。
ランダムな文字列のように見えます。</p>

<p>```text</p>

<pre><code>TWITTER_CONSUMER_KEY="xxxxXXxxXxXxXXXxXxXXXXxxx"
TWITTER_CONSUMER_SECRET="xxXXxXXxxxxxxXXXXXxXxXXxxXXXxXXxxxxXXxxXxxXXxxXxxx"
</code></pre>

<p>```</p>

<h3>動作確認</h3>

<ul>
<li>通常のログインをした状態で「Twitter と連携」で Twitter の許可画面に飛びます。</li>
<li>許可すると「Twitter 側に許可情報」と「UserAuth に連携情報」が保存されます。</li>
<li>「Twitter との連携を解除」で「UserAuth が削除」されます。</li>
<li>「ログアウト」して「Twitter でログイン」すると「ログイン画面」に戻ります。</li>
<li>ログインすると <code>auth/failure</code> が 404 エラーになります。ここは後で実装する予定です。</li>
<li>再度ログイン後の画面を直接開きます。</li>
<li>再度「Twitter と連携」で「UserAuth に連携情報」が保存されます。「Twitter 側の許可情報」は古いままです。</li>
<li>「ログアウト」して「Twitter でログイン」でログインできます。</li>
<li><a href="https://twitter.com/settings/applications">https://twitter.com/settings/applications</a> で許可を取り消します。</li>
<li>「ログアウト」して「Twitter でログイン」で Twitter の許可画面に飛びます。</li>
<li>許可すると「Twitter 側に許可情報」が保存されて、「UserAuth」は残っているので、そのままログインできます。</li>
</ul>


<h3>GitHub 連携</h3>

<p>GitHub 連携は作成後にすぐに使えるので、アプリケーション作成に使っても良いアカウントがあれば一番簡単です。</p>

<p><a href="https://github.com/settings/applications">https://github.com/settings/applications</a> から <code>Register new application</code> で作成します。</p>

<ul>
<li>Application name: 適切な名前を設定</li>
<li>Homepage URL: たとえば <code>http://app.127.0.0.1.xip.io:3000/</code> など</li>
<li>Application description: ユーザーが許可するときにわかりやすい説明</li>
<li>Authorization callback URL: たとえば <code>http://app.127.0.0.1.xip.io:3000/auth/github/callback</code> のように <code>/auth/github/callback</code> にする。実サイトなら <code>https</code> にすべき。</li>
</ul>


<p>右上に見えている Client ID と Client Secret を使います。</p>

<ul>
<li>Client ID : 環境変数 <code>GITHUB_CONSUMER_KEY</code> に設定</li>
<li>Client Secret : 環境変数 <code>GITHUB_CONSUMER_SECRET</code> に設定</li>
</ul>


<p>dotenv を使っているので <code>.env</code> に以下のような感じで設定しました。
十六進数の数字のように見えます。</p>

<p>```text</p>

<pre><code>GITHUB_CONSUMER_KEY="xxxxxxxxxxxxxxxxxxxx"
GITHUB_CONSUMER_SECRET="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
</code></pre>

<p>```</p>

<h2>Facebook 連携</h2>

<p><a href="https://developers.facebook.com/">https://developers.facebook.com/</a> から上の <code>Apps</code> の中にある <code>Craete a New App</code> で作成します。
最初は作成前に開発者関連の規約などに同意する必要があるようです。</p>

<ul>
<li>Display Name: 適切な名前を設定します。</li>
<li>Namespace: optional なので空欄のままで良いようです。</li>
<li>カテゴリ: 適当に選択します。</li>
</ul>


<p>セキュリティチェックがあるので、入力すると作成できます。</p>

<p>右上に見えている App ID と App Secret (Show を押すとパスワード認証の後に内容表示) を使います。</p>

<ul>
<li>App ID : 環境変数 <code>FACEBOOK_KEY</code> に設定</li>
<li>App Secret : 環境変数 <code>FACEBOOK_SECRET</code> に設定</li>
</ul>


<p>dotenv を使っているので <code>.env</code> に以下のような感じで設定しました。
十進数と十六進数の数字のように見えます。</p>

<p>```text</p>

<pre><code>FACEBOOK_KEY="xxxxxxxxxxxxxxx"
FACEBOOK_SECRET="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
</code></pre>

<p>```</p>

<p><code>Settings</code> の <code>Add Platform</code> で <code>Website</code> を選んで追加します。</p>

<ul>
<li>Site URL: たとえば <code>http://app.127.0.0.1.xip.io:3000/</code> など</li>
<li>Mobile Site URL: 空欄のまま</li>
</ul>


<p>callback URL は設定が不要だったので、
Site URL の下ならどこでも良さそうです。</p>

<h3><code>google_oauth2</code> 連携</h3>

<p><a href="https://github.com/zquestz/omniauth-google-oauth2">https://github.com/zquestz/omniauth-google-oauth2</a> に書いてあるように
<a href="https://code.google.com/apis/console/">https://code.google.com/apis/console/</a> を開きます。</p>

<p>飛ばされる先で <code>API &amp; AUTH</code> の中の <code>Credentials</code> で <code>Create new Client ID</code> で作成します。</p>

<ul>
<li>Application type : Web application</li>
<li>Authorized JavaScript origins : たとえば <code>http://app.127.0.0.1.xip.io:3000</code> など</li>
<li>Authorized redirect URI : たとえば <code>http://app.127.0.0.1.xip.io:3000/auth/google_oauth2/callback</code> のように <code>/auth/google_oauth2/callback</code> にする。実サイトなら <code>https</code> にすべき。</li>
</ul>


<p>右に見えている Client ID と Client secret を使います。</p>

<ul>
<li>Client ID : 環境変数 <code>GOOGLE_CLIENT_ID</code> に設定</li>
<li>Client secret : 環境変数 <code>GOOGLE_CLIENT_SECRET</code> に設定</li>
</ul>


<p>dotenv を使っているので <code>.env</code> に以下のような感じで設定しました。
ドメインっぽい文字列とランダムな文字列のように見えます。</p>

<p>```text</p>

<pre><code>GOOGLE_CLIENT_ID="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com"
GOOGLE_CLIENT_SECRET="XXxxxXxXxxxXXxXXxXxXXxxX"
</code></pre>

<p>```</p>

<p>さらに <code>Consent screen</code> での設定が必要です。
しかも全アプリ共通のようなので、名前を分けたい場合はグーグルアカウントごと違うものにしないといけないように見えました。</p>

<ul>
<li>Email address : グーグルアカウントのアドレス選択</li>
<li>Product name : 適切な名前を設定</li>
<li>Homepage URL 以下 : 必要に応じて設定</li>
</ul>


<p>さらにエラーメッセージ (<code>"Access Not Configured. Please use Google Developers Console to activate the API for your project."</code>) で検索してわかったのですが、
<a href="http://qiita.com/aikyo02/items/459d03af304e1188f110" title="Google OAuth 2.0 loginが2014年9月に使えなくなる(Googleアカウントからのユーザ登録機能がある場合は注意)">Google OAuth 2.0 loginが2014年9月に使えなくなる(Googleアカウントからのユーザ登録機能がある場合は注意)</a>
に書いてあるように、
APIs で <code>Google+ API</code> も有効にする必要がありました。</p>

<h2>参考サイト</h2>

<ul>
<li><a href="http://xoyip.hatenablog.com/entry/2013/12/20/212109" title="Railsでログインとは別に複数のサービスとの連携を行う方法 - PILOG">Railsでログインとは別に複数のサービスとの連携を行う方法 &ndash; PILOG</a>
と<a href="https://github.com/xoyip/multi-oauth">その実装</a>は非常に参考になりました。</li>
<li><a href="http://qiita.com/aikyo02/items/459d03af304e1188f110" title="Google OAuth 2.0 loginが2014年9月に使えなくなる(Googleアカウントからのユーザ登録機能がある場合は注意)">Google OAuth 2.0 loginが2014年9月に使えなくなる(Googleアカウントからのユーザ登録機能がある場合は注意)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[doorkeeper gem の API のクライアント]]></title>
    <link href="http://blog.n-z.jp/blog/2013-10-08-doorkeeper-api-client.html"/>
    <updated>2013-10-08T21:06:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/doorkeeper-api-client</id>
    <content type="html"><![CDATA[<p><a href="http://rubygems.org/gems/doorkeeper">doorkeeper gem</a>
で API を作る方は
<a href="https://github.com/applicake/doorkeeper-provider-app">doorkeeper-provider-app</a>
というサンプルの
<code>app/controllers/api/</code>
以下などをみればすぐにわかったのですが、
API を呼び出す方は
<a href="https://github.com/applicake/doorkeeper/wiki/Create-a-OmniAuth-strategy-for-your-provider">OmniAuth の中でユーザーの情報を取り出す</a>
だけならすぐに出来たのですが、
コントローラーの中など呼び出す方法は
<a href="https://github.com/applicake/doorkeeper-devise-client">doorkeeper-devise-client</a>
を見てもよくわからなかったので、まとめてみました。</p>

<!--more-->


<h2>動作確認バージョン</h2>

<ul>
<li>provider 側

<ul>
<li>rails 3.2.14</li>
<li>doorkeeper 0.7.3</li>
</ul>
</li>
<li>client 側

<ul>
<li>rails 4.0.0</li>
<li>devise 3.1.1</li>
<li>omniauth 1.1.4</li>
<li>omniauth-oauth2 1.1.1</li>
<li>oauth2 0.8.1</li>
</ul>
</li>
</ul>


<h2>準備</h2>

<p>まず
<a href="https://github.com/applicake/doorkeeper/wiki/Create-a-OmniAuth-strategy-for-your-provider">Create a OmniAuth strategy for your provider</a>
を参考にして、
OmniAuth の中で
<code>access_token.get('/api/v1/me.json').parsed</code>
は出来るところまでは準備しておきます。</p>

<p>目的としては、
この
<code>access_token</code>
が認証より後で呼ばれる他のコントローラーの中で取得できれば良いということになります。</p>

<p>余談ですが、
doorkeeper の wiki は
<a href="https://github.com/applicake/doorkeeper/wiki/Supported-Ruby-&amp;-Rails-versions">Supported Ruby &amp; Rails versions</a>
のように情報が古いまま放置されているページもあるようなので、
<a href="https://github.com/applicake/doorkeeper">README</a>
などのソースコード側のドキュメントも参照した方が良さそうです。</p>

<h2>必要なもの</h2>

<p><code>access_token</code>
は
<code>OAuth2::AccessToken</code>
クラスのオブジェクトです。</p>

<p>生成するには</p>

<ul>
<li><code>OAuth2::Client</code> のオブジェクト</li>
<li>認証で取得した <code>token</code></li>
</ul>


<p>が必要になります。</p>

<p><code>OAuth2::Client</code>
の生成には</p>

<ul>
<li><code>client_id</code></li>
<li><code>client_secret</code></li>
<li>URL</li>
</ul>


<p>が必要になります。</p>

<h2>token の保存</h2>

<p>まず
<code>OAuth2</code>
の認証で取得した
<code>token</code>
を保存しておく必要があります。</p>

<p><code>Users::OmniauthCallbacksController#doorkeeper</code>
で
<code>session[:doorkeeper_token] = request.env["omniauth.auth"]["credentials"]["token"]</code>
のようにしてセッションなどの後で使える場所に保存しておきます。</p>

<p>後で調べてわかったのですが、
<a href="https://github.com/applicake/doorkeeper-devise-client/blob/master/app/controllers/users/omniauth_callbacks_controller.rb">doorkeeper-devise-client の Users::OmniauthCallbacksController</a>
では
<code>request.env["omniauth.auth"].credentials.token</code>
を
<code>user.doorkeeper_access_token</code>
でデータベースに保存していました。</p>

<h2>OAuth2::Client の作成</h2>

<p><a href="https://github.com/applicake/doorkeeper-devise-client/blob/master/app/controllers/application_controller.rb">doorkeeper-devise-client の ApplicationController</a>
では必要な情報は定数経由で受け取るようになっていました。</p>

<p>今回は
<code>devise</code>
と
<code>omniauth-oauth2</code>
を使っているので、
その情報を使って生成するようにしました。
要点だけまとめると以下のコードになります。</p>

<p>```ruby</p>

<pre><code>config = Devise.omniauth_configs[:doorkeeper]
strategy = config.strategy_class.new(*config.args)
client = strategy.client
</code></pre>

<p>```</p>

<h2>OAuth2::AccessToken の生成</h2>

<p>ここまで準備ができれば後は
<code>OAuth2::AccessToken.new</code>
するだけです。</p>

<p>まとめると以下のコードになります。</p>

<p>```ruby
  def access_token</p>

<pre><code>return @access_token if defined?(@access_token)
config = Devise.omniauth_configs[:doorkeeper]
strategy = config.strategy_class.new(*config.args)
token = session[:doorkeeper_token]
@access_token = OAuth2::AccessToken.new(strategy.client, token)
</code></pre>

<p>  end
```</p>

<h2>API 呼び出し</h2>

<p><code>access_token</code>
が出来たら後は呼び出しに使うだけです。</p>

<p>単純な情報取得は
<code>get</code>
して
JSON
なら
<code>parsed</code>
を呼び出すだけです。</p>

<p><code>ruby
  access_token.get("/api/v1/me.json").parsed
  access_token.get("/api/v1/posts.json").parsed
</code></p>

<p>今回は連携して書き込みたいというのが目的だったため、
<code>post</code>
も使いました。</p>

<p>モデルの例としては
<code>rails g scaffold post title body:text</code>
で API の提供側では以下の実装とします。</p>

<p>```ruby app/controllers/api/v1/posts_controller.rb
module Api::V1
  class PostsController &lt; ApiController</p>

<pre><code>doorkeeper_for :index
doorkeeper_for :create
respond_to     :json

def index
  respond_with Post.all
end

def create
  post = Post.new(params[:post])
  post.user = current_resource_owner
  post.save!
  respond_with post
end
</code></pre>

<p>```</p>

<p>呼び出し側は以下のようになります。</p>

<p><code>ruby
access_token.post("/api/v1/posts", params: { post: { title: title, body: body } })
</code></p>

<p><code>params</code>
による指定は
<a href="https://github.com/intridea/oauth2/blob/master/lib/oauth2/access_token.rb">OAuth2::AccessToken</a>
のソースをみて推測しました。</p>

<h2>scope 付き API 提供</h2>

<p>書き込みも許可すると
<code>scope</code>
を分けたくなります。</p>

<p>doorkeeper 側では
<a href="https://github.com/applicake/doorkeeper/wiki/Using-Scopes">Using Scopes</a>
を参考にして</p>

<ul>
<li>initializers に scopes 追加</li>
<li>翻訳追加</li>
<li>API に scopes 追加</li>
</ul>


<p>をしておきます。</p>

<p><code>ruby config/initializers/doorkeeper.rb
  default_scopes  :public
  optional_scopes :admin, :write
</code></p>

<p>2013-12-20 追記:
doorkeeper gem を 0.7.3 から 0.7.4 に上げたところ、
シンボルだとうまく動かなくなってしまったので、
文字列に変更しました。</p>

<p>(doorkeeer gem 0.7.3 以前)
```ruby app/controllers/api/v1/posts_controller.rb</p>

<pre><code>doorkeeper_for :index,  :show,   scopes: [:public]
doorkeeper_for :create, :update, scopes: [:admin, :write]
</code></pre>

<p>```</p>

<p>(doorkeeer gem 0.7.4 以降)
```ruby app/controllers/api/v1/posts_controller.rb</p>

<pre><code>doorkeeper_for :index,  :show,   scopes: %w"public"
doorkeeper_for :create, :update, scopes: %w"admin write"
</code></pre>

<p>```</p>

<p>参考のため、この API の rspec も載せておきます。
複数の <code>scopes</code> を設定する時に <code>,</code> 区切りだとうまくいかないところがあったので、
スペース区切りにしています。</p>

<p>```ruby spec/controllers/api/v1/posts_controller_spec.rb
require &lsquo;spec_helper&rsquo;</p>

<p>describe Api::V1::PostsController do
  describe &ldquo;GET &lsquo;index&rsquo;&rdquo; do</p>

<pre><code>let!(:application) { Doorkeeper::Application.create!(name: "MyApp", redirect_uri: "http://app.com") }
let!(:user) { FactoryGirl.create(:normal_user) }
let!(:token) { Doorkeeper::AccessToken.create! application_id: application.id, resource_owner_id: user.id, scopes: "public" }
subject { response }

context "valid token" do
  before do
    get 'index', format: :json, access_token: token.token
  end
  it { should be_success }
  its(:status) { should eq(200) }
  its(:body) { should == Post.all.to_a.to_json }
end

context "invalid token" do
  before do
    get 'index', format: :json, access_token: token.token.succ
  end
  it { should_not be_success }
  its(:status) { should eq(401) }
end
</code></pre>

<p>  end</p>

<p>  describe &ldquo;GET &lsquo;index&rsquo; without scopes&rdquo; do</p>

<pre><code>let!(:application) { Doorkeeper::Application.create!(name: "MyApp", redirect_uri: "http://app.com") }
let!(:user) { FactoryGirl.create(:normal_user) }
let!(:token) { Doorkeeper::AccessToken.create! application_id: application.id, resource_owner_id: user.id, scopes: "write" }
subject { response }

context "valid token" do
  before do
    get 'index', format: :json, access_token: token.token
  end
  it { should_not be_success }
  its(:status) { should eq(401) }
  its(:body) { should == " " }
end
</code></pre>

<p>  end</p>

<p>  describe &ldquo;POST &lsquo;create&rsquo;&rdquo; do</p>

<pre><code>let!(:application) { Doorkeeper::Application.create!(name: "MyApp", redirect_uri: "http://app.com") }
let!(:user) { FactoryGirl.create(:normal_user) }
let!(:token) { Doorkeeper::AccessToken.create! application_id: application.id, resource_owner_id: user.id, scopes: "public write" }
subject { response }

context "valid token" do
  before do
    post 'create', format: :json, access_token: token.token, post: { title: "title", body: "some content" }
  end
  it { should be_success }
  its(:status) { should eq(201) } # 201 Created
  its(:body) { should == Post.last.to_json }
end

context "invalid token" do
  before do
    post 'create', format: :json, access_token: token.token.succ
  end
  it { should_not be_success }
  its(:status) { should eq(401) }
end
</code></pre>

<p>  end
end
```</p>

<h2>scope 付き呼び出し</h2>

<p><code>devise</code>
の設定で
<code>omniauth</code>
の設定に
<code>scope</code>
を追加するだけです。</p>

<p><code>ruby config/initializers/devise.rb
  config.omniauth :doorkeeper, ENV['DOORKEEPER_APP_ID'], ENV['DOORKEEPER_APP_SECRET'], { scope: 'public write' }
</code></p>

<p>rspec のところでもちょっと書きましたが、
区切りが <code>,</code> だとうまくいかないことがあったので、
スペース区切りにしています。</p>

<p>原因は
<a href="https://github.com/applicake/doorkeeper/blob/master/lib/doorkeeper/oauth/scopes.rb">lib/doorkeeper/oauth/scopes.rb</a>
で
<code>string.split</code>
のように無引数の
<code>String#split</code>
を使っているからではないかと推測していますが、確認はしていません。</p>

<h2>まとめ</h2>

<p><code>client_id</code> と <code>client_secret</code> と provider の URL はあらかじめ用意しておいて、
client 側の rails アプリに設定しておきます。</p>

<p><code>token</code>
は OAuth2 で取得したものを
<code>session</code>
やデータベースなどに保存しておいて使います。</p>

<p>必要なら
<code>scopes</code>
も設定できます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[devise 3.0.3 と devise 3.1.0 で自動生成されるファイルの違い]]></title>
    <link href="http://blog.n-z.jp/blog/2013-09-18-devise30-devise31.html"/>
    <updated>2013-09-18T15:09:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/devise30-devise31</id>
    <content type="html"><![CDATA[<p><a href="https://gist.github.com/znz/6603471">devise 3.0.3 と devise 3.1.0 で自動生成されるファイルの差分</a>
をとって、バージョンアップした時に対応が必要な場所を調べました。</p>

<!--more-->


<h2>対応が必要な場所</h2>

<p>最初に結論をまとめておきます。</p>

<ul>
<li><code>config/initializers/devise.rb</code> に <code>config.secret_key</code> を追加。

<ul>
<li>これは <code>rails</code> コマンドを実行しようとした時などにエラーとどういう内容を追加すれば良いのかが出るのですぐに気付きます。</li>
</ul>
</li>
<li><code>rails generate devise:views</code> をしていたのなら

<ul>
<li><code>app/views/devise/mailer</code> の <code>token</code> 周り</li>
<li><code>app/views/devise/shared/_links.erb</code> の <code>devise_mapping.recoverable?</code> の行
の修正が必要です。</li>
</ul>
</li>
<li><code>app/models/user.rb</code> の <code>:token_authenticatable</code> の削除の検討

<ul>
<li>削除しなくても動いているので、すぐに削除する必要はなさそうですが、
<code>rails generate devise User</code> で生成される例からなくなっているので
削除を検討した方が良さそうです。</li>
</ul>
</li>
<li>データベースのテーブルの変更に追従するなら
<code>migration</code> を作って対応すれば良さそうです。</li>
</ul>


<h2>対象バージョン</h2>

<p>rails 3.2.14 との組み合わせで devise 3.0.3 と devise 3.1.0 で比較しました。
細かいバージョンは
<a href="https://gist.github.com/znz/6603471#file-bundle-list-in-devise30-txt">devise 3.0.3 の時の bundle list</a>
と
<a href="https://gist.github.com/znz/6603471#file-bundle-list-in-devise31-txt">devise 3.1.0 の時の bundle list</a>
を参照してください。</p>

<h2><code>rails generate devise:install</code> の差分</h2>

<p><code>rails generate devise:install</code> の差分のうち、
<a href="https://gist.github.com/znz/6603471#file-initializer-diff">config/initializers/devise.rb の差分</a>
は <code>"</code> から <code>'</code> への変更などもあって本質的ではない部分も多かったので、
<a href="https://gist.github.com/znz/6603471#file-initializer-tr-diff">tr で処理した差分</a>
を作ってみたところ、本質的には
<code>config.secret_key =</code>
の行の追加だけでした。</p>

<p><a href="https://gist.github.com/znz/6603471#file-locale-diff">config/locales/devise.en.yml の差分</a>
もあるので、
<code>locales</code>
のファイルも更新しておくと良さそうです。</p>

<h2><code>rails generate devise User</code> の差分</h2>

<p><code>rails generate devise User</code> の差分として、
<a href="https://gist.github.com/znz/6603471#file-devise_create_users-diff">migration の差分</a>
は
<code>sign_in_count</code> と <code>failed_attempts</code> への <code>NOT NULL</code> 制約の追加と
Token authenticatable 用の <code>authentication_token</code> の削除なので、
対応する変更をする <code>migration</code> を作って対応するか、
気にせず古いまま使えば良さそうです。</p>

<p><code>app/models/user.rb</code> からもコメントの中のモジュール例にあった
<code>token_authenticatable</code> が削除されています。</p>

<p><code>config/routes.rb</code> に追加される <code>devise_for :users</code> は同じでした。</p>

<h2><code>rails generate devise:views</code> の差分</h2>

<p><a href="https://gist.github.com/znz/6603471#file-views-diff">app/views の差分</a>
は
<code>@resource.なんとか_token</code>
だったものが
<code>@token</code>
に変わっているのと、
<code>app/views/devise/shared/_links.erb</code>
の
<code>if devise_mapping.recoverable? &amp;&amp; controller_name != 'passwords'</code>
が
<code>if devise_mapping.recoverable? &amp;&amp; controller_name != 'passwords' &amp;&amp; controller_name != 'registrations'</code>
に変わっているのが
主な変更でした。</p>
]]></content>
  </entry>
  
</feed>
