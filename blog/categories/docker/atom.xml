<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2014-04-13T00:46:05+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[第3回 コンテナ型仮想化の情報交換会＠大阪 (コンテナ型VMや関連するカーネル等の技術が話題の勉強会)に参加した]]></title>
    <link href="http://blog.n-z.jp/blog/2014-04-12-lxcjp.html"/>
    <updated>2014-04-12T22:23:56+09:00</updated>
    <id>http://blog.n-z.jp/blog/lxcjp</id>
    <content type="html"><![CDATA[<p><a href="http://atnd.org/events/46446">第3回 コンテナ型仮想化の情報交換会＠大阪 (コンテナ型VMや関連するカーネル等の技術が話題の勉強会)</a>
に参加してきました。</p>

<!--more-->


<h2>全体の感想</h2>

<p>全体的には LXC や Docker に限らず、
Hyper-V 上での FreeBSD jail の話や Vagrant や CircleCI (LXC を使っている) などの話もあって、面白かったです。</p>

<h2>会場</h2>

<p>ちょっと早めに出発して、梅田から難波橋を通って堺筋を通って会場まで歩いていきました。
場所もわかりやすくて交差点の名前と目的地のビルの名前をちゃんとチェックしていれば迷わずにたどり着けました。</p>

<p>会場無線 LAN があったのですが、
最初に接続した MacBook Air は問題なく繋がっていたのですが、
後から追加でつなごうとした iPod touch は無線 LAN 自体は繋がっているのに APIPA の IP アドレスになっていて、
DHCP の割り当て IP アドレスが足りなかったのではないかと思いました。</p>

<h2>LXC</h2>

<p>いろいろと知らないことも多くて勉強になったのですが、特に <code>veth</code> と <code>macvlan</code> の違いがよくわかっていなかったので、
<code>veth</code> は作成しただけだと通信に使えなくてペアの片方をネットワークネームスペースに入れないと使えないというコンテナ用の機能で、
<code>macvlan</code> は物理 NIC に別 MAC アドレスを付けて使うもの、
というのがわかって良かったです。</p>

<p>LXC という言葉がさすものが「カーネルのコンテナ機能」のときと「<code>lxc-start</code> などの LXC のユーザーランド」のことがある、というのは気をつける必要があると思いました。
たとえば Docker 0.9 で LXC への依存がなくなったというのは <code>lxc-start</code> などを使わなくなって、システムコールを <code>libcontainer</code> という別ライブラリで直接呼んでカーネルのコンテナ機能を使うようになったなど。</p>

<h2>FreeBSD jail</h2>

<p>jail については存在は知っていたのですが、使ったことはなかったので、そういうものなのかと思ってみていました。</p>

<h2>VagrantユーザのためのDocker入門</h2>

<p>途中の質問にあった container と image の違いで
<a href="http://docs.docker.io/en/latest/terms/image/">http://docs.docker.io/en/latest/terms/image/</a>
に書いてある
<code>In Docker terminology, a read-only Layer is called an image. An image never changes.</code>
が根拠だと思うのですが、
イメージはコンテナに名前をつけてリードオンリーにしたもの、という説明で
今まで曖昧にしていた違いがちゃんとわかったように思いました。</p>

<p>このブログの Docker 関連記事の中で一番人気の
<a href="http://blog.n-z.jp/blog/2013-12-24-docker-rm.html">Dockerで不要になったコンテナやイメージを削除する</a>
で割とコンテナとイメージを曖昧な感じで書いているのは、はっきりとは区別できていなかったからでした。</p>

<p>Vagrant との使い分けも実際に両方使っている人の話だったので、非常に参考になりました。
基本的には Vagrant も Docker も開発環境として使うという話でした。</p>

<h2>Docker運用の観点からみたLXC</h2>

<p>いろいろな話がありました。
基本的には production 環境として使う話でした。</p>

<h2>Docker の layer 数制限の話</h2>

<p>休憩時間に話をしていたのですが layer の制限が 42 から 127 に増えたのは
<a href="https://github.com/dotcloud/docker/pull/2897">Increase max image depth to 127</a>
からで、
理由は aufs の方で <code>CONFIG_AUFS_BRANCH_MAX_127</code> という設定を <code>y</code> にすると
制限が 127 になるから、ということのようでした。</p>

<p>懇親会の時にも話が出たのですが、
<code>RUN</code> ごとにキャッシュがきくので、
基本的には <code>Dockerfile</code> の変更を試している間は <code>RUN</code> ごとに細かくコマンドを並べて試行錯誤して、
出来上がったら <code>&amp;&amp;</code> でつなげて一行の <code>RUN</code> にまとめるのが良さそう、
という話でした。</p>

<p>関連する話としては aufs の layer が重なっているのを git で merge するときのようにまとめたい、
という意見に対して、
<code>Dockerfile</code> をマスター (主) として扱って、
イメージは捨てていつでも作り直せるもの (従) として扱う方が良い、
だから、無理に aufs の差分イメージの中を直接いじってマージしようとせずに
<code>Dockerfile</code> から再生成した方が良い、
という話がありました。</p>

<h2>CircleCI, Cucumber-Chef</h2>

<p><code>CircleCI</code> と <code>ngrok</code> を組み合わせて、
rebuild.fm で話があったブランチごとよりもさらに富豪的に、
コミットごとに時間制限付きのサーバーを動かす話などがありました。</p>

<p><code>CircleCI</code> の1時間という時間制限 (SSH で入れるようにして動かすと30分) と
ローカルサーバーを外に公開できる <code>ngrok</code> というものを組み合わせて
コミットごとに一定時間サーバーを動かしているという話でした。</p>

<h2>終わり</h2>

<p>他の発表の時間に余裕を持たせていて、パネルディスカッションはありませんでした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[boot2dockerでdockerを試す]]></title>
    <link href="http://blog.n-z.jp/blog/2014-02-23-boot2docker.html"/>
    <updated>2014-02-23T00:47:22+09:00</updated>
    <id>http://blog.n-z.jp/blog/boot2docker</id>
    <content type="html"><![CDATA[<p>boot2docker で最新の docker を試してみました。
他ではあまり書いていないアンインストール方法も書いているので、
不要になった時や何か変になった時の削除方法も参考になると思います。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Mac OS X 10.9.1 で試しましたが Linux でも同様に動くはずです</li>
<li>VirtualBox 4.3.6</li>
<li>boot2docker 0.6.0</li>
<li>docker 0.8.1</li>
</ul>


<h2>VirtualBox</h2>

<p>あらかじめ VirtualBox をインストールしておきます。</p>

<h2>boot2docker</h2>

<p><a href="http://docs.docker.io/en/latest/installation/mac/">http://docs.docker.io/en/latest/installation/mac/</a> の手順に従って
<code>boot2docker</code> を入れてみます。</p>

<h3>インストール</h3>

<p>適当なディレクトリに <code>boot2docker</code> をダウンロードして実行可能にします。</p>

<p><code>
 mkdir -p ~/boot2docker
 cd ~/boot2docker
 curl https://raw.github.com/boot2docker/boot2docker/master/boot2docker &gt; boot2docker
 chmod +x boot2docker
</code></p>

<p>この段階でのアンインストールは <code>boot2docker</code> を削除するだけです。</p>

<h3>VM イメージの作成</h3>

<p>初回は <code>./boot2docker init</code> を実行して iso のダウンロードと VM の作成をします。</p>

<p>```
% ./boot2docker init
[2014-02-22 23:43:36] Creating VM boot2docker-vm
Virtual machine &lsquo;boot2docker-vm&rsquo; is created and registered.
UUID: 61e0ec36-fc80-4b70-ac11-899f6526a57e
Settings file: &lsquo;/Users/kazu/VirtualBox VMs/boot2docker-vm/boot2docker-vm.vbox&rsquo;
[2014-02-22 23:43:36] Setting VM settings
[2014-02-22 23:43:36] Setting VM networking
[2014-02-22 23:43:36] boot2docker.iso not found.
[2014-02-22 23:43:38] Latest version is v0.6.0, downloading&hellip;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>

<pre><code>                             Dload  Upload   Total   Spent    Left  Speed
</code></pre>

<p>100   346  100   346    0     0    319      0  0:00:01  0:00:01 &mdash;:&mdash;:&mdash;   319
100 24.0M  100 24.0M    0     0   295k      0  0:01:23  0:01:23 &mdash;:&mdash;:&mdash;  498k
[2014-02-22 23:45:02] Done
[2014-02-22 23:45:02] Setting VM disks
[2014-02-22 23:45:02] Creating 40000 Meg hard drive&hellip;
Converting from raw image file=&ldquo;stdin&rdquo; to file=&ldquo;/Users/kazu/.boot2docker/boot2docker-vm.vmdk&rdquo;&hellip;
Creating dynamic image with size 41943040000 bytes (40000MB)&hellip;
[2014-02-22 23:45:02] Done.
[2014-02-22 23:45:02] You can now type boot2docker up and wait for the VM to start.
```</p>

<p>この段階のやり直しは VM が起動していれば <code>./boot2docker stop</code> で止めて、
<code>./boot2docker delete</code> で VM を削除するだけではダメで、
<code>~/.boot2docker</code> も削除する必要があります。</p>

<p>パスは <code>boot2docker</code> の中の <code>BOOT2DOCKER_CFG_DIR</code> に書かれていて、
以下の設定は <code>$HOME/.boot2docker/profile</code> で設定変更できます。</p>

<ul>
<li><code>VM_NAME</code> : VirtualBox での VM の名前 (デフォルト: <code>boot2docker-vm</code>)</li>
<li><code>DOCKER_PORT</code> : ホスト側で docker 用に使うポート (デフォルト: <code>4243</code>)</li>
<li><code>SSH_HOST_PORT</code> : ホスト側で ssh サーバー用に使うポート (デフォルト: <code>2022</code>)</li>
<li><code>VM_DISK</code> : vmdk ファイルのパス (デフォルト: <code>${BOOT2DOCKER_CFG_DIR}/${VM_NAME}.vmdk</code>)</li>
<li><code>VM_DISK_SIZE</code> : vmdk の容量 (デフォルト: <code>40000</code> メガバイト)</li>
<li><code>VM_MEM</code> : メモリ (デフォルト: <code>1024</code>)</li>
<li><code>BOOT2DOCKER_ISO</code> : ISO ファイルのパス (デフォルト: <code>${BOOT2DOCKER_CFG_DIR}/boot2docker.iso</code>)</li>
</ul>


<p>VM を作り直すだけなら <code>./boot2docker delete</code> して <code>./boot2docker init</code> すれば
ISO はダウンロードし直さずに VM だけ作り直せます。</p>

<p>間違えて先に <code>~/.boot2docker</code> を削除してしまうと VirtualBox の状態が不整合になるので、
VirtualBox の GUI の方の仮想メディアマネージャーで存在しなくっているファイルを除去するなどの対処をして直します。</p>

<h3>VM の起動</h3>

<p>docker デーモンの VM を <code>./boot2docker up</code> で起動します。</p>

<p>```
% ./boot2docker up
[2014-02-22 23:50:43] Starting boot2docker-vm&hellip;
[2014-02-22 23:51:03] Started.</p>

<p>To connect the docker client to the Docker daemon, please set:
export DOCKER_HOST=tcp://localhost:4243</p>

<p>```</p>

<p>止めるのは <code>./boot2docker stop</code> です。</p>

<h3>ssh で中に入る</h3>

<p><code>vagrant</code> と似た感じで <code>./boot2docker ssh</code> で中に入れます。
ユーザーは <code>docker</code> でパスワードは <code>tcuser</code> です。
Tiny Core Linux ベースなので、こういうパスワードになっているのだと思います。</p>

<p>```
% ./boot2docker ssh
docker@localhost&rsquo;s password:</p>

<pre><code>                    ##        .
              ## ## ##       ==
           ## ## ## ##      ===
       /""""""""""""""""\___/ ===
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~
       \______ o          __/
         \    \        __/
          \____\______/
</code></pre>

<hr />

<p>| |<strong>   </strong><em>   </em><strong> | |<em>|</em></strong> \ <strong>| | </strong><em>   </em><strong>| | </strong><em><strong> _ </strong>
| &lsquo;</em> \ / _ \ / _ \| <strong>| </strong>) / <em>` |/ _ \ / <strong>| |/ / _ \ &rsquo;</strong>|
| |</em>) | (<em>) | (</em>) | |<em> / __/ (</em>| | (<em>) | (<strong>|   &lt;  </strong>/ |
|</em>.<strong>/ _</strong>/ _<strong>/ _<em>|</em></strong><strong>_<em>,</em>|_</strong>/ _<strong>|_|__</strong>|_|
boot2docker: 0.6.0
docker@boot2docker:~$
```</p>

<h2>docker を使ってみる</h2>

<p>ホスト OS 側に docker コマンドをインストールして、そこから使っても良いのですが、
Homebrew でインストールできたバージョンが 0.8.0 で少し古かったので、
主に VM の中の docker コマンドを使いました。</p>

<p>ドキュメントでは <code>sudo docker</code> で実行していますが、
TCP 接続だったり、ローカルの unix socket の場合でもグループのアクセス権限で許可されている場合などは
<code>sudo</code> なしの <code>docker</code> コマンドだけで大丈夫です。</p>

<p><code>boot2docker</code> の VM の場合は <code>/var/run/docker.sock</code> が <code>docker</code> グループに読み書きが許可されていて、
<code>docker</code> ユーザーが <code>docker</code> グループに属しているため、 <code>sudo</code> が不要になっています。</p>

<h3>バージョンなどの情報確認</h3>

<p><code>docker version</code> や <code>docker info</code> で情報を確認します。</p>

<p><code>boot2docker</code> の場合は問題ないと思いますが、
docker のサーバーとの接続がうまくいかない場合はここでエラーなどになるので、
環境変数 <code>DOCKER_HOST</code> やポートフォワーディングや firewall などの設定を確認します。</p>

<p>まず VM の外の Homebrew でインストールした docker コマンドから確認しました。
ここでバージョンが古かったので、後は ssh で入った VM の中で docker コマンドを使うことにしました。</p>

<p>```
% export DOCKER_HOST=tcp://127.0.0.1:4243
% docker version
Client version: 0.8.0
Go version (client): go1.2
Git commit (client): cc3a8c8d8ec57e15b7b7316797132d770408ab1a</p>

<p>Server version: 0.8.1
Git commit (server): a1598d1
Go version (server): go1.2
Last stable version: 0.8.1, please update docker
```</p>

<p>VM の中では Server と Client のバージョンが最新版で一致しています。
ついでに <code>docker info</code> も確認しました。</p>

<p><code>
docker@boot2docker:~$ docker version
Client version: 0.8.1
Go version (client): go1.2
Git commit (client): a1598d1
Server version: 0.8.1
Git commit (server): a1598d1
Go version (server): go1.2
Last stable version: 0.8.1
docker@boot2docker:~$ docker info
Containers: 0
Images: 0
Driver: aufs
 Root Dir: /mnt/sda1/var/lib/docker/aufs
 Dirs: 0
Debug mode (server): true
Debug mode (client): false
Fds: 10
Goroutines: 13
Execution Driver: lxc-0.8.0
EventsListeners: 0
Kernel Version: 3.13.3-tinycore64
Init Path: /usr/local/bin/docker
docker@boot2docker:~$
</code></p>

<h3>docker を試してみる</h3>

<p><code>docker pull ubuntu</code> であらかじめダウンロードしてから <code>docker run</code> を実行しても良いのですが、
いきなり <code>docker run -i -t ubuntu /bin/bash</code> を実行しても、
自動的にダウンロードしてから実行されます。</p>

<p>ダウンロードはサーバー側が遅いのか、時間がかかることがあるようなので、
ゆっくり待った方が良さそうです。</p>

<p>引数に指定した <code>/bin/bash</code> がコンテナの中の唯一のプロセスとして起動するので、
自由に試してみて、 <code>exit</code> などで <code>/bin/bash</code> が終了すればコンテナも終了します。</p>

<p><code>
docker@boot2docker:~$ docker run -i -t ubuntu /bin/bash
Unable to find image 'ubuntu' locally
Pulling repository ubuntu
9cd978db300e: Download complete
eb601b8965b8: Download complete
5ac751e8d623: Download complete
9cc9ea5ea540: Download complete
9f676bd305a4: Download complete
511136ea3c5a: Download complete
f323cf34fd77: Download complete
6170bb7b0ad1: Download complete
1c7f181e78b9: Download complete
7a4f87241845: Download complete
321f7f4200f4: Download complete
root@a64cca91db41:/# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 15:32 ?        00:00:00 /bin/bash
root         9     1  0 15:33 ?        00:00:00 ps -ef
root@a64cca91db41:/# exit
exit
docker@boot2docker:~$
</code></p>

<p><a href="http://blog.n-z.jp/blog/2013-12-24-docker-rm.html">Dockerで不要になったコンテナやイメージを削除する</a>
に書いたようにコンテナが溜まっていくので、削除しておきます。</p>

<p><code>
docker@boot2docker:~$ docker ps -a -q
a64cca91db41
docker@boot2docker:~$ docker rm `docker ps -a -q`
a64cca91db41
docker@boot2docker:~$
</code></p>

<p>ちょっと試すだけなら <code>-rm</code> オプションを付けて自動削除するのが良さそうです。</p>

<p><code>
docker@boot2docker:~$ docker run -i -t -rm ubuntu /bin/bash
root@f810cbccf394:/# exit
exit
docker@boot2docker:~$ docker ps -a -q
docker@boot2docker:~$
</code></p>

<h2>つづく</h2>

<p><code>docker pull</code> に時間がかかって、すぐにはいろいろ試せないようなので、別の記事に続きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[installコマンドでコマンド数を減らす]]></title>
    <link href="http://blog.n-z.jp/blog/2014-02-14-install.html"/>
    <updated>2014-02-14T23:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/install</id>
    <content type="html"><![CDATA[<p>mkdir とか touch とか chown とか chmod とか個別に実行しなくても
install コマンドだけでまとめて出来るという話です。</p>

<!--more-->


<h2>問題例</h2>

<p>Dockerfile の RUN などが典型的な例ですが、他でも例えば
<code>mkdir -p /home/foo/.ssh; chown foo /home/foo/.ssh; chmod 0700 /home/foo/.ssh</code>
のようなことをすることがあると思います。</p>

<p>特に Dockerfile の場合は RUN ごとにイメージがたまっていくこともあって、
<code>;</code> や <code>&amp;&amp;</code> でつなげて単独の RUN にまとめて書くことも多いと思います。</p>

<h2>install でディレクトリを作る</h2>

<p>たとえば</p>

<p><code>
 mkdir -p /home/foo/.ssh
 chown foo /home/foo/.ssh
 chgrp users /home/foo/.ssh
 chmod 0700 /home/foo/.ssh
</code></p>

<p>なら
<code>install -o foo -g users -m 0700 -d /home/foo/.ssh</code>
にまとめられます。</p>

<p><code>install -o foo -g users -m 0700 -d /home/foo/.ssh /home/foo/tmp</code>
のように複数ディレクトリを同時に作成することも出来ます。</p>

<p>2014-02-16 追記:
<a href="http://qiita.com/znz/items/fee7c42587e995566a69#comment-a08bc7770a5fcdf902a0">Qiita の方のコメント</a>
で
<code>sudo -u user mkdir -p -m 700 /home/user/.ssh</code>
というやり方もあるという話がありました。</p>

<h2>install でファイルをコピーする</h2>

<p>たとえば</p>

<p><code>
 cp /path/from/*.txt /path/to/
 chown foo /path/to/*.txt
 chgrp users /path/to/*.txt
 chmod 0644 /path/to/*.txt
</code></p>

<p>なら
<code>install -o foo -g users -m 0644 /path/from/*.txt /path/to/</code>
にまとめられます。</p>

<p><code>install -o foo -g users -m 0644 -t /path/to /path/from/*.txt</code>
のようにディレクトリを先に書くことも出来ます。</p>

<p>1ファイルだけなら
<code>install -o foo -g users -m 0644  /path/from/foo.txt /path/to/bar.txt</code>
のようにコピー先のファイル名を指定することも出来ます。</p>

<h2>まとめ</h2>

<p>たくさん <code>chown</code> や <code>chmod</code> を実行していることがあれば、
<code>install</code> コマンドでまとめられないか検討してみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dockerで不要になったコンテナやイメージを削除する]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-24-docker-rm.html"/>
    <updated>2013-12-24T11:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/docker-rm</id>
    <content type="html"><![CDATA[<p>Docker を使い続けてコンテナやイメージを放置していると差分だけとはいえ、
ディスクの消費が増えていって、
<code>書き込みエラー: デバイスに空き領域がありません</code>
(<code>ENOSPC</code>, <code>write error: No space left on device</code>)
というエラーになってしまいます。</p>

<!--more-->


<h2>コンテナの削除</h2>

<p><a href="http://docs.docker.io/en/latest/commandline/cli/#rm">docker rm</a>
の Eamples にあるように</p>

<p><code>console
 docker rm `docker ps -a -q`
</code></p>

<p>で停止しているコンテナを削除できます。</p>

<p>実行中のコンテナがあると削除できないというエラーが出ますが、
意図的にやっていることなので気にする必要はありません。</p>

<p>公式のドキュメントにも書いてある方法なので、
コンテナの削除方法はこのやり方で問題ないと思います。</p>

<h2>イメージの削除</h2>

<p><a href="https://github.com/dotcloud/docker/blob/e960152a1e9064d8c2ae57b9ab2a33d9b27276b9/CHANGELOG.md#072-2013-12-16">0.7.2 (2013-12-16) の変更点</a>
に
「実行中以外であってもコンテナが依存しているイメージは削除できなくした」
(Prevent deletion of image if ANY container is depending on it even if the container is not running)
と書いてあって、
今まではコンテナが停止していれば
<code>docker rmi</code> でイメージが削除できていたのですが、
0.7.2 からはできなくなったので、
上記の手順でコンテナを先に削除しておく必要があります。</p>

<p>不要なイメージの削除は
<code>docker images</code> で <code>REPOSITORY</code> が
<code>&lt;none&gt;</code> になっているものを削除すれば良いので、</p>

<p><code>console
 docker rmi $(docker images | awk '/^&lt;none&gt;/ { print $3 }')
</code></p>

<p>のようにすれば可能です。</p>

<p><code>Error: No such image: xxxxxxxxxxxx</code>
のようにエラーが出ることがありますが、
他のイメージを削除したときに一緒に削除されてしまっているだけで、
特に問題はないようです。</p>

<p><a href="https://github.com/dotcloud/docker/blob/a665517151911866285e5a72164c5f2d2f31ba65/FIXME">FIXME</a>
に書いてある方法なので、
現状はこの方法が無難だと思います。</p>

<p>FIXME に書いてあるということで、
将来的にはコンテナの削除の方も含めて、
もっと簡単なコマンドが用意される予定のようです。</p>

<h2>その他のイメージの削除</h2>

<p><code>docker rmi local/debian-ja:7.2</code> で特定の <code>TAG</code> のイメージを削除したり、
<code>docker rmi shipyard/shipyard</code> で特定の <code>REPOSITORY</code> のすべてのイメージを削除したりできます。</p>

<h2>まとめ</h2>

<p>docker を使い続けていると起きることのある問題の対処方法を紹介しました。</p>

<p>本題ではないので上には書いていませんが、
イメージがたまっている状態で削除する前に
<a href="http://docs.docker.io/en/latest/commandline/cli/#displaying-images-visually">docker images -viz</a>
を見てみるのも面白いかもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DOCKER indexのTrusted Buildsで複数バージョンのrubyを試せるimageを作ってみた]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-19-docker-trusted-builds.html"/>
    <updated>2013-12-19T23:02:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/docker-trusted-builds</id>
    <content type="html"><![CDATA[<p><a href="https://index.docker.io/">DOCKER index</a>
には
<a href="http://blog.docker.io/2013/11/introducing-trusted-builds/">Trusted Builds</a>
という機能があり、
Docker index の方で
image の作成をしてくれます。</p>

<p>image の作成方法は GitHub に Dockerfile を公開して、
それを指定します。</p>

<p>今回はそれを使って複数バージョンの ruby を試せる image を作ってみました。</p>

<!--more-->


<h2>Dockerfile の動作確認</h2>

<p><code>docker build</code> への Dockerfile の指定方法は</p>

<pre><code>docker build DockerfileのあるディレクトリへのパスやURL
</code></pre>

<p>という方法と</p>

<pre><code>docker build - &lt; Dockerfile
</code></pre>

<p>のように <code>-</code> を指定して標準入力から渡す方法があります。</p>

<p>違いとしては
パスや URL の指定だとファイル名が Dockerfile 固定という制限があり、
<code>-</code> の方だと <code>ADD</code> が使えない (基準となるディレクトリがわからないため)
という制限があるようです。
(詳しく調べていないだけなので他にもあると思います。)</p>

<p>そこで、</p>

<pre><code>docker build -t local/rubys .
</code></pre>

<p>または</p>

<pre><code>docker build -t local/rubys - &lt; Dockerfile
</code></pre>

<p>のようにして動作確認します。</p>

<h2>DOCKER index のアカウント登録</h2>

<p>英小文字か数字で4文字から30文字という制限があったので、
<code>znzj</code> というアカウントにしました。</p>

<p>メールアドレスとパスワードを設定して、
メールの確認が済んだらアカウントの作成は完了です。</p>

<p>最近はサービスごとにメールアドレスを分けていて、
アイコンが gravatar のデフォルトになってしまっていたので、
User Settings から Gravatar email も設定しました。</p>

<p>ここはメールアドレスの確認がなかったので、
他人のアイコンでも使えてしまうように見えたのですが、
良いのでしょうか。
ちょっと考えてみましたが、
画像をコピーして使えば同じようなものなので、
気にするほどのことではなさそうに思いました。</p>

<h2>GitHub のアカウントとの連携</h2>

<p>hook の登録のため、ということで多少の書き込み権限も要求されるので、
許可したくない場合は Trusted builds は使えません。</p>

<h2>Trusted Builds の追加</h2>

<p>ログイン中に
<a href="https://index.docker.io/builds/">Trusted Builds</a>
のページの <code>+Add New</code> から、
GitHub レポジトリを選択します。
ここでは <a href="https://github.com/znz/docker-rubys">https://github.com/znz/docker-rubys</a> を選択しました。</p>

<ol>
<li>Default Branch は <code>master</code> のまま</li>
<li>Repo name も <code>znzj/docker-rubys</code> のまま (<code>/</code> の右の部分は英小文字か数字か <code>-</code> か <code>.</code> で 3 文字から 30 文字)</li>
<li>Docker Tag Name も <code>latest</code> のまま</li>
<li>Dockerfile Location は <code>/</code> から <code>rubys/</code> に変更</li>
<li>Active にはチェックをいれたまま</li>
</ol>


<p>という状態で作成しました。</p>

<p><code>Dockerfile</code> の push とどっちが先が良いのかわからなかったので、
<code>Dockerfile</code> なしで追加してしまったら、
初回は <code>Dockerfile</code> が見つからないという理由で失敗してしまったので、
先に <code>Dockerfile</code> を push してから追加するもののようです。</p>

<h2>イメージの使用</h2>

<p>しばらくまつと Trusted Builds のページで
Status が Pending から Building に変わって、
最終的に Done になってビルドできて使えるようになるので、</p>

<pre><code>docker pull znzj/docker-rubys
</code></pre>

<p>でダウンロードします。</p>

<p>ダウンロードが完了したら、</p>

<pre><code>docker run -i -t znzj/docker-rubys
</code></pre>

<p>で <code>/bin/bash -l</code> を起動します。
(<code>CMD</code> で指定されています。)</p>

<p>bash で</p>

<pre><code>rbenv versions
</code></pre>

<p>で入っている ruby のバージョンを確認したり、</p>

<pre><code>rbenv each ruby -v
</code></pre>

<p>や</p>

<pre><code>rbenv each -v gem list
</code></pre>

<p>などのように
<a href="https://github.com/chriseppstein/rbenv-each">rbenv each</a>
を使って、
それぞれのバージョンの ruby の環境でコマンドを実行できるようにしています。</p>

<p>ホスト側とのファイルのやり取りはどうするのが良いのか
まだ調べていないので、
とりあえず vim でファイルを作成するか、
wget でダウンロードすることを想定しています。</p>

<h2>abuse?</h2>

<p><code>GitHub: Add Trusted Build</code>
のところに
<code>Anyone who abuses the build system, will have their accounts disabled. If you are unsure what might be considered abuse, please ask before you build.</code>
という注意書きがあって、
ビルドするぐらいなら大丈夫かと思っていたのですが、
他の Trusted Builds をみるとインストールしたり
ファイルを追加したりしているだけのものが
多いので心配になってしまいました。
さらに探してみると
<a href="https://index.docker.io/u/sameersbn/gitlab/">https://index.docker.io/u/sameersbn/gitlab/</a>
で ruby を make しているものもあったので、
ビルドはダメということもなさそうでした。</p>

<p>しかし、頻繁にビルドして負荷をかけるのもよくなさそうなので、
trunk の nightly build などをしようと思ったら、
ローカルで作成して <code>docker push</code> する方がよさそうに感じました。</p>

<h2>aufs の制限</h2>

<p><a href="https://github.com/dotcloud/docker/issues/332">https://github.com/dotcloud/docker/issues/332</a>
によると aufs は重ねられる数に限界 (40ぐらい?) があるようなので、
<code>RUN</code> コマンドは出来るだけまとめて減らした方が良いのかもしれません。</p>

<p><a href="https://index.docker.io/u/truongsinh/nodejs/">https://index.docker.io/u/truongsinh/nodejs/</a>
のように <code>&amp;&amp;</code> でつなげて 1 個の <code>RUN</code> にまとめている例もありました。</p>

<p>aufs 以外が主流になるかもしれないので、
この辺りは Dockerfile の読みやすさや
<code>docker history</code> でわかれていた方が良いのかなど、
利点や欠点を考えつつ、
ベストプラクティスが決まっていくまで
試行錯誤するのが良さそうです。</p>

<h2>まとめ</h2>

<p>DOCKER index には Trusted Builds という向こう側で
<code>docker build</code> してくれる仕組みがあるので、
<code>docker push</code> とうまく使い分けて
公開可能なイメージはどんどん公開すると良いのではないでしょうか。</p>
]]></content>
  </entry>
  
</feed>
