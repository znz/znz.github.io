<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2014-04-05T23:38:49+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[boot2dockerでdockerを試す]]></title>
    <link href="http://blog.n-z.jp/blog/2014-02-23-boot2docker.html"/>
    <updated>2014-02-23T00:47:22+09:00</updated>
    <id>http://blog.n-z.jp/blog/boot2docker</id>
    <content type="html"><![CDATA[<p>boot2docker で最新の docker を試してみました。
他ではあまり書いていないアンインストール方法も書いているので、
不要になった時や何か変になった時の削除方法も参考になると思います。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Mac OS X 10.9.1 で試しましたが Linux でも同様に動くはずです</li>
<li>VirtualBox 4.3.6</li>
<li>boot2docker 0.6.0</li>
<li>docker 0.8.1</li>
</ul>


<h2>VirtualBox</h2>

<p>あらかじめ VirtualBox をインストールしておきます。</p>

<h2>boot2docker</h2>

<p><a href="http://docs.docker.io/en/latest/installation/mac/">http://docs.docker.io/en/latest/installation/mac/</a> の手順に従って
<code>boot2docker</code> を入れてみます。</p>

<h3>インストール</h3>

<p>適当なディレクトリに <code>boot2docker</code> をダウンロードして実行可能にします。</p>

<p><code>
 mkdir -p ~/boot2docker
 cd ~/boot2docker
 curl https://raw.github.com/boot2docker/boot2docker/master/boot2docker &gt; boot2docker
 chmod +x boot2docker
</code></p>

<p>この段階でのアンインストールは <code>boot2docker</code> を削除するだけです。</p>

<h3>VM イメージの作成</h3>

<p>初回は <code>./boot2docker init</code> を実行して iso のダウンロードと VM の作成をします。</p>

<p>```
% ./boot2docker init
[2014-02-22 23:43:36] Creating VM boot2docker-vm
Virtual machine &lsquo;boot2docker-vm&rsquo; is created and registered.
UUID: 61e0ec36-fc80-4b70-ac11-899f6526a57e
Settings file: &lsquo;/Users/kazu/VirtualBox VMs/boot2docker-vm/boot2docker-vm.vbox&rsquo;
[2014-02-22 23:43:36] Setting VM settings
[2014-02-22 23:43:36] Setting VM networking
[2014-02-22 23:43:36] boot2docker.iso not found.
[2014-02-22 23:43:38] Latest version is v0.6.0, downloading&hellip;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>

<pre><code>                             Dload  Upload   Total   Spent    Left  Speed
</code></pre>

<p>100   346  100   346    0     0    319      0  0:00:01  0:00:01 &mdash;:&mdash;:&mdash;   319
100 24.0M  100 24.0M    0     0   295k      0  0:01:23  0:01:23 &mdash;:&mdash;:&mdash;  498k
[2014-02-22 23:45:02] Done
[2014-02-22 23:45:02] Setting VM disks
[2014-02-22 23:45:02] Creating 40000 Meg hard drive&hellip;
Converting from raw image file=&ldquo;stdin&rdquo; to file=&ldquo;/Users/kazu/.boot2docker/boot2docker-vm.vmdk&rdquo;&hellip;
Creating dynamic image with size 41943040000 bytes (40000MB)&hellip;
[2014-02-22 23:45:02] Done.
[2014-02-22 23:45:02] You can now type boot2docker up and wait for the VM to start.
```</p>

<p>この段階のやり直しは VM が起動していれば <code>./boot2docker stop</code> で止めて、
<code>./boot2docker delete</code> で VM を削除するだけではダメで、
<code>~/.boot2docker</code> も削除する必要があります。</p>

<p>パスは <code>boot2docker</code> の中の <code>BOOT2DOCKER_CFG_DIR</code> に書かれていて、
以下の設定は <code>$HOME/.boot2docker/profile</code> で設定変更できます。</p>

<ul>
<li><code>VM_NAME</code> : VirtualBox での VM の名前 (デフォルト: <code>boot2docker-vm</code>)</li>
<li><code>DOCKER_PORT</code> : ホスト側で docker 用に使うポート (デフォルト: <code>4243</code>)</li>
<li><code>SSH_HOST_PORT</code> : ホスト側で ssh サーバー用に使うポート (デフォルト: <code>2022</code>)</li>
<li><code>VM_DISK</code> : vmdk ファイルのパス (デフォルト: <code>${BOOT2DOCKER_CFG_DIR}/${VM_NAME}.vmdk</code>)</li>
<li><code>VM_DISK_SIZE</code> : vmdk の容量 (デフォルト: <code>40000</code> メガバイト)</li>
<li><code>VM_MEM</code> : メモリ (デフォルト: <code>1024</code>)</li>
<li><code>BOOT2DOCKER_ISO</code> : ISO ファイルのパス (デフォルト: <code>${BOOT2DOCKER_CFG_DIR}/boot2docker.iso</code>)</li>
</ul>


<p>VM を作り直すだけなら <code>./boot2docker delete</code> して <code>./boot2docker init</code> すれば
ISO はダウンロードし直さずに VM だけ作り直せます。</p>

<p>間違えて先に <code>~/.boot2docker</code> を削除してしまうと VirtualBox の状態が不整合になるので、
VirtualBox の GUI の方の仮想メディアマネージャーで存在しなくっているファイルを除去するなどの対処をして直します。</p>

<h3>VM の起動</h3>

<p>docker デーモンの VM を <code>./boot2docker up</code> で起動します。</p>

<p>```
% ./boot2docker up
[2014-02-22 23:50:43] Starting boot2docker-vm&hellip;
[2014-02-22 23:51:03] Started.</p>

<p>To connect the docker client to the Docker daemon, please set:
export DOCKER_HOST=tcp://localhost:4243</p>

<p>```</p>

<p>止めるのは <code>./boot2docker stop</code> です。</p>

<h3>ssh で中に入る</h3>

<p><code>vagrant</code> と似た感じで <code>./boot2docker ssh</code> で中に入れます。
ユーザーは <code>docker</code> でパスワードは <code>tcuser</code> です。
Tiny Core Linux ベースなので、こういうパスワードになっているのだと思います。</p>

<p>```
% ./boot2docker ssh
docker@localhost&rsquo;s password:</p>

<pre><code>                    ##        .
              ## ## ##       ==
           ## ## ## ##      ===
       /""""""""""""""""\___/ ===
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~
       \______ o          __/
         \    \        __/
          \____\______/
</code></pre>

<hr />

<p>| |<strong>   </strong><em>   </em><strong> | |<em>|</em></strong> \ <strong>| | </strong><em>   </em><strong>| | </strong><em><strong> _ </strong>
| &lsquo;</em> \ / _ \ / _ \| <strong>| </strong>) / <em>` |/ _ \ / <strong>| |/ / _ \ &rsquo;</strong>|
| |</em>) | (<em>) | (</em>) | |<em> / __/ (</em>| | (<em>) | (<strong>|   &lt;  </strong>/ |
|</em>.<strong>/ _</strong>/ _<strong>/ _<em>|</em></strong><strong>_<em>,</em>|_</strong>/ _<strong>|_|__</strong>|_|
boot2docker: 0.6.0
docker@boot2docker:~$
```</p>

<h2>docker を使ってみる</h2>

<p>ホスト OS 側に docker コマンドをインストールして、そこから使っても良いのですが、
Homebrew でインストールできたバージョンが 0.8.0 で少し古かったので、
主に VM の中の docker コマンドを使いました。</p>

<p>ドキュメントでは <code>sudo docker</code> で実行していますが、
TCP 接続だったり、ローカルの unix socket の場合でもグループのアクセス権限で許可されている場合などは
<code>sudo</code> なしの <code>docker</code> コマンドだけで大丈夫です。</p>

<p><code>boot2docker</code> の VM の場合は <code>/var/run/docker.sock</code> が <code>docker</code> グループに読み書きが許可されていて、
<code>docker</code> ユーザーが <code>docker</code> グループに属しているため、 <code>sudo</code> が不要になっています。</p>

<h3>バージョンなどの情報確認</h3>

<p><code>docker version</code> や <code>docker info</code> で情報を確認します。</p>

<p><code>boot2docker</code> の場合は問題ないと思いますが、
docker のサーバーとの接続がうまくいかない場合はここでエラーなどになるので、
環境変数 <code>DOCKER_HOST</code> やポートフォワーディングや firewall などの設定を確認します。</p>

<p>まず VM の外の Homebrew でインストールした docker コマンドから確認しました。
ここでバージョンが古かったので、後は ssh で入った VM の中で docker コマンドを使うことにしました。</p>

<p>```
% export DOCKER_HOST=tcp://127.0.0.1:4243
% docker version
Client version: 0.8.0
Go version (client): go1.2
Git commit (client): cc3a8c8d8ec57e15b7b7316797132d770408ab1a</p>

<p>Server version: 0.8.1
Git commit (server): a1598d1
Go version (server): go1.2
Last stable version: 0.8.1, please update docker
```</p>

<p>VM の中では Server と Client のバージョンが最新版で一致しています。
ついでに <code>docker info</code> も確認しました。</p>

<p><code>
docker@boot2docker:~$ docker version
Client version: 0.8.1
Go version (client): go1.2
Git commit (client): a1598d1
Server version: 0.8.1
Git commit (server): a1598d1
Go version (server): go1.2
Last stable version: 0.8.1
docker@boot2docker:~$ docker info
Containers: 0
Images: 0
Driver: aufs
 Root Dir: /mnt/sda1/var/lib/docker/aufs
 Dirs: 0
Debug mode (server): true
Debug mode (client): false
Fds: 10
Goroutines: 13
Execution Driver: lxc-0.8.0
EventsListeners: 0
Kernel Version: 3.13.3-tinycore64
Init Path: /usr/local/bin/docker
docker@boot2docker:~$
</code></p>

<h3>docker を試してみる</h3>

<p><code>docker pull ubuntu</code> であらかじめダウンロードしてから <code>docker run</code> を実行しても良いのですが、
いきなり <code>docker run -i -t ubuntu /bin/bash</code> を実行しても、
自動的にダウンロードしてから実行されます。</p>

<p>ダウンロードはサーバー側が遅いのか、時間がかかることがあるようなので、
ゆっくり待った方が良さそうです。</p>

<p>引数に指定した <code>/bin/bash</code> がコンテナの中の唯一のプロセスとして起動するので、
自由に試してみて、 <code>exit</code> などで <code>/bin/bash</code> が終了すればコンテナも終了します。</p>

<p><code>
docker@boot2docker:~$ docker run -i -t ubuntu /bin/bash
Unable to find image 'ubuntu' locally
Pulling repository ubuntu
9cd978db300e: Download complete
eb601b8965b8: Download complete
5ac751e8d623: Download complete
9cc9ea5ea540: Download complete
9f676bd305a4: Download complete
511136ea3c5a: Download complete
f323cf34fd77: Download complete
6170bb7b0ad1: Download complete
1c7f181e78b9: Download complete
7a4f87241845: Download complete
321f7f4200f4: Download complete
root@a64cca91db41:/# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 15:32 ?        00:00:00 /bin/bash
root         9     1  0 15:33 ?        00:00:00 ps -ef
root@a64cca91db41:/# exit
exit
docker@boot2docker:~$
</code></p>

<p><a href="http://blog.n-z.jp/blog/2013-12-24-docker-rm.html">Dockerで不要になったコンテナやイメージを削除する</a>
に書いたようにコンテナが溜まっていくので、削除しておきます。</p>

<p><code>
docker@boot2docker:~$ docker ps -a -q
a64cca91db41
docker@boot2docker:~$ docker rm `docker ps -a -q`
a64cca91db41
docker@boot2docker:~$
</code></p>

<p>ちょっと試すだけなら <code>-rm</code> オプションを付けて自動削除するのが良さそうです。</p>

<p><code>
docker@boot2docker:~$ docker run -i -t -rm ubuntu /bin/bash
root@f810cbccf394:/# exit
exit
docker@boot2docker:~$ docker ps -a -q
docker@boot2docker:~$
</code></p>

<h2>つづく</h2>

<p><code>docker pull</code> に時間がかかって、すぐにはいろいろ試せないようなので、別の記事に続きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[installコマンドでコマンド数を減らす]]></title>
    <link href="http://blog.n-z.jp/blog/2014-02-14-install.html"/>
    <updated>2014-02-14T23:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/install</id>
    <content type="html"><![CDATA[<p>mkdir とか touch とか chown とか chmod とか個別に実行しなくても
install コマンドだけでまとめて出来るという話です。</p>

<!--more-->


<h2>問題例</h2>

<p>Dockerfile の RUN などが典型的な例ですが、他でも例えば
<code>mkdir -p /home/foo/.ssh; chown foo /home/foo/.ssh; chmod 0700 /home/foo/.ssh</code>
のようなことをすることがあると思います。</p>

<p>特に Dockerfile の場合は RUN ごとにイメージがたまっていくこともあって、
<code>;</code> や <code>&amp;&amp;</code> でつなげて単独の RUN にまとめて書くことも多いと思います。</p>

<h2>install でディレクトリを作る</h2>

<p>たとえば</p>

<p><code>
 mkdir -p /home/foo/.ssh
 chown foo /home/foo/.ssh
 chgrp users /home/foo/.ssh
 chmod 0700 /home/foo/.ssh
</code></p>

<p>なら
<code>install -o foo -g users -m 0700 -d /home/foo/.ssh</code>
にまとめられます。</p>

<p><code>install -o foo -g users -m 0700 -d /home/foo/.ssh /home/foo/tmp</code>
のように複数ディレクトリを同時に作成することも出来ます。</p>

<p>2014-02-16 追記:
<a href="http://qiita.com/znz/items/fee7c42587e995566a69#comment-a08bc7770a5fcdf902a0">Qiita の方のコメント</a>
で
<code>sudo -u user mkdir -p -m 700 /home/user/.ssh</code>
というやり方もあるという話がありました。</p>

<h2>install でファイルをコピーする</h2>

<p>たとえば</p>

<p><code>
 cp /path/from/*.txt /path/to/
 chown foo /path/to/*.txt
 chgrp users /path/to/*.txt
 chmod 0644 /path/to/*.txt
</code></p>

<p>なら
<code>install -o foo -g users -m 0644 /path/from/*.txt /path/to/</code>
にまとめられます。</p>

<p><code>install -o foo -g users -m 0644 -t /path/to /path/from/*.txt</code>
のようにディレクトリを先に書くことも出来ます。</p>

<p>1ファイルだけなら
<code>install -o foo -g users -m 0644  /path/from/foo.txt /path/to/bar.txt</code>
のようにコピー先のファイル名を指定することも出来ます。</p>

<h2>まとめ</h2>

<p>たくさん <code>chown</code> や <code>chmod</code> を実行していることがあれば、
<code>install</code> コマンドでまとめられないか検討してみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dockerで不要になったコンテナやイメージを削除する]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-24-docker-rm.html"/>
    <updated>2013-12-24T11:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/docker-rm</id>
    <content type="html"><![CDATA[<p>Docker を使い続けてコンテナやイメージを放置していると差分だけとはいえ、
ディスクの消費が増えていって、
<code>書き込みエラー: デバイスに空き領域がありません</code>
(<code>ENOSPC</code>, <code>write error: No space left on device</code>)
というエラーになってしまいます。</p>

<!--more-->


<h2>コンテナの削除</h2>

<p><a href="http://docs.docker.io/en/latest/commandline/cli/#rm">docker rm</a>
の Eamples にあるように</p>

<p><code>console
 docker rm `docker ps -a -q`
</code></p>

<p>で停止しているコンテナを削除できます。</p>

<p>実行中のコンテナがあると削除できないというエラーが出ますが、
意図的にやっていることなので気にする必要はありません。</p>

<p>公式のドキュメントにも書いてある方法なので、
コンテナの削除方法はこのやり方で問題ないと思います。</p>

<h2>イメージの削除</h2>

<p><a href="https://github.com/dotcloud/docker/blob/e960152a1e9064d8c2ae57b9ab2a33d9b27276b9/CHANGELOG.md#072-2013-12-16">0.7.2 (2013-12-16) の変更点</a>
に
「実行中以外であってもコンテナが依存しているイメージは削除できなくした」
(Prevent deletion of image if ANY container is depending on it even if the container is not running)
と書いてあって、
今まではコンテナが停止していれば
<code>docker rmi</code> でイメージが削除できていたのですが、
0.7.2 からはできなくなったので、
上記の手順でコンテナを先に削除しておく必要があります。</p>

<p>不要なイメージの削除は
<code>docker images</code> で <code>REPOSITORY</code> が
<code>&lt;none&gt;</code> になっているものを削除すれば良いので、</p>

<p><code>console
 docker rmi $(docker images | awk '/^&lt;none&gt;/ { print $3 }')
</code></p>

<p>のようにすれば可能です。</p>

<p><code>Error: No such image: xxxxxxxxxxxx</code>
のようにエラーが出ることがありますが、
他のイメージを削除したときに一緒に削除されてしまっているだけで、
特に問題はないようです。</p>

<p><a href="https://github.com/dotcloud/docker/blob/a665517151911866285e5a72164c5f2d2f31ba65/FIXME">FIXME</a>
に書いてある方法なので、
現状はこの方法が無難だと思います。</p>

<p>FIXME に書いてあるということで、
将来的にはコンテナの削除の方も含めて、
もっと簡単なコマンドが用意される予定のようです。</p>

<h2>その他のイメージの削除</h2>

<p><code>docker rmi local/debian-ja:7.2</code> で特定の <code>TAG</code> のイメージを削除したり、
<code>docker rmi shipyard/shipyard</code> で特定の <code>REPOSITORY</code> のすべてのイメージを削除したりできます。</p>

<h2>まとめ</h2>

<p>docker を使い続けていると起きることのある問題の対処方法を紹介しました。</p>

<p>本題ではないので上には書いていませんが、
イメージがたまっている状態で削除する前に
<a href="http://docs.docker.io/en/latest/commandline/cli/#displaying-images-visually">docker images -viz</a>
を見てみるのも面白いかもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DOCKER indexのTrusted Buildsで複数バージョンのrubyを試せるimageを作ってみた]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-19-docker-trusted-builds.html"/>
    <updated>2013-12-19T23:02:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/docker-trusted-builds</id>
    <content type="html"><![CDATA[<p><a href="https://index.docker.io/">DOCKER index</a>
には
<a href="http://blog.docker.io/2013/11/introducing-trusted-builds/">Trusted Builds</a>
という機能があり、
Docker index の方で
image の作成をしてくれます。</p>

<p>image の作成方法は GitHub に Dockerfile を公開して、
それを指定します。</p>

<p>今回はそれを使って複数バージョンの ruby を試せる image を作ってみました。</p>

<!--more-->


<h2>Dockerfile の動作確認</h2>

<p><code>docker build</code> への Dockerfile の指定方法は</p>

<pre><code>docker build DockerfileのあるディレクトリへのパスやURL
</code></pre>

<p>という方法と</p>

<pre><code>docker build - &lt; Dockerfile
</code></pre>

<p>のように <code>-</code> を指定して標準入力から渡す方法があります。</p>

<p>違いとしては
パスや URL の指定だとファイル名が Dockerfile 固定という制限があり、
<code>-</code> の方だと <code>ADD</code> が使えない (基準となるディレクトリがわからないため)
という制限があるようです。
(詳しく調べていないだけなので他にもあると思います。)</p>

<p>そこで、</p>

<pre><code>docker build -t local/rubys .
</code></pre>

<p>または</p>

<pre><code>docker build -t local/rubys - &lt; Dockerfile
</code></pre>

<p>のようにして動作確認します。</p>

<h2>DOCKER index のアカウント登録</h2>

<p>英小文字か数字で4文字から30文字という制限があったので、
<code>znzj</code> というアカウントにしました。</p>

<p>メールアドレスとパスワードを設定して、
メールの確認が済んだらアカウントの作成は完了です。</p>

<p>最近はサービスごとにメールアドレスを分けていて、
アイコンが gravatar のデフォルトになってしまっていたので、
User Settings から Gravatar email も設定しました。</p>

<p>ここはメールアドレスの確認がなかったので、
他人のアイコンでも使えてしまうように見えたのですが、
良いのでしょうか。
ちょっと考えてみましたが、
画像をコピーして使えば同じようなものなので、
気にするほどのことではなさそうに思いました。</p>

<h2>GitHub のアカウントとの連携</h2>

<p>hook の登録のため、ということで多少の書き込み権限も要求されるので、
許可したくない場合は Trusted builds は使えません。</p>

<h2>Trusted Builds の追加</h2>

<p>ログイン中に
<a href="https://index.docker.io/builds/">Trusted Builds</a>
のページの <code>+Add New</code> から、
GitHub レポジトリを選択します。
ここでは <a href="https://github.com/znz/docker-rubys">https://github.com/znz/docker-rubys</a> を選択しました。</p>

<ol>
<li>Default Branch は <code>master</code> のまま</li>
<li>Repo name も <code>znzj/docker-rubys</code> のまま (<code>/</code> の右の部分は英小文字か数字か <code>-</code> か <code>.</code> で 3 文字から 30 文字)</li>
<li>Docker Tag Name も <code>latest</code> のまま</li>
<li>Dockerfile Location は <code>/</code> から <code>rubys/</code> に変更</li>
<li>Active にはチェックをいれたまま</li>
</ol>


<p>という状態で作成しました。</p>

<p><code>Dockerfile</code> の push とどっちが先が良いのかわからなかったので、
<code>Dockerfile</code> なしで追加してしまったら、
初回は <code>Dockerfile</code> が見つからないという理由で失敗してしまったので、
先に <code>Dockerfile</code> を push してから追加するもののようです。</p>

<h2>イメージの使用</h2>

<p>しばらくまつと Trusted Builds のページで
Status が Pending から Building に変わって、
最終的に Done になってビルドできて使えるようになるので、</p>

<pre><code>docker pull znzj/docker-rubys
</code></pre>

<p>でダウンロードします。</p>

<p>ダウンロードが完了したら、</p>

<pre><code>docker run -i -t znzj/docker-rubys
</code></pre>

<p>で <code>/bin/bash -l</code> を起動します。
(<code>CMD</code> で指定されています。)</p>

<p>bash で</p>

<pre><code>rbenv versions
</code></pre>

<p>で入っている ruby のバージョンを確認したり、</p>

<pre><code>rbenv each ruby -v
</code></pre>

<p>や</p>

<pre><code>rbenv each -v gem list
</code></pre>

<p>などのように
<a href="https://github.com/chriseppstein/rbenv-each">rbenv each</a>
を使って、
それぞれのバージョンの ruby の環境でコマンドを実行できるようにしています。</p>

<p>ホスト側とのファイルのやり取りはどうするのが良いのか
まだ調べていないので、
とりあえず vim でファイルを作成するか、
wget でダウンロードすることを想定しています。</p>

<h2>abuse?</h2>

<p><code>GitHub: Add Trusted Build</code>
のところに
<code>Anyone who abuses the build system, will have their accounts disabled. If you are unsure what might be considered abuse, please ask before you build.</code>
という注意書きがあって、
ビルドするぐらいなら大丈夫かと思っていたのですが、
他の Trusted Builds をみるとインストールしたり
ファイルを追加したりしているだけのものが
多いので心配になってしまいました。
さらに探してみると
<a href="https://index.docker.io/u/sameersbn/gitlab/">https://index.docker.io/u/sameersbn/gitlab/</a>
で ruby を make しているものもあったので、
ビルドはダメということもなさそうでした。</p>

<p>しかし、頻繁にビルドして負荷をかけるのもよくなさそうなので、
trunk の nightly build などをしようと思ったら、
ローカルで作成して <code>docker push</code> する方がよさそうに感じました。</p>

<h2>aufs の制限</h2>

<p><a href="https://github.com/dotcloud/docker/issues/332">https://github.com/dotcloud/docker/issues/332</a>
によると aufs は重ねられる数に限界 (40ぐらい?) があるようなので、
<code>RUN</code> コマンドは出来るだけまとめて減らした方が良いのかもしれません。</p>

<p><a href="https://index.docker.io/u/truongsinh/nodejs/">https://index.docker.io/u/truongsinh/nodejs/</a>
のように <code>&amp;&amp;</code> でつなげて 1 個の <code>RUN</code> にまとめている例もありました。</p>

<p>aufs 以外が主流になるかもしれないので、
この辺りは Dockerfile の読みやすさや
<code>docker history</code> でわかれていた方が良いのかなど、
利点や欠点を考えつつ、
ベストプラクティスが決まっていくまで
試行錯誤するのが良さそうです。</p>

<h2>まとめ</h2>

<p>DOCKER index には Trusted Builds という向こう側で
<code>docker build</code> してくれる仕組みがあるので、
<code>docker push</code> とうまく使い分けて
公開可能なイメージはどんどん公開すると良いのではないでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dockerのWeb UI 3種類を比較してみた]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-15-compare-docker-web-ui.html"/>
    <updated>2013-12-15T00:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/compare-docker-web-ui</id>
    <content type="html"><![CDATA[<p><a href="http://www.docker.io/">docker</a> の Web UI を比較してみました。</p>

<p>対象は以下の3種類の Web UI です。
検索すると <code>DockerUI</code> 以外が見つけにくいようなので、
まとめて紹介します。</p>

<ul>
<li><a href="https://github.com/shipyard/shipyard">Shipyard</a></li>
<li><a href="https://github.com/dynport/dockland">Dockland</a></li>
<li><a href="https://github.com/crosbymichael/dockerui">DockerUI</a></li>
</ul>


<!--more-->


<h2>対象バージョン</h2>

<p>先月末頃にも試したのですが、
その時にはこんなに <code>docker</code> が流行るとは思っていなかったので、
ちゃんとまとめていませんでした。</p>

<p>そこで改めて新しいバージョンを試しつつ比較したいと思います。</p>

<ul>
<li>amd64 の Ubuntu 13.04 (raring)</li>
<li>docker 0.7.1</li>
<li>Shipyard version 0dc558</li>
<li>Dockland 5a02db9d20</li>
<li>DockerUI v0.3 (5094acc024)</li>
</ul>


<h2>Shipyard</h2>

<h3>インストール</h3>

<p><a href="https://github.com/shipyard/shipyard/wiki/QuickStart">QuickStart</a>
の説明を参考にして <code>/etc/default/docker</code> を作成して <code>DOCKER_OPTS</code> を設定します。
<code>-d</code> は <code>/etc/init/docker.conf</code> の方に書いてあるので不要です。</p>

<p>VirtualBox の中で試したので、
IP アドレスは <code>10.0.2.15</code> にしています。</p>

<p><code>sh /etc/default/docker
DOCKER_OPTS="-H tcp://10.0.2.15:4243 -H unix:///var/run/docker.sock"
</code></p>

<p>公開されている latest Shipyard image を使って起動します。</p>

<p><code>console
docker pull shipyard/shipyard
docker run -i -t -d -p 80:80 -p 8000:8000 shipyard/shipyard
</code></p>

<p>バージョンアップの時も同様に <code>docker pull</code> でとってくると
古いイメージがたまっていくので、
<code>docker images</code> で一覧を確認して
<code>REPOSITORY</code> や <code>TAG</code> が <code>&lt;none&gt;</code> になっているイメージを
適当に <code>docker rmi</code> で削除すると良いと思います。</p>

<h3>初期設定</h3>

<p><code>http://127.0.0.1:8000/</code>
を開いて</p>

<ul>
<li>username: <code>admin</code></li>
<li>password: <code>shipyard</code></li>
</ul>


<p>でログインします。</p>

<p>左の <code>Hosts</code> を開いて <code>Add</code> で <code>docker</code> のホストを追加します。
例えば以下のような設定になります。</p>

<ul>
<li>Name: raring64</li>
<li>Hostname: 10.0.2.15</li>
<li>Public hostname: (空欄のまま)</li>
<li>Port: 4243</li>
</ul>


<h3>設定変更など</h3>

<p>以前は右上の <code>admin</code> から <code>administration</code> を選んで、
Django administration から追加する必要があったと思うのですが、
今は shipyard の方で設定できるようになっているようです。
追加や有効・無効の切り替えや削除は出来ても、
編集はまだ出来ないようなので、
<code>Name</code> などを変更したい時は
Django administration
の方を開く必要があるようです。</p>

<p>ログインパスワードの変更などのユーザー管理も
Django administration
の方を開く必要があるようです。</p>

<h3>使用感</h3>

<p>左の <code>Containers</code> や <code>Images</code> を開いてみて見ると何となく使い方がわかると思います。
バージョンアップで機能が増えていきそうなので、細かくは書きませんが、
ログが見えたりするのは便利です。</p>

<p><code>Applications</code> は
<a href="https://github.com/dotcloud/hipache">hipache</a>
に関連しているようです。</p>

<h2>Dockland</h2>

<h3>バージョン</h3>

<p>作りはじめで放置されているようで、
6 commits しかなくて、
latest commit も 2013 年 6 月になっています。
そのためバージョンは前回と変わっていません。</p>

<h3>依存関係</h3>

<p>sinatra ベースで作られていて、
graphviz も必要なので、
クリーンな環境に入れるのは大変です。</p>

<p>前回は docker のホスト側に入れたら大変だったので、
今回は <code>Dockerfile</code> を使ってインストールしました。</p>

<h3>インストール</h3>

<p>README にあった <code>dockland.dockerfile</code>
は古い docker のバージョンが対象のようなので、
最近の docker にあわせて
<code>EXPOSE</code> をコメントアウトするなどの
変更をして使います。
<code>APP_REVISION</code> のあたりは特定のリビジョンに固定して使いたい時のものだと思ったので、コメントアウトしています。</p>

<p>```plain dockland.dockerfile</p>

<h1>/tmp/dockland.dockerfile</h1>

<p>FROM ubuntu:12.04</p>

<p>RUN sed &rsquo;s/main$/main universe/&lsquo; -i /etc/apt/sources.list &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y
RUN apt-get install ruby1.9.1 ruby1.9.1-dev build-essential git-core graphviz libssl-dev -y</p>

<p>RUN git clone <a href="https://github.com/dynport/dockland.git">https://github.com/dynport/dockland.git</a> /app</p>

<h1>this is to speed up updates</h1>

<p>RUN cd /app &amp;&amp; gem install bundler &mdash;no-ri &mdash;no-rdoc &amp;&amp; bundle</p>

<h1>change the revision to update your image</h1>

<h1>ENV APP_REVISION 51f5445abeeb080568edeca248d68b29a66f1387</h1>

<h1>RUN cd /app &amp;&amp; git fetch -q origin  &amp;&amp; git reset -q &mdash;hard $APP_REVISION &amp;&amp; git clean -q -d -x -f &amp;&amp; bundle</h1>

<h1>EXPOSE 80</h1>

<p>CMD cd /app &amp;&amp; bundle exec ./bin/dockland -h ${DOCKER_HOST-<a href="http://10.0.2.15:4243">http://10.0.2.15:4243</a>} -p 80
```</p>

<p>公開するポートの指定は
docker 0.6.5 から
<code>Dockerfile</code> の
<code>EXPOSE</code> では出来なくなっていて、
<code>docker run</code> の引数の <code>-p</code> で指定する必要があります。
( <a href="http://blog.docker.io/2013/11/docker-0-7-docker-now-runs-on-any-linux-distribution/">Docker 0.7 runs on all Linux distributions – and 6 other major features | Docker Blog</a> の Feature 4: Advanced port redirects 参照)
<code>EXPOSE 80</code> のような指定はまだ使えるように書いてあるのですが、
ちゃんと使えたとしても外側のポートが可変なのは使いにくいので、
起動する時に指定するようにしました。</p>

<p><code>console
docker build -t dockland:dockland - &lt; /tmp/dockland.dockerfile
id=$(docker run -d -p 8080:80 dockland:dockland)
curl -I http://127.0.0.1:8080
</code></p>

<p>docker 側の API の公開設定は shipyard の方で設定したのと同じです。</p>

<h3>使用感</h3>

<p><code>graphviz</code> が必須ということからわかるかもしれませんが、
<code>docker images -viz</code> から生成できるイメージの有向グラフを使っています。
上の例だと <code>http://127.0.0.1:8080/</code> を開くと
矢印で繋がったイメージの ID 一覧が出てきて、
楕円の中の ID をクリックするとイメージの詳細情報が表示できます。</p>

<p>詳細ページには <code>DELETE</code> というボタンがあったり、
History から祖先のイメージをたどれたりするだけで
機能はほとんどありません。</p>

<p><code>docker images -viz</code> の図を良い感じに見たい、
という用途には良さそうです。</p>

<h2>DockerUI</h2>

<p>最後は DockerUI です。</p>

<h3>インストール</h3>

<p><code>console
docker pull crosbymichael/dockerui
docker run -d -p 9000:9000 crosbymichael/dockerui -e="http://10.0.2.15:4243"
</code></p>

<h3><code>-api-enable-cors</code> は必要?</h3>

<p>DockerUI は docker 側の引数に <code>-api-enable-cors</code> が必要と書いていますが、
ちょっと表示を試した感じでは付けていなくても動いていました。
本当に必要なのでしょうか?</p>

<h3>使用感</h3>

<p>最初の画面で円グラフが表示されているなど、
見た目は良く、
前回試した時に比べて機能も増えているように感じました。</p>

<p>認証がなかったり、 <code>-api-enable-cors</code> が必要と書いていたりして
セキュリティ的に気になる点がありました。</p>

<p>VM の中で動かすだけなので、セキュリティ的なことは気にしないとか、
firewall などで別途セキュリティは確保できるという状態なら
良いのではないでしょうか。</p>

<h3>dokku 環境にインストール</h3>

<p>もうちょっと調べていたところ、
<a href="https://github.com/crosbymichael/dockerui/pull/14">Makes dockerui compatible with dokku</a>
という変更が入っているようなので、
<code>dokku</code> 環境では <code>docker pull</code> の代わりに
<code>dokku</code> への <code>git push</code> で簡単に最新版を使えるようになるようです。</p>

<p><code>dokku</code> への <code>git push</code> は Installing のところで少し時間がかかります。</p>

<p>deploy 出来れば他の <code>dokku</code> に deploy したアプリと同じように
<code>http://dockerui.deploy.127.0.0.1.xip.io</code>
のような <code>dokku</code> で設定した URL で見えるようになります。</p>

<p>参考のため、実際に試したログを載せておきます。
<code>~/.ssh/config</code> で <code>raring64</code> という名前で <code>ssh</code> 接続できるようにしていて、
<code>dokku</code> ユーザーに接続する必要があるので、
<code>dokku@raring64</code> になっています。</p>

<p>```console
% git clone <a href="https://github.com/crosbymichael/dockerui">https://github.com/crosbymichael/dockerui</a>
Cloning into &lsquo;dockerui&rsquo;&hellip;
remote: Counting objects: 709, done.
remote: Compressing objects: 100% (385/385), done.
remote: Total 709 (delta 315), reused 705 (delta 314)
Receiving objects: 100% (709/709), 2.50 MiB | 585.00 KiB/s, done.
Resolving deltas: 100% (315/315), done.
Checking connectivity&hellip; done.
% cd dockerui
% git remote add raring64 dokku@raring64:dockerui
% git push raring64 master
Counting objects: 705, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (389/389), done.
Writing objects: 100% (705/705), 2.50 MiB | 0 bytes/s, done.
Total 705 (delta 313), reused 698 (delta 306)
&mdash;&mdash;&ndash;> Cleaning up &hellip;
&mdash;&mdash;&ndash;> Building dockerui &hellip;</p>

<pre><code>   Go app detected
</code></pre>

<p>&mdash;&mdash;&ndash;> Installing Go 1.1.2&hellip; done</p>

<pre><code>   Installing Virtualenv... done
   Installing Mercurial... done
   Installing Bazaar... done
</code></pre>

<p>&mdash;&mdash;&ndash;> Running: go get -tags heroku ./&hellip;
&mdash;&mdash;&ndash;> Discovering process types</p>

<pre><code>   Procfile declares types -&gt; web
</code></pre>

<p>&mdash;&mdash;&ndash;> Releasing dockerui &hellip;
&mdash;&mdash;&ndash;> Deploying dockerui &hellip;
=====> Application deployed:</p>

<pre><code>   http://dockerui.deploy.127.0.0.1.xip.io
</code></pre>

<p>To dokku@raring64:dockerui
 * [new branch]      master &ndash;> master
Killed by signal 1.
% ssh dokku@raring64 config:set dockerui DOCKER_ENDPOINT=<a href="http://10.0.2.15:4243">http://10.0.2.15:4243</a>
&mdash;&mdash;&ndash;> Setting config vars and restarting dockerui
DOCKER_ENDPOINT: <a href="http://10.0.2.15:4243">http://10.0.2.15:4243</a>
&mdash;&mdash;&ndash;> Releasing dockerui &hellip;
&mdash;&mdash;&ndash;> Release complete!
&mdash;&mdash;&ndash;> Deploying dockerui &hellip;
&mdash;&mdash;&ndash;> Deploy complete!
Killed by signal 1.
```</p>

<p>最初は pull request の説明にあった <code>config:add</code> で試していて、
<code>ssh dokku@raring64 logs dockerui</code> で確認してみても
<code>http: proxy error: unsupported protocol scheme ""</code>
とログに出ているだけでうまく情報がとれていないと思ったら、
<code>config:set</code> が正しい、というのが原因でした。</p>

<h2>まとめ</h2>

<p>以前に試した時は <code>Shipyard</code>
が一番高機能で開発も活発に見えて良さそうに感じましたが、
今は <code>DockerUI</code> も機能が増えていて、
今後、どちらも主流になる可能性があるように感じました。</p>

<p><code>DockerUI</code> の方は認証がなかったり、
docker の設定に <code>-api-enable-cors</code> が必要と書いていたりするので、
セキュリティを気にするのなら、
<code>Shipyard</code> の方がお勧めできると思いました。</p>

<p><code>Dockland</code> は <code>docker images -viz</code> を使っているというアイデアは
良さそうに感じたので、ぜひ他の Web UI でも採用されると便利そうだと
思いました。</p>
]]></content>
  </entry>
  
</feed>
