<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2014-09-03T22:50:58+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[boot2dockerでdockerのvolumeの保存状況を調べてみた]]></title>
    <link href="http://blog.n-z.jp/blog/2014-08-14-boot2docker-volume.html"/>
    <updated>2014-08-14T20:36:13+09:00</updated>
    <id>http://blog.n-z.jp/blog/boot2docker-volume</id>
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/userguide/dockervolumes/" title="Managing data in containers - Docker Documentation">Managing data in containers - Docker Documentation</a>
に
「Volumes persist until no containers use them」
(ボリュームは使っているコンテナがなくなるまで存続する)
と書いてあり、実際のところどうなのかを boot2docker で確認してみました。</p>

<p>確認した範囲ではコンテナを消した後でも残っていました。
確認の仕方が悪いなど気づいた点があればコメントなり twitter で指摘などをよろしくお願いします。</p>

<!--more-->


<h2>確認バージョン</h2>

<ul>
<li>Mac OS X 10.9.4</li>
<li>VirtualBox 4.3.14</li>
<li>docker 1.1.2</li>
<li>boot2docker v1.1.2</li>
</ul>


<h2>クリーンな環境で起動する</h2>

<p>まず一度 boot2docker の環境を消してから、作成し直しました。</p>

<pre><code class="console">%  boot2docker delete
%  boot2docker init
2014/08/14 20:35:43 Creating VM boot2docker-vm...
2014/08/14 20:35:43 Apply interim patch to VM boot2docker-vm (https://www.virtualbox.org/ticket/12748)
2014/08/14 20:35:43 Setting NIC #1 to use NAT network...
2014/08/14 20:35:43 Port forwarding [ssh] tcp://127.0.0.1:2022 --&gt; :22
2014/08/14 20:35:43 Port forwarding [docker] tcp://127.0.0.1:2375 --&gt; :2375
2014/08/14 20:35:43 Setting NIC #2 to use host-only network "vboxnet0"...
2014/08/14 20:35:43 Setting VM storage...
2014/08/14 20:35:50 Done. Type `boot2docker up` to start the VM.
% export DOCKER_HOST=tcp://192.168.59.103:2375
% boot2docker up
2014/08/14 20:38:02 Waiting for VM to be started...
...........
2014/08/14 20:38:35 Started.
2014/08/14 20:38:35 Your DOCKER_HOST env variable is already set correctly.
</code></pre>

<h2>volume 作成</h2>

<p><a href="https://github.com/boot2docker/boot2docker#folder-sharing" title="Folder sharing">Folder sharing</a>
の方法で volume を使ったコンテナを作成しました。</p>

<pre><code class="console">% docker run -v /data --name my-data busybox true
Unable to find image 'busybox' locally
Pulling repository busybox
a9eb17255234: Download complete
511136ea3c5a: Download complete
42eed7f1bf2a: Download complete
120e218dd395: Download complete
</code></pre>

<h2>実体確認</h2>

<p><code>/</code> が入ると <code>docker inspect -f '{{ index .Volumes./data }}' my-data</code> のようには確認できないので、
<a href="https://github.com/docker/docker/issues/6966">https://github.com/docker/docker/issues/6966</a> を参考にしてボリュームの実体ディレクトリを確認しました。</p>

<p>一覧で見るだけなら <code>docker inspect -f '{{ .Volumes }}' my-data</code> で確認できます。</p>

<pre><code class="console">% docker inspect -f '{{ index .Volumes "/data" }}' my-data
/mnt/sda1/var/lib/docker/vfs/dir/7625e8091bafdaa0cf1342bc33f29b2708e59b1388505fdd860960b09adf1846
% docker inspect -f '{{ .Volumes }}' my-data
map[/data:/mnt/sda1/var/lib/docker/vfs/dir/7625e8091bafdaa0cf1342bc33f29b2708e59b1388505fdd860960b09adf1846]
</code></pre>

<h2>適当なファイル作成</h2>

<p>目的のボリュームを確認しやすくするために適当なファイルを作成しました。</p>

<pre><code class="console">% docker run -it --rm --volumes-from my-data ubuntu
Unable to find image 'ubuntu' locally
Pulling repository ubuntu
c4ff7513909d: Download complete
511136ea3c5a: Download complete
1c9383292a8f: Download complete
9942dd43ff21: Download complete
d92c3c92fa73: Download complete
0ea0d582fd90: Download complete
cc58e55aa5a5: Download complete
root@bf9a312400fa:/# echo foo &gt; /data/foo.txt
root@bf9a312400fa:/# exit
exit
</code></pre>

<h2>コンテナ削除</h2>

<p>連携しているコンテナを削除します。</p>

<pre><code class="console">% docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
ddd48c305f62        busybox:latest      true                6 minutes ago       Exited (0) 6 minutes ago                       my-data
%  docker ps -a -q | xargs docker rm
ddd48c305f62
</code></pre>

<h2>実体確認</h2>

<p><code>boot2docker ssh</code> で入って確認したところ、残っていました。</p>

<pre><code class="console">% boot2docker ssh
                        ##        .
                  ## ## ##       ==
               ## ## ## ##      ===
           /""""""""""""""""\___/ ===
      ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~
           \______ o          __/
             \    \        __/
              \____\______/
 _                 _   ____     _            _
| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __
| '_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ '__|
| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &lt;  __/ |
|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|
boot2docker: 1.1.2
             master : 740106c - Thu Jul 24 03:24:10 UTC 2014
docker@boot2docker:~$ ls -al /mnt/sda1/var/lib/docker/vfs/dir/7625e8091bafdaa0cf1342bc33f29b2708e59b
1388505fdd860960b09adf1846
ls: /mnt/sda1/var/lib/docker/vfs/dir/7625e8091bafdaa0cf1342bc33f29b2708e59b1388505fdd860960b09adf1846: Permission denied
docker@boot2docker:~$ sudo ls -al /mnt/sda1/var/lib/docker/vfs/dir/7625e8091bafdaa0cf1342bc33f29b270
8e59b1388505fdd860960b09adf1846
total 12
drwxr-xr-x    2 root     root          4096 Aug 14 11:52 .
drwx------    4 root     root          4096 Aug 14 11:49 ..
-rw-r--r--    1 root     root             4 Aug 14 11:52 foo.txt
docker@boot2docker:~$
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[boot2docker で VM のファイルをコンテナやホストと共有する]]></title>
    <link href="http://blog.n-z.jp/blog/2014-08-06-docker-volume.html"/>
    <updated>2014-08-06T23:17:27+09:00</updated>
    <id>http://blog.n-z.jp/blog/docker-volume</id>
    <content type="html"><![CDATA[<p>Mac OS X 上の <code>boot2docker</code> でホストとコンテナでファイルを共有する方法を試してみました。
さらに <code>boot2docker ssh</code> で入ったときにも見えるような設定でも試してみました。</p>

<!--more-->


<h2>参考</h2>

<ul>
<li><a href="http://qiita.com/numa08/items/e52bd18611ac159af1ac" title="boot2dockerでコンテナからホストのファイルを参照する - Qiita">boot2dockerでコンテナからホストのファイルを参照する - Qiita</a></li>
<li><a href="https://github.com/boot2docker/boot2docker#folder-sharing" title="Folder sharing">Folder sharing</a></li>
<li><a href="https://docs.docker.com/userguide/dockervolumes/" title="Managing data in containers - Docker Documentation">Managing data in containers - Docker Documentation</a></li>
</ul>


<h2>対象バージョン</h2>

<ul>
<li>Mac OS X 10.9.4</li>
<li>VirtualBox 4.3.14</li>
<li>docker 1.1.2</li>
<li>boot2docker 1.1.2</li>
</ul>


<h2>実行コマンド</h2>

<ul>
<li><code>docker run -v /mnt/sda1/data:/data --name my-data busybox true</code> で共有ボリューム用コンテナ作成</li>
<li><code>docker run --rm -v /usr/local/bin/docker:/docker -v /var/run/docker.sock:/docker.sock svendowideit/samba my-data</code> で samba 起動</li>
<li><code>docker run -it --rm --volumes-from my-data ubuntu /bin/bash</code> で確認</li>
</ul>


<h3>共有ボリューム用コンテナ作成</h3>

<p><a href="http://blog.n-z.jp/blog/2013-12-24-docker-rm.html" title="Dockerで不要になったコンテナやイメージを削除する">Dockerで不要になったコンテナやイメージを削除する</a>
のように <code>docker ps -a -q | xargs docker rm</code> などで停止しているコンテナを削除してしまうと
<code>my-data</code> という名前を付けたデータ保存用のコンテナも消えてしまうので、
<code>boot2docker</code> では永続化されているパーティションの <code>/mnt/sda1</code> に <code>data</code> をおくことにしました。</p>

<p>run の時点で <code>/mnt/sda1/data</code> は自動作成されるので、
あらかじめ作っておく必要はありません。</p>

<p>間違えてコンテナを削除してしまった場合は
<code>docker run -v /mnt/sda1/data:/data --name my-data busybox true</code>
で作成し直せばデータは残ったまま <code>my-data</code> コンテナを再作成できます。</p>

<p>このやり方は docker を動かすホストに依存してしまうので、
一般には標準のボリュームコンテナを作成する方法の方がおすすめのようです。</p>

<h3>共有ボリューム用コンテナ再作成 (標準の方法の場合)</h3>

<p><code>--volumes-from</code> で指定した共有は使っているコンテナがなくなってしまっても内容が残っていますが、
名前で指定して取り出す方法がなくなってしまうように見えます。</p>

<p><code>my-data</code> コンテナを削除してしまった場合、
<code>--volumes-from my-data</code> は使えなくなるので、
<code>docker run --volumes-from samba-server --name my-data busybox true</code>
のように残っているコンテナを <code>--volumes-from</code> で指定して再作成すれば、
また <code>docker run -it --rm --volumes-from my-data ubuntu /bin/bash</code> のように
<code>--volumes-from</code> に <code>my-data</code> を指定できるようになります。</p>

<h3>samba 起動</h3>

<p><code>docker run --rm -v /usr/local/bin/docker:/docker -v /var/run/docker.sock:/docker.sock svendowideit/samba my-data</code>
で samba を起動します。</p>

<p><code>docker.sock</code> も渡しているので、多重起動しないように既存の <code>samba-server</code> は止めてくれるようです。</p>

<p>起動時に以下のようにホスト側からの接続方法の説明が出ます。</p>

<pre><code>% docker run --rm -v /usr/local/bin/docker:/docker -v /var/run/docker.sock:/docker.sock svendowideit/samba my-data
stopping and removing existing server
starting samba server container sharing my-data:/data

# run 'docker logs samba-server' to view the samba logs

================================================

Your data volume (/data) should now be accessible at \\&lt;docker ip&gt;\ as 'guest' user (no password)

For example, on OSX, using a typical boot2docker vm:
    goto Go|Connect to Server in Finder
    enter 'cifs://192.168.59.103
    hit the 'Connect' button
    select the volumes you want to mount
    choose the 'Guest' radiobox and connect

Or on Linux:
    mount -t cifs //192.168.59.103/data /mnt/data -o username=guest

Or on Windows:
    Enter '\\192.168.59.103\data' into Explorer
    Log in as Guest - no password
</code></pre>

<h3>samba に接続</h3>

<p><code>boot2docker ip</code> で IP アドレスを確認して、
<code>192.168.59.103</code> なら、
<code>Finder</code> の <code>サーバへ接続</code> (メニューの <code>移動</code> の <code>サーバーへ接続...</code>) を開いて、
サーバアドレスとして <code>cifs://192.168.59.103/data</code> を入力して <code>接続</code> します。
<code>ユーザの種類</code> は <code>ゲスト</code> を選んで <code>接続</code> します。
すると <code>/Volumes/data</code> で見えるようになります。</p>

<p>Linux なら <code>mount -t cifs //192.168.59.103/data /mnt/data -o username=guest</code> のようにマウントするそうです。</p>

<p>Windows ならエクスプローラーで <code>\\192.168.59.103\data</code> にパスワードなしのゲスト接続すれば見えるそうです。</p>

<h3>別コンテナで確認</h3>

<p><code>docker run -it --rm --volumes-from my-data ubuntu /bin/bash</code> などで別コンテナを起動すると、
<code>/data</code> にマウントされているので、
<code>ls -l /data</code> で中身を確認したり、
<code>/data</code> の中にファイルを作成して他で見えることを確認しました。</p>

<h2>まとめ</h2>

<p><a href="https://github.com/boot2docker/boot2docker#folder-sharing">README に書いてある Folder sharing</a>
だと間違えて消してしまうことがあったので、ちょっと工夫した方法を紹介しました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[boot2docker のバージョンアップ]]></title>
    <link href="http://blog.n-z.jp/blog/2014-08-06-boot2docker-upgrade.html"/>
    <updated>2014-08-06T23:10:26+09:00</updated>
    <id>http://blog.n-z.jp/blog/boot2docker-upgrade</id>
    <content type="html"><![CDATA[<p>boot2docker の ISO の更新は専用コマンドで簡単にできるとわかったので、
わざと古いバージョンに戻したりして動作確認してみました。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Mac OS X 10.9.4</li>
<li>VirtualBox 4.3.14</li>
<li>docker 1.1.2</li>
<li>boot2docker 1.1.2</li>
</ul>


<h2>更新準備</h2>

<p><code>boot2docker delete</code> して消してから ISO を更新して
<code>boot2docker init</code> で作り直すという説明もありますが、
再起動しても残る部分は ISO とは別の仮想ディスクの <code>/dev/sda1</code> に保存されていて、
そのまま使い回せることがほとんどなので、
作り直さなくても更新できます。</p>

<p>大きくバージョンをあげるとか、クリーンな環境でやり直したいと言うときは消して作り直せば良いと思います。</p>

<p>参考: <a href="http://qiita.com/tukiyo3/items/07f1eb77b5ffd9031e30" title="boot2dockerのデータ永続化まとめ - Qiita">boot2dockerのデータ永続化まとめ - Qiita</a></p>

<h2>更新方法</h2>

<h3>VM を停止して更新</h3>

<p><code>boot2docker upgrade</code> で VM が起動していれば停止して更新して起動し直してくれます。</p>

<h3>ISO だけ更新</h3>

<p><code>boot2docker download</code> で ISO だけ無条件にダウンロードしてくれます。</p>

<h3>boot2docker help</h3>

<p>以上の説明は <code>boot2docker help</code> にちゃんと書いてある通りです。</p>

<pre><code>% boot2docker help
Usage: boot2docker [&lt;options&gt;] &lt;command&gt; [&lt;args&gt;]

boot2docker management utility.

Commands:
    init                    Create a new boot2docker VM.
    up|start|boot           Start VM from any states.
    ssh [ssh-command]       Login to VM via SSH.
    save|suspend            Suspend VM and save state to disk.
    down|stop|halt          Gracefully shutdown the VM.
    restart                 Gracefully reboot the VM.
    poweroff                Forcefully power off the VM (might corrupt disk image).
    reset                   Forcefully power cycle the VM (might corrupt disk image).
    delete|destroy          Delete boot2docker VM and its disk image.
    config|cfg              Show selected profile file settings.
    info                    Display detailed information of VM.
    ip                      Display the IP address of the VM's Host-only network.
    status                  Display current state of VM.
    download                Download boot2docker ISO image.
    upgrade                 Upgrade the boot2docker ISO image (if vm is running it will be stopped and started).
    version                 Display version information.

Options:
      --basevmdk="": Path to VMDK to use as base for persistent partition
      --dhcp=true: enable VirtualBox host-only network DHCP.
      --dhcpip=192.168.59.99: VirtualBox host-only network DHCP server address.
  -s, --disksize=20000: boot2docker disk image size (in MB).
      --dockerport=2375: host Docker port (forward to port 2375 in VM).
      --hostip=192.168.59.3: VirtualBox host-only network IP address.
      --iso="/Users/knishiyama/.boot2docker/boot2docker.iso": path to boot2docker ISO image.
      --lowerip=192.168.59.103: VirtualBox host-only network DHCP lower bound.
  -m, --memory=2048: virtual machine memory size (in MB).
      --netmask=ffffff00: VirtualBox host-only network mask.
      --serial=false: try serial console to get IP address (experimental)
      --serialfile="": path to the serial socket/pipe.
      --ssh="ssh": path to SSH client utility.
      --ssh-keygen="ssh-keygen": path to ssh-keygen utility.
      --sshkey="/Users/knishiyama/.ssh/id_boot2docker": path to SSH key to use.
      --sshport=2022: host SSH port (forward to port 22 in VM).
      --upperip=192.168.59.254: VirtualBox host-only network DHCP upper bound.
      --vbm="VBoxManage": path to VirtualBox management utility.
  -v, --verbose=false: display verbose command invocations.
      --vm="boot2docker-vm": virtual machine name.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyLiveを仮想環境で作成]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-13-build-rubylive-on-vm.html"/>
    <updated>2014-07-13T09:35:02+09:00</updated>
    <id>http://blog.n-z.jp/blog/build-rubylive-on-vm</id>
    <content type="html"><![CDATA[<p>最近流行りの仮想環境を使ってクリーンな wheezy 環境で RubyLive を作成できるようにしました。</p>

<p>VirtualBox + Vagrant は特殊な制限のない仮想環境なので Live イメージが作成できたのですが、
docker は後述の制限のために作成できませんでした。</p>

<!--more-->


<h2>RubyLive を Vagrant で作成</h2>

<p>Vagrant を使ってクリーンな wheezy 環境で RubyLive の ISO を作成できるようにしました。
こちらは問題なく作成できました。</p>

<h3>動作確認バージョン</h3>

<ul>
<li>VirtualBox 4.3.12</li>
<li>Vagrant 1.6.3</li>
</ul>


<h3>使い方</h3>

<ul>
<li>VirtualBox と Vagrant をインストールしておきます。</li>
<li><code>git clone https://github.com/znz/rubylive-builder</code> で取得します。</li>
<li><code>cd rubylive-builder</code> で中に入ります。</li>
<li><code>VM_MEMORY=512 vagrant up</code> のように適当なメモリ容量を指定して起動します。 (指定なしなら 1024)

<ul>
<li>他の項目も環境変数である程度変更できるようにしています。</li>
<li>初回起動時は box をダウンロードするので非常に時間がかかります。</li>
<li>provision で live-build などの必要なパッケージをインストールしています。</li>
</ul>
</li>
<li><code>vagrant ssh</code> でゲストにログインします。</li>
<li><code>/vagrant/rubylive.sh</code> を実行すると <code>/home/vagrant/rubylive</code> で RubyLive のイメージを作成します。

<ul>
<li>実行するたびにタイムスタンプの入ったファイル名の ISO ファイルが作成されます。</li>
<li>ネットワークの速度やマシンスペックに影響を受けると思いますが、試した環境では約1時間かかりました。</li>
</ul>
</li>
<li>作成できた <code>/home/vagrant/rubylive/*.iso</code> を <code>/vagrant</code> にコピーまたは移動して、ホスト OS 側に取り出します。</li>
<li>取り出した ISO ファイルを使用します。</li>
</ul>


<p>なぜか
    chroot: failed to run command <code>/usr/bin/env': No such file or directory
で失敗することがありましたが、再度</code>/vagrant/rubylive.sh` を実行すれば問題なく作成できました。</p>

<h3>片付け方</h3>

<ul>
<li><code>vagrant destroy</code> で VM を破棄します。</li>
<li><code>git clone</code> した作業ディレクトリを削除します。</li>
<li>wheezy の box が不要なら <code>vagrant box remove opscode_debian-7.4_chef-provisionerless</code> で削除します。</li>
<li>Vagrant や VirtualBox も不要ならアンインストールします。</li>
</ul>


<h2>RubyLive を Docker で作成 (失敗)</h2>

<p>docker 環境の中では <code>chroot /rubylive/chroot mount -t proc proc /proc</code> が <code>EPERM</code> で失敗するため、作成できませんでした。</p>

<h3>動作確認バージョン</h3>

<ul>
<li>docker 1.1.1</li>
</ul>


<h3>試し方</h3>

<ul>
<li>docker をインストールしておきます。</li>
<li><code>git clone https://github.com/znz/rubylive-builder</code> で取得します。</li>
<li><code>docker build rubylive-builder</code> で作成に挑戦します。

<ul>
<li>または <code>cd rubylive-builder</code> で中に入って <code>docker build .</code> です。</li>
</ul>
</li>
<li><code>docker ps -a</code> で最近の CREATED の IMAGE を確認します。

<ul>
<li>もしくは <code>docker images</code> で確認します。</li>
<li>最後の失敗した後の状態は残っていないようでした。</li>
</ul>
</li>
<li><code>docker run -i -t --rm 4b8bc4523794 /bin/bash</code> のように中に入ります。

<ul>
<li>4b8bc4523794 のところは確認した IMAGE の ID にしてください。</li>
</ul>
</li>
<li><code>cd rubylive</code> で rubylive ディレクトリに入って <code>rake</code> で作成に再挑戦します。</li>
<li><code>less /rubylive/chroot/debootstrap/debootstrap.log</code> でログを確認したり、
<code>chroot /rubylive/chroot mount -t proc proc /proc</code> や
<code>mount -t proc proc /rubylive/chroot/proc</code> を直接実行してみたりして
原因を確認します。</li>
</ul>


<h3>失敗部分のメッセージ</h3>

<pre><code>W: Failure trying to run: chroot /rubylive/chroot mount -t proc proc /proc
W: See /rubylive/chroot/debootstrap/debootstrap.log for details
P: Begin unmounting filesystems...
P: Saving caches...
/usr/bin/env: apt-get: No such file or directory
rake aborted!
Command failed with status (1): [sudo lb build...]
</code></pre>

<p><code>/rubylive/chroot/debootstrap/debootstrap.log</code> をみると <code>mount: permission denied</code> と出ていました。</p>

<h3>Dockerfile 直接指定 (失敗)</h3>

<p><code>docker build https://raw.githubusercontent.com/znz/rubylive-builder/master/Dockerfile</code>
のように直接 URL を指定する方法は
<code>sources.list</code> を国内ミラーに差し替える部分が失敗して使えませんでした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 14.04 で dokku を使う]]></title>
    <link href="http://blog.n-z.jp/blog/2014-04-18-ubuntu-1404-dokku.html"/>
    <updated>2014-04-18T23:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/ubuntu-1404-dokku</id>
    <content type="html"><![CDATA[<p>Ubuntu 14.04 がリリースされたので、
<a href="https://github.com/progrium/dokku">dokku</a>
を Ubuntu 14.04 で試してみました。</p>

<!--more-->


<h2>dokku の Vagrantfile を確認する</h2>

<p>まず dokku を clone して中の Vagrantfile をみて、
環境変数で設定できる項目があるのを確認しておきます。</p>

<pre><code class="console">% git clone https://github.com/progrium/dokku
% cd dokku
% vi Vagrantfile
</code></pre>

<h2>Vagantfile を変更する</h2>

<p>デフォルトの apt-line のままだとダウンロードが遅いので、
<a href="http://mirrors.ubuntu.com/mirrors.txt">http://mirrors.ubuntu.com/mirrors.txt</a>
からミラーサーバーを選んで (今回は jaist を選択)、
shell provision のところで書き換えておきます。
(関係ないところにマッチして問題が起きる可能性はほぼないので、置換元の URL の <code>.</code> はエスケープしていません。)</p>

<pre><code class="diff">diff --git a/Vagrantfile b/Vagrantfile
index a310f6b..7c1a133 100644
--- a/Vagrantfile
+++ b/Vagrantfile
@@ -29,5 +29,10 @@ Vagrant::configure("2") do |config|
     vb.customize ["modifyvm", :id, "--memory", BOX_MEMORY]
   end

-  config.vm.provision :shell, :inline =&gt; "apt-get -y install git &amp;&amp; cd /root/dokku &amp;&amp; #{make_cmd}"
+  config.vm.provision :shell, :inline =&gt; &lt;&lt;-SHELL
+    sed -i~ -e 's;http://archive.ubuntu.com/ubuntu;http://ftp.jaist.ac.jp/pub/Linux/ubuntu;' /etc/apt/sources.list &amp;&amp;
+    apt-get update &amp;&amp;
+    apt-get -y install git &amp;&amp;
+    cd /root/dokku &amp;&amp; #{make_cmd}
+  SHELL
 end
</code></pre>

<h2>初回起動</h2>

<p><code>BOX_NAME</code>, <code>BOX_URI</code> に trusty を指定して、
<code>BOX_MEMORY</code> も 512 から 2048 に増やした値を指定して起動します。</p>

<p><code>node-js-sample</code> だと 512 メガでも問題ないのですが、
Rails アプリを動かそうとするとメモリ不足で <code>bundle install</code> の途中で失敗して
deploy できなかったので増やしています。</p>

<pre><code class="console">% BOX_NAME=trusty-amd64-20140418 BOX_URI=https://cloud-images.ubuntu.com/vagrant/trusty/20140418/trusty-server-cloudimg-amd64-vagrant-disk1.box BOX_MEMORY=2048 vagrant up
</code></pre>

<p>box のダウンロードとインストール、
VM の作成などには時間がかかるので、
他のことをしながらゆっくり待ちます。</p>

<h2>二度目以降の起動</h2>

<p>VM の作成ができている状態なら、
box の設定は参照されないので省略できます。
<code>vagrant destroy</code> した後に <code>vagrant up</code> し直したときは参照されるので、
毎回設定していてもかまいません。</p>

<p><code>BOX_MEMORY</code> は毎回設定されるので、指定を忘れると 512 に戻ってしまいます。</p>

<pre><code class="console">% BOX_MEMORY=2048 vagrant up
</code></pre>

<h2>dokku の初期設定</h2>

<p>ssh の鍵を追加します。</p>

<pre><code class="console">% vagrant ssh
vagrant@dokku:~$ egrep '^ssh' ~/.ssh/authorized_keys | sudo sshcommand acl-add dokku vagrant
dd:3b:b8:2e:85:04:06:e9:ab:ff:a8:0a:c0:04:6e:d6
vagrant@dokku:~$ cat ~/.ssh/authorized_keys
# CLOUD_IMG: This file was created/modified by the Cloud Image build process
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6NF8iallvQVp22WDkTkyrtvp9eWW6A8YVr+kz4TjGYe7gHzIw+niNltGEFHzD8+v1I2YJ6oXevct1YeS0o9HZyN1Q9qgCgzUFtdOKLv6IedplqoPkcmF0aYet2PkEDo3MlTBckFXPITAMzF8dJSIFo9D8HfdOV0IAdx4O7PtixWKn5y2hMNG0zQPyUecp4pzC6kivAIhyfHilFR61RGL+GPXQ2MWZWFYbAGjyiYJnAmCP3NOTd0jMZEnDkbUvxhMmBYSdETk1rRgm+R4LOzFUGaHqHDLKLX+FIPKcF96hrucXzcWyLbIbEgE98OHlnVYCzRdK8jlqm8tehUc9c9WhQ== vagrant insecure public key
vagrant@dokku:~$ cat /home/dokku/.ssh/authorized_keys
command="FINGERPRINT=dd:3b:b8:2e:85:04:06:e9:ab:ff:a8:0a:c0:04:6e:d6 NAME=vagrant `cat /home/dokku/.sshcommand` $SSH_ORIGINAL_COMMAND",no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6NF8iallvQVp22WDkTkyrtvp9eWW6A8YVr+kz4TjGYe7gHzIw+niNltGEFHzD8+v1I2YJ6oXevct1YeS0o9HZyN1Q9qgCgzUFtdOKLv6IedplqoPkcmF0aYet2PkEDo3MlTBckFXPITAMzF8dJSIFo9D8HfdOV0IAdx4O7PtixWKn5y2hMNG0zQPyUecp4pzC6kivAIhyfHilFR61RGL+GPXQ2MWZWFYbAGjyiYJnAmCP3NOTd0jMZEnDkbUvxhMmBYSdETk1rRgm+R4LOzFUGaHqHDLKLX+FIPKcF96hrucXzcWyLbIbEgE98OHlnVYCzRdK8jlqm8tehUc9c9WhQ== vagrant insecure public key
</code></pre>

<h2>dokku の鍵追加失敗例</h2>

<p><code>cat ~/.ssh/authorized_keys | sudo sshcommand acl-add dokku vagrant</code>
で追加してしまうと以下のように変になってしまいます。</p>

<pre><code class="text">vagrant@dokku:~$ cat /home/dokku/.ssh/authorized_keys
command="FINGERPRINT=is NAME=vagrant `cat /home/dokku/.sshcommand` $SSH_ORIGINAL_COMMAND",no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding # CLOUD_IMG: This file was created/modified by the Cloud Image build process
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6NF8iallvQVp22WDkTkyrtvp9eWW6A8YVr+kz4TjGYe7gHzIw+niNltGEFHzD8+v1I2YJ6oXevct1YeS0o9HZyN1Q9qgCgzUFtdOKLv6IedplqoPkcmF0aYet2PkEDo3MlTBckFXPITAMzF8dJSIFo9D8HfdOV0IAdx4O7PtixWKn5y2hMNG0zQPyUecp4pzC6kivAIhyfHilFR61RGL+GPXQ2MWZWFYbAGjyiYJnAmCP3NOTd0jMZEnDkbUvxhMmBYSdETk1rRgm+R4LOzFUGaHqHDLKLX+FIPKcF96hrucXzcWyLbIbEgE98OHlnVYCzRdK8jlqm8tehUc9c9WhQ== vagrant insecure public key
</code></pre>

<pre><code class="bash">    KEY=$(cat)
    FINGERPRINT=$(ssh-keygen -lf /dev/stdin &lt;&lt;&lt; $(echo $KEY) | awk '{print $2}')
    KEY_PREFIX="command=\"FINGERPRINT=$FINGERPRINT NAME=$NAME \`cat $USERHOME/.sshcommand\` \$SSH_ORIGINAL_COMMAND\",no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding"
    echo "$KEY_PREFIX $KEY" &gt;&gt; "$USERHOME/.ssh/authorized_keys"
    echo $FINGERPRINT
</code></pre>

<p>の部分を以下のように <code>while read</code> ループに変えた方が良いのかもしれません。</p>

<pre><code class="bash">    while read KEY; do
      FINGERPRINT=$(ssh-keygen -lf /dev/stdin &lt;&lt;&lt; $(echo $KEY) | awk '{print $2}')
      KEY_PREFIX="command=\"FINGERPRINT=$FINGERPRINT NAME=$NAME \`cat $USERHOME/.sshcommand\` \$SSH_ORIGINAL_COMMAND\",no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding"
      echo "$KEY_PREFIX $KEY" &gt;&gt; "$USERHOME/.ssh/authorized_keys"
      echo $FINGERPRINT
    done
</code></pre>

<h2>node-js-sample の deploy</h2>

<p><code>node-js-sample</code> を <code>deploy</code> して動作確認します。
以下の例では <code>ssh dokku</code> で VM に接続できるように <code>~/.ssh/config</code> に設定済みです。</p>

<pre><code class="console">% git clone https://github.com/heroku/node-js-sample
Cloning into 'node-js-sample'...
remote: Reusing existing pack: 319, done.
remote: Total 319 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (319/319), 201.92 KiB | 210.00 KiB/s, done.
Resolving deltas: 100% (17/17), done.
Checking connectivity... done.
% cd node-js-sample
% git remote add dokku dokku:node-js-app
%  git push --set-upstream dokku master
Counting objects: 319, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (274/274), done.
Writing objects: 100% (319/319), 201.92 KiB | 0 bytes/s, done.
Total 319 (delta 17), reused 319 (delta 17)
-----&gt; Cleaning up ...
remote: Cloning into '/tmp/tmp.ChNvZEb5S9'...
-----&gt; Building node-js-app ...
remote: warning: You appear to have cloned an empty repository.
remote: done.
remote: HEAD is now at 2e52ce7... Update documentation links
       Node.js app detected
-----&gt; Requested node range:  0.10.x
-----&gt; Resolved node version: 0.10.26
-----&gt; Downloading and installing node
(省略)
-----&gt; Discovering process types
       Procfile declares types -&gt; web
-----&gt; Releasing node-js-app ...
-----&gt; Deploying node-js-app ...
=====&gt; Application deployed:
       http://node-js-app.dokku.me

To dokku:node-js-app
 * [new branch]      master -&gt; master
Branch master set up to track remote branch master from dokku.
</code></pre>

<p>Vagrantfile で guest の 80 番ポートを host の 8080 番ポートで見えるように設定されているので
<code>http://node-js-app.dokku.me:8080/</code>
で開くと <code>Hello World!</code> と表示されます。</p>
]]></content>
  </entry>
  
</feed>
