<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2013-12-13T18:54:25+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[dockerのカスタムベースイメージを作成する]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-13-docker-custom-base-image.html"/>
    <updated>2013-12-13T18:49:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/docker-custom-base-image</id>
    <content type="html"><![CDATA[<p>例などにある ubuntu の base image は
apt-line が archive.ubuntu.com になっていて、
apt-get install などが遅いです。</p>

<p>日本で使うのなら日本のミラーを使った方が良いので、
そういう base image を作ります。</p>

<p>base image はあまりカスタマイズせずに、
派生するイメージにDockerfile などを使って
カスタマイズをした方が望ましいのですが、
ほぼ必須のものを毎回インストールするのは無駄なので、
ついでに日本語 locale を入れるというカスタマイズもしておきます。</p>

<!--more-->


<h2>docker 向けのポイント</h2>

<p>最初に docker 向けのポイントをまとめておきます。</p>

<ul>
<li>最小限にするなら <code>--variant=minbase</code></li>
<li><code>--include=iproute</code> などで <code>iproute</code> パッケージを入れておかないとネットワークにつながらない</li>
<li><code>policy-rc.d</code> とか <code>initctl</code> を対処しておかないとパッケージのインストール時に変なことになるかも</li>
<li><code>dpkg</code> に <code>force-unsafe-io</code> を設定すると <code>apt</code> を高速化できる</li>
<li><a href="https://github.com/dotcloud/docker/blob/master/contrib/mkimage-debootstrap.sh">mkimage-debootstrap.sh</a> をそのまま使う場合も日本のミラーを指定する方が良い</li>
</ul>


<h2>base image の作り方</h2>

<p>公式ドキュメントの
<a href="http://docs.docker.io/en/latest/use/baseimages/">Base Image Creation</a>
を参考にして、基本は
<a href="https://github.com/dotcloud/docker/blob/master/contrib/mkimage-debootstrap.sh">mkimage-debootstrap.sh</a>
の手順を使います。</p>

<p>カスタマイズのため、手順を追いかけるだけで直接は使いません。</p>

<h2>debootstrap の実行</h2>

<p>最初は以下のように <code>/tmp/wheezy64</code> などの適当な場所に
<code>debootstrap</code> で <code>chroot</code> 環境を作成します。
proxy 環境なら <code>sudo http_proxy=$http_proxy debootstrap ...</code>
のように指定すれば良いようです。</p>

<p>Debian での例:
<code>
 sudo debootstrap --verbose --variant=minbase --include=iproute --arch=amd64 wheezy /tmp/wheezy64 http://cdn.debian.or.jp/debian
</code></p>

<p>Ubuntu での例:
<code>
 sudo debootstrap --verbose --variant=minbase --arch=amd64 precise /tmp/precise64 http://ftp.jaist.ac.jp/pub/Linux/ubuntu/
</code></p>

<h3>variant</h3>

<p><code>variant</code> で <code>minbase</code> を指定するとインストールされるパッケージが減って、
本当に最小限の環境になります。
具体的には <code>Essential: yes</code> のパッケージ
( <code>aptitude search '~E'</code> または <code>aptitude search '?essential'</code> で一覧)
と <code>apt</code> がインストールされます。</p>

<p><code>buildd</code> という <code>variant</code> もあって <code>minbase</code> に加えて
<code>build-essential</code> が追加でインストールされるようなので、
CI 環境用などの base image なら <code>--variant=buildd</code> の方が
良いかもしれません。</p>

<p>デフォルトだと <code>Priority</code> が <code>imporant</code> のパッケージ
( <code>aptitude search '~pimportant</code> または <code>aptitude search '?priority(important)' で一覧)
がインストールされるようです。
インストールされるパッケージの差分は
</code>aptitude search &lsquo;~pimportant!~E`
で調べられます。</p>

<h3>include</h3>

<p>元の <code>mkimage-debootstrap.sh</code> では <code>iproute,iputils-ping</code> と指定してますが、
<code>iputils-ping</code> は必須ではないのでここでは省略しています。</p>

<p><code>iproute</code> は docker 環境では必須です。
このパッケージに含まれる <code>ip</code> コマンドが入っていないとネットワークにつながりません。</p>

<p><code>iproute</code> パッケージは <code>Priority</code> が <code>optional</code> なので
普通に <code>debootstrap</code> を実行しても入らないので、
注意が必要です。</p>

<h3>その他の引数</h3>

<p>arch の指定とか suite の指定とか生成先ディレクトリの指定とか、
ミラーの指定とかは見てわかる通りです。</p>

<h2>docker 向けのカスタマイズ</h2>

<p>次に生成されたディレクトリの中で
<code>mkimage-debootstrap.sh</code>
にデフォルト (<code>-d</code> オプションが指定されなかったとき) の処理をしていきます。</p>

<h3>policy-rc.d</h3>

<p>ファイルの作成方法は何でも良いのですが、
exit status で 101 を返す <code>usr/sbin/policy-rc.d</code> を作成して、
パッケージのインストールやアップデートなどで init スクリプトが
実行されないようにします。</p>

<p>ちなみに
<code>$'...'</code> は bash に <code>\n</code> を解釈させるための書き方なので、
<code>'...'</code> や <code>"..."</code> の間違いではありません。</p>

<p><code>
 echo $'#!/bin/sh\nexit 101' | sudo tee usr/sbin/policy-rc.d &gt; /dev/null
 sudo chmod +x usr/sbin/policy-rc.d
</code></p>

<p><code>policy-rc.d</code> については <code>invoke-rc.d</code> の man を参照してください。</p>

<h3>sbin/initctl</h3>

<p>initctl を実行してしまう upstart スクリプトがあるらしく、
その対処もします。</p>

<p>policy-rc.d は存在しなかったので、作成するだけでしたが、
<code>sbin/initctl</code> はパッケージ管理のファイルとして存在するので
<code>dpkg-divert</code> でパッケージの更新などで上書きされないようにしています。</p>

<p><code>
 sudo chroot . dpkg-divert --local --rename --add /sbin/initctl
 sudo ln -sf /bin/true sbin/initctl
</code></p>

<h3>パッケージのキャッシュの削除</h3>

<p><code>
 sudo chroot . apt-get clean
</code></p>

<p>を実行して不要な deb ファイルなどを削除して、
イメージのサイズを削減しています。</p>

<p>後で独自カスタマイズのところでパッケージをインストールして、
その後でまた実行するので、その場合はここでは実行しなくてもかまいません。</p>

<h3>apt の高速化など</h3>

<p><code>mkimage-debootstrap.sh</code> のコメントには
<code>dpkg</code> がパッケージの展開後に <code>sync()</code> を呼んでいるのが
原因で無駄に遅くなっているので、
強制的に <code>sync()</code> を呼ばなくさせると書いています。</p>

<p><code>
 echo 'force-unsafe-io' | sudo tee etc/dpkg/dpkg.cfg.d/02apt-speedup &gt; /dev/null
</code></p>

<p>それから、 deb ファイルを残さないようにして image ファイルが大きくならないようにしています。</p>

<p><code>
 echo 'DPkg::Post-Invoke {"/bin/rm -f /var/cache/apt/archives/*.deb || true";};' | sudo tee etc/apt/apt.conf.d/no-cache &gt; /dev/null
</code></p>

<h3>元に戻す方法</h3>

<p><code>mkimage-debootstrap.sh</code> のコメントに
元に戻す方法も書いてありました。
<code>dpkg-divert</code> 以外はファイルを消すだけです。</p>

<p><code>
 rm /usr/sbin/policy-rc.d
 rm /sbin/initctl; dpkg-divert --rename --remove /sbin/initctl
 rm /etc/dpkg/dpkg.cfg.d/02apt-speedup
 rm /etc/apt/apt.conf.d/no-cache
</code></p>

<h3>apt-line の変更</h3>

<p><code>etc/apt/sources.list</code> をみると</p>

<p><code>
 deb http://cdn.debian.or.jp/debian wheezy main
</code></p>

<p>だけになっているので、 <code>updates</code> と <code>security</code> を追加します。</p>

<p><code>mkimage-debootstrap.sh</code> もデフォルト
(<code>-d</code> も <code>-s</code> も指定されていないとき)
の動作では追加します。</p>

<p>この例では以下のようにしました。</p>

<p>debian での例:
<code>
 deb http://cdn.debian.or.jp/debian wheezy main
 deb http://cdn.debian.or.jp/debian wheezy-updates main
 deb http://security.debian.org/ wheezy/updates main
</code></p>

<p>ubuntu での例:
<code>
 deb http://ftp.jaist.ac.jp/pub/Linux/ubuntu precise main universe
 deb http://ftp.jaist.ac.jp/pub/Linux/ubuntu precise-updates main universe
 deb http://ftp.jaist.ac.jp/pub/Linux/ubuntu precise-security main universe
</code></p>

<p>main 以外を追加したい場合はここで追加しておくと良さそうです。
<code>mkimage-debootstrap.sh</code> でも ubuntu の場合は <code>universe</code> が追加されていました。</p>

<h2>独自カスタマイズ</h2>

<p>ここから独自カスタマイズになります。</p>

<h3>アップデート実行</h3>

<p>base image にセキュリティアップデートも入れておきたいなら、
更新しておきます。</p>

<p><code>
 sudo chroot . apt-get update
 sudo chroot . apt-get dist-upgrade
</code></p>

<h3>日本語 locale 追加</h3>

<p>debian の場合は
別環境で <code>debconf-get-selections</code> で調べておいた設定を使って、
<code>debconf-set-selections</code> で設定を入れておいて
<code>DEBIAN_FRONTEND=noninteractive</code> でインストールします。</p>

<p><code>
 echo locales locales/locales_to_be_generated multiselect ja_JP.EUC-JP EUC-JP, ja_JP.UTF-8 UTF-8 | sudo chroot . debconf-set-selections
 echo locales locales/default_environment_locale select ja_JP.UTF-8 | sudo chroot . debconf-set-selections
 sudo chroot . env DEBIAN_FRONTEND=noninteractive apt-get install locales
</code></p>

<p>ubuntu の場合は
<code>language-pack-ja</code> パッケージを入れても良いのですが、
不要なパッケージを入れるのが嫌なら <code>locale-gen</code> コマンドで
生成しても良いです。</p>

<p><code>
 sudo chroot . locale-gen ja_JP.UTF-8
 sudo chroot . locale-gen ja_JP.EUC-JP
</code></p>

<h3>パッケージのキャッシュの削除</h3>

<p>カスタマイズが終わったら clean を実行しておきます。
<code>etc/apt/apt.conf.d/no-cache</code> を作成していれば不要かもしれません。</p>

<p><code>
 sudo chroot . apt-get clean
</code></p>

<h2>イメージ作成と取り込み</h2>

<h3>tarball 作成</h3>

<p><code>mkimage-debootstrap.sh</code> は <code>-t</code> オプションが指定されたときに
docker のイメージではなく tarball を作成します。
直接取り込むならこの手順は不要です。</p>

<p>作成方法としては
最初に <code>touch</code> で一般ユーザー権限のファイルになるようにしておいて、
中身は <code>root</code> 権限で入れるようにしています。</p>

<p><code>
 touch /tmp/wheezy64.tar.xz
 sudo tar --numeric-owner -caf /tmp/wheezy64.tar.xz .
</code></p>

<h3>イメージ取り込み</h3>

<p><code>sudo docker</code> は root 権限が不要な設定にいていれば <code>docker</code> だけでかまいません。</p>

<p><code>mkimage-debootstrap.sh</code> は安定版や LTS に <code>latest</code> タグを設定したり、
<code>etc/debian_version</code> や <code>etc/lsb-release</code> をみて
タグを設定しているので、必要に応じて設定しておきます。</p>

<p>イメージ名としては「ユーザー名/レポジトリ名」という形式が推奨されていますが、
ここでは例として「ユーザー名」の部分は「local」にしておきます。
そして「レポジトリ名」としては日本語 locale を入れたということで
<code>-ja</code> を付けました。
日本のミラーを使っているということで <code>-ja-jp</code> にしても良かったのですが、
長かったので、 <code>-ja</code> だけにしました。</p>

<p>Debian での例:
<code>
 sudo tar --numeric-owner -c . | sudo docker import - local/debian-ja:wheezy
 sudo docker tag local/debian-ja:wheezy local/debian-ja:latest
 sudo docker tag local/debian-ja:wheezy local/debian-ja:7.2
</code></p>

<p>Ubuntu での例:
<code>
 sudo tar --numeric-owner -c . | sudo docker import - local/ubuntu-ja:precise
 sudo docker tag local/ubuntu-ja:precise local/ubuntu-ja:latest
 sudo docker tag local/ubuntu-ja:precise local/ubuntu-ja:12.04
</code></p>

<h2>まとめ</h2>

<p><a href="https://github.com/dotcloud/docker/blob/master/contrib/mkimage-debootstrap.sh">mkimage-debootstrap.sh</a>
で何をやっているのか、
同じことを手動でやるのはどうするのかということを説明しました。</p>

<p>最初のポイントにも書きましたが
<code>mkimage-debootstrap.sh</code>
を直接使うのも良いですが、
最低限ミラーを指定するのがおすすめです。</p>

<p>目的によっては <code>variant</code> を変更したり、
<code>include</code> でインストールするパッケージを増やしておくだけでも
便利になると思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBoxでdokkuを試した]]></title>
    <link href="http://blog.n-z.jp/blog/2013-11-15-dokku.html"/>
    <updated>2013-11-15T15:35:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/dokku</id>
    <content type="html"><![CDATA[<p>VirtualBox の中に Ubuntu 13.04 を入れて
<a href="https://github.com/progrium/dokku">dokku</a>
を試してみました。</p>

<p><a href="http://blog.coiney.com/2013/08/10/create-my-own-heroku/">dokku + VirtualBoxで自分のHerokuを作る</a>
を参考にしたのですが、
情報が古いのか、
README
に書いてあるのとコマンドが違うところ
(<code>gitreceive</code> が <code>sshcommand</code> になっているなど)
があるので、
README
の手順を基準にするのが良さそうです。</p>

<!--more-->


<h2>対象バージョン</h2>

<p>dokku の README に Ubuntu 13.10 と docker の組み合わせは
まだ問題があり、
13.04 が推奨と書いてあったので、
13.04 を使いました。</p>

<ul>
<li>ホストOS : OS X 10.9</li>
<li>VirtualBox 4.3.2</li>
<li>ゲストOS : Ubuntu 13.04 (amd64)</li>
<li>lxc-docker : 0.6.6</li>
<li>dokku : 今の master ブランチ (59ef6510bc)</li>
</ul>


<h2>Ubuntu 13.04 (amd64) のインストール</h2>

<p>OS のインストールは自分がこうしたというだけの話なので、
興味が無ければ dokku のインストールまで飛ばしてください。</p>

<p>いつものように
<a href="http://ftp.jaist.ac.jp/pub/Linux/ubuntu-releases/">Ubuntu Releases の jaist ミラー</a>
から
<code>ubuntu-13.04-server-amd64.iso</code>
をダウンロードしてインストールしました。</p>

<p>最初のユーザーは <code>adminuser</code> で、
<code>ssh</code> は後で入れるので、
パッケージのチェックは入れずにインストールしました。
ディスクは多めに 20GB に設定した以外はほぼデフォルトでインストールしました。</p>

<h3>etckeeper の設定</h3>

<ul>
<li><code>sudo aptitude install etckeeper git</code> で <code>git</code> と一緒にインストールして <code>bzr</code> をインストールしないようにします。
<code>bzr</code> がないので自動での <code>etckeeper init</code> は失敗するので、手動で実行します。</li>
<li><code>EDITOR=vi sudoedit /etc/etckeeper/etckeeper.conf</code> で <code>VCS="git"</code> と <code>GIT_COMMIT_OPTIONS="-v"</code> に変更します。</li>
<li><code>sudo etckeeper init</code> で初期化します。</li>
<li><code>sudo etckeeper commit "Initial commit"</code> で今の状態をコミットしておきます。</li>
<li><code>(cd /etc/ &amp;&amp; sudo git gc)</code> で <code>git gc</code> しておきます。</li>
</ul>


<h3>ufw の設定</h3>

<ul>
<li><code>/etc/default/ufw</code> の <code>DEFAULT_FORWARD_POLICY</code> を <code>DROP</code> から <code>ACCEPT</code> に変更しておきます。
<code>DROP</code> のままだと後で <code>docker</code> の中から DNS の解決ができないのが原因で <code>! [remote rejected] master -&gt; master (pre-receive hook declined)</code> になります。</li>
<li><code>sudo ufw enable</code> で有効にします。</li>
<li><code>sudo ufw allow 22/tcp</code> で <code>ssh</code> を許可します。</li>
<li><code>sudo ufw allow 80/tcp</code> で <code>http</code> を許可します。</li>
<li><code>sudo etckeeper commit "enable ufw"</code> などで変更を保存します。</li>
</ul>


<h3>ssh の設定</h3>

<ul>
<li><code>sudo aptitude install ssh</code> でインストールします。</li>
<li><code>/etc/hosts.deny</code> に <code>ALL: ALL</code> を追加してデフォルト拒否にします。</li>
<li><code>/etc/hosts.allow</code> に <code>sshd: 127.0.0.1 [::1]</code>
を追加してローカルホストからの接続を許可します。</li>
<li><code>/etc/hosts.allow</code> に <code>sshd: 10.0.0.0/8</code> も追加して
VirtualBox のポートフォワーディング経由の接続を許可します。</li>
<li><code>/etc/ssh/sshd_config</code> (<code>ssh_config</code> ではない) に
<code>AllowUsers adminuser</code> と <code>AllowUsers dokku</code> を追加して、
特定のユーザーにだけ <code>ssh</code> で接続できるようにします。</li>
</ul>


<p>ホストOS側では Vagrant も使っていたので、
ssh 用の鍵としては
<a href="https://github.com/mitchellh/vagrant/tree/master/keys">Vagrant の Insecure Keypair</a>
を使いました。</p>

<p>そして
ホストOS側の
<code>~/.ssh/config</code>
の設定としては、
グローバルの設定も含めると以下のようにしました。</p>

<p><code>
ExitOnForwardFailure yes
Ciphers aes256-ctr,aes192-ctr,aes128-ctr
HashKnownHosts no
NoHostAuthenticationForLocalhost yes
ServerAliveInterval 30
Host raring64
  Ciphers arcfour256,arcfour128
  HostName 127.0.0.1
  User adminuser
  Port 21304
  UserKnownHostsFile /dev/null
  StrictHostKeyChecking no
  PasswordAuthentication no
  IdentityFile ~/.vagrant.d/insecure_private_key
  IdentitiesOnly yes
</code></p>

<p><code>Ciphers</code> はデフォルトはセキュアなものを使い、
VM 用には速いものを使うようにしています。</p>

<h2>VirtualBox のポートフォワーディング設定</h2>

<p>設定のネットワークのポートフォワーディングのところで、</p>

<ul>
<li>名前:SSH, プロトコル:TCP, ホストIP:127.0.0.1, ホストポート:21304, ゲストIP:空欄, ゲストポート:22</li>
<li>名前:Web, プロトコル:TCP, ホストIP:127.0.0.1, ホストポート:1384, ゲストIP:空欄, ゲストポート:80</li>
</ul>


<p>のような感じで設定しました。</p>

<p>13.10 にしたら</p>

<ul>
<li>名前:SSH, プロトコル:TCP, ホストIP:127.0.0.1, ホストポート:21310, ゲストIP:空欄, ゲストポート:22</li>
<li>名前:Web, プロトコル:TCP, ホストIP:127.0.0.1, ホストポート:1380, ゲストIP:空欄, ゲストポート:80</li>
</ul>


<p>とすれば良いかなと思っています。</p>

<h2>dokku のインストール</h2>

<p><a href="https://github.com/progrium/dokku/blob/1d3ae29ba6bed8e1c98991c15db45724508fae30/README.md">README</a>
に書いてあるように
<code>wget -qO- https://raw.github.com/progrium/dokku/master/bootstrap.sh | sudo bash</code>
などでインストールできます。</p>

<p>実際には、
内容を確認したかったので、
<code>wget</code> でダウンロードした後、
<code>sudo bash &lt; bootstrap.sh</code>
で実行しました。</p>

<p>時間は5分程度かかると書いてありますが、
実際には
<code>docker</code>
用のイメージのダウンロードに時間がかかるので、
ネットワークの速度の影響が大きいようです。</p>

<h2>dokku の設定</h2>

<h3>VHOST の設定</h3>

<p>参考にしたサイトと同じように <code>xip.io</code> を使いました。
ポートフォワーディング経由にしているので、
<code>127.0.0.1</code>
にしています。</p>

<p><code>
echo deploy.127.0.0.1.xip.io | sudo tee /home/dokku/VHOST
</code></p>

<h3>ssh 公開鍵の追加</h3>

<p><code>ssh</code>
の接続は Vagrant と共通の鍵を使うことにしたので、
<code>/home/adminuser/.ssh/authorized_keys</code>
には <code>vagrant.pub</code> と同じ内容が入っています。</p>

<p>この鍵をそのまま <code>dokku</code> の方に登録しました。</p>

<p>ここもゲストOS側での作業になります。
README の手順では <code>ssh</code> 経由で <code>sudo</code> を実行しています。</p>

<p><code>
cat ~/.ssh/authorized_keys | sudo sshcommand acl-add dokku vagrant
</code></p>

<p>この手順で追加した公開鍵は</p>

<p><code>
sudo sshcommand acl-remove dokku vagrant
</code></p>

<p>で削除できます。</p>

<p>他の公開鍵を追加する時は <code>vagrant</code> の部分を変更しておかないと
<code>acl-remove</code> でまとめて削除されてしまいます。</p>

<h2>アプリケーションの deploy</h2>

<p>問題なく設定できていれば以下で deploy できます。</p>

<p>```</p>

<pre><code>git clone https://github.com/heroku/node-js-sample
cd node-js-sample
git remote add raring64 dokku@raring64:node-js-app
git push raring64 master
</code></pre>

<p>```</p>

<p>エラーになったときはログをみたり、
<code>dmesg</code>
を見たりして原因を調べてください。</p>

<p>正常に deploy できていれば
<code>http://node-js-app.deploy.127.0.0.1.xip.io:1384</code>
で <code>Hello World!</code> と表示されます。</p>

<h2>リモートからの dokku コマンド</h2>

<p>README には <code>$ dokku run node-js-app ls -alh</code> と書いてあり、
ホストOS側には <code>dokku</code> コマンドはないので、
どうすればいいのか悩んだのですが、</p>

<p><code>
 ssh dokku@raring64 run node-js-app ls -alh
</code></p>

<p>のように <code>git push</code> に使う <code>ssh</code> 経由で
<code>dokku</code> コマンドが実行されているのを使えました。</p>

<p>入力待ちになってしまうようで、
<code>control+D</code> で <code>EOF</code> を入力するなどしないと
ホストOS側のプロンプトに戻ってこないので、
想定された使い方ではなさそうな感じです。</p>

<p>他にも</p>

<p><code>
 ssh dokku@raring64 delete node-js-app
</code></p>

<p>でアプリケーションの削除もできました。
heroku と違って確認なしにいきなり削除されてしまうので注意が必要です。</p>

<p>どんなコマンドが実行できるのかは <code>dokku help</code> 相当の</p>

<p><code>
 ssh dokku@raring64 help
</code></p>

<p>で一覧が出てきます。</p>

<p>普段使いそうなのは <code>config</code> 関連と <code>logs</code> だと思いました。</p>
]]></content>
  </entry>
  
</feed>
