<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dokku | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/dokku/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2017-08-15T20:54:07+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[.gitlab-ci.ymlでDokkuとHerokuにdeployする]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-13-gitlab-ci-heroku.html"/>
    <updated>2017-07-13T21:50:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/gitlab-ci-heroku</id>
    <content type="html"><![CDATA[<p>GitLab と Dokku (と一部 Heroku) を使って CI/CD (Continuous Integration / Continuous Deployment) 環境を作ってみた話の続きです。
CI 部分のメインとなる <code>.gitlab-ci.yml</code> の設定の別パターンの話です。
review 環境は Dokku を使って、 staging と production に Heroku を使います。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Ubuntu 16.04.2 LTS</li>
<li>Omnibus GitLab 9.1.4-ce.0 (インストール時) から 9.3.5-ce.0 (記事執筆時)</li>
<li>gitlab-ci-multi-runner 9.2.0 (インストール時) から 9.3.0 (記事執筆時)</li>
<li>Dokku 0.9.4 (インストール時) から 0.10.2 (記事執筆時)</li>
</ul>


<h2>構成</h2>

<p>今回は、
git push すると CI が走り、 master 以外のブランチなら review 環境にデプロイされて、
master ブランチなら staging 環境にデプロイして、
tag が push されたら production 環境にデプロイされる、
という状態にします。</p>

<p>そして、 staging と production の deploy 先は Dokku ではなく Heroku を使います。</p>

<h2>.gitlab-ci.yml</h2>

<p>この後は <code>.gitlab-ci.yml</code> に設定する内容の説明になります。</p>

<h2>image 設定</h2>

<p>ここは前回と同じです。</p>

<p>ここでは <a href="https://hub.docker.com/r/_/ruby/">library/ruby - Docker Hub</a> の 2.3.3 を使いました。
<code>.ruby-version</code> や <code>Gemfile</code> と同じバージョンを指定します。</p>

<pre><code>image: ruby:2.3.3
</code></pre>

<p>2.3 だと 2.3.4 になるので、 2.3.3 まで指定しています。
2.3.4 はセキュリティアップデートではなかったので、まだ 2.3.3 のままですが、様子をみてあげる予定です。</p>

<h2>cache 設定</h2>

<p>ここも前回と同じです。</p>

<p><a href="https://docs.gitlab.com/ce/ci/yaml/README.html#cache-key">cache:key</a> から per-branch caching を選んで以下のように設定しました。</p>

<pre><code>cache:
  key: "$CI_COMMIT_REF_NAME"
  untracked: true
</code></pre>

<h2>環境変数設定</h2>

<p>ここも前回と同じです。</p>

<p><a href="https://hub.docker.com/r/_/postgres/">library/postgres - Docker Hub</a> で使う <code>POSTGRES_PASSWORD</code> などと、それに接続するための Rails 用の <code>DATABASE_URL</code>、
デプロイ用の省略表記のための <code>DOKKU</code> などを設定しています。</p>

<p><code>APP_NAME</code> と <code>DB_NAME</code> は <code>CI_ENVIRONMENT_SLUG</code> を使ってブランチごとに自動生成される名前を使っています。</p>

<pre><code>variables:
  # for test
  POSTGRES_DB: dbname
  POSTGRES_USER: dbuser
  POSTGRES_PASSWORD: dbpass
  DATABASE_URL: "postgres://dbuser:dbpass@postgres:5432/dbname"
  # for deploy
  DOKKU: ssh dokku@$DOKKU_HOST
  APP_NAME: $CI_ENVIRONMENT_SLUG
  DB_NAME: $CI_ENVIRONMENT_SLUG-database
</code></pre>

<h2>stages 設定</h2>

<p>ここも設定内容は前回と同じですが、 staging と production が別 Pipeline になって、それぞれで test が実行されるのが違います。</p>

<p>最初に説明したように、 test の後に review、 staging、 production となるように stages を設定します。</p>

<pre><code>stages:
  - test
  - review
  - staging
  - production
</code></pre>

<h2>before_script</h2>

<p>ここも前回と同じです。</p>

<p>テスト用の before_script を設定しています。(デプロイの方は個別に上書きしています。)</p>

<p>apt や bundler ではキャッシュ用のディレクトリである <code>/cache</code> を使うように指定しています。</p>

<p>開発環境と共通になっている都合上、 sqlite3 を入れています。
JavaScript ランタイムも必要なので、 nodejs も入れています。</p>

<pre><code>before_script:
  - 'apt-get update -qq &amp;&amp; apt-get -o dir::cache::archives="/cache/apt" install -y -qq sqlite3 libsqlite3-dev nodejs'
  - ruby -v
  - gem install bundler --no-ri --no-rdoc
  - bundle install --jobs $(nproc) --path=/cache/bundler
  - ln -nfs .test.env .env
</code></pre>

<h2>デプロイ用の before_script</h2>

<p>ここも前回と同じです。</p>

<p><a href="https://docs.gitlab.com/ce/ci/yaml/README.html#hidden-keys">Hidden keys</a>に書いてあるようにキーが <code>.</code> で始まるものは無視されるので、
YAML のアンカーを使って参照用に使えます。</p>

<p>ruby image には openssh-client は入っていたのですが、他の image に変えても動くように参考にした <a href="https://docs.gitlab.com/ce/ci/ssh_keys/README.html">Using SSH keys</a> に書いてあった通り、 openssh-client のインストール手順も入れています。</p>

<p><code>~/.ssh/config</code> で Hostname や Port や User などを指定したかったことがあったので、設定できるようにしました。</p>

<pre><code>.before_ssh: &amp;before_ssh
  # https://docs.gitlab.com/ce/ci/ssh_keys/README.html
  - 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get -o dir::cache::archives="/cache/apt" install -y openssh-client )'
  - eval $(ssh-agent -s)
  - ssh-add &lt;(echo "$SSH_PRIVATE_KEY")
  - mkdir -p ~/.ssh
  # Set `ssh-keyscan $DOKKU_HOST` to SSH_SERVER_HOSTKEYS
  - '[[ -f /.dockerenv ]] &amp;&amp; echo "$SSH_SERVER_HOSTKEYS" &gt; ~/.ssh/known_hosts'
  - '[[ -f /.dockerenv ]] &amp;&amp; echo "$SSH_CONFIG" &gt; ~/.ssh/config'
</code></pre>

<h2>GitLab の Web での環境変数設定</h2>

<p>ここも前回とほぼ同じですが、 production と staging の deploy 用の API 鍵を設定しているところが違います。</p>

<p>ここで <code>.gitlab-ci.yml</code> の話は中断して、 Secret variables の設定の話です。</p>

<p>GitLab で該当プロジェクトを開いて、 Settings の Pipelines から Secret variables で <code>SSH_PRIVATE_KEY</code> などを設定します。</p>

<p>ここでは、以下のように設定しました。</p>

<ul>
<li><code>DOKKU_HOST</code> : Dokku に ssh するときのホスト名 (<code>dokku.example.com</code> など)</li>
<li><code>DOKKU_DOMAIN</code> : Dokku の VHOST に設定したドメイン (<code>10.1.2.3.xip.io</code> など)</li>
<li><code>SSH_PRIVATE_KEY</code> : 秘密鍵 (<code>~/.ssh/id_gitlab</code> など) の内容</li>
<li><code>SSH_SERVER_HOSTKEYS</code> : <code>ssh-keyscan $DOKKU_HOST</code> の出力</li>
<li><code>SSH_CONFIG</code> : <code>~/.ssh/config</code> に設定したい内容</li>
<li><code>HEROKU_PRODUCTION_API_KEY</code> : <a href="https://dashboard.heroku.com/account">Manage Account</a> から production 用の Heroku アカウントの API key</li>
<li><code>HEROKU_STAGING_API_KEY</code> : <a href="https://dashboard.heroku.com/account">Manage Account</a> から staging 用の Heroku アカウントの API key</li>
</ul>


<p><code>SSH_PRIVATE_KEY</code> は Protected を Yes にすると review 環境への deploy に失敗するので、 No のままにする必要がありそうです。</p>

<p><code>HEROKU_PRODUCTION_API_KEY</code> や <code>HEROKU_STAGING_API_KEY</code> は Protected branch などの運用次第で Protected を Yes にできそうです。</p>

<h2>review 環境への deploy 用 script</h2>

<p>ここも前回とほぼ同じです。</p>

<p>まず Dokku でアプリとデータベースを作成して接続します。
2度目以降は同じアプリを更新するので、作成などのエラーは無視します。</p>

<p>環境変数は <code>TZ</code> と <code>RAILS_SERVE_STATIC_FILES</code> あたりがほぼ必須だと思いますが、他は staging 環境や review 環境用に独自に設定できるようにしています。
<code>RACK_DEV_MARK_ENV</code> は rack-dev-mark gem の設定です。</p>

<p><code>Procfile</code> で web だけではなく clockwork gem を使ったプロセスも動かしている関係で <code>letter_opener</code> 用のディレクトリをマウントしていますが、
<code>/usr/bin/find '/var/lib/dokku/data/storage/letter_opener' -mtime '+2' -delete</code> のような感じで古いファイルは自動削除する予定です。
(自動削除はまだしていません。)</p>

<p>デプロイ本体部分の <code>git push</code> は、単純に <code>master</code> だとうまくいかないことがあったので、 <code>HEAD:refs/heads/master</code> という指定にしています。
Heroku にデプロイするときも git でデプロイするなら同様になります。</p>

<p><code>db:seed</code> の実行は <code>ssh</code> に <code>-tt</code> をつけて強制的に tty を確保する必要がありました。</p>

<pre><code>.deploy_script: &amp;deploy_script
  - $DOKKU apps:create $APP_NAME || echo $?
  # require `sudo dokku plugin:install https://github.com/dokku/dokku-postgres`
  - $DOKKU postgres:create $DB_NAME || echo $?
  - $DOKKU postgres:link $DB_NAME $APP_NAME || echo $?
  - $DOKKU config:set --no-restart $APP_NAME
    TZ=Asia/Tokyo
    RAILS_SERVE_STATIC_FILES=1
    NO_FORCE_SSL=1
    RACK_DEV_MARK_ENV=review
  - git push dokku@$DOKKU_HOST:$APP_NAME HEAD:refs/heads/master
  - $DOKKU -tt run $APP_NAME bundle exec rake db:seed
</code></pre>

<p>前回と違って <code>RAILS_ENV</code> の変更をしていなかったり、 <code>letter_opener_web</code> や <code>seed_fu</code> は使っていないという違いがあります。</p>

<h2>test stage のジョブ</h2>

<p>ここも前回と同じです。</p>

<p>postgres を使って rake でテストを走らせます。</p>

<p>データベースの設定は <code>DATABASE_URL</code> で指定しているので、 <code>config/database.yml</code> は特に何もしていません。</p>

<pre><code>rake:
  stage: test
  services:
    - postgres:latest
  script:
    - bundle exec rake db:setup RAILS_ENV=test
    - bundle exec rake
</code></pre>

<p>rubocop なども使うなら同様に設定します。</p>

<h2>production 環境への deploy</h2>

<p>順番が前後しますが、最初に production 環境への deploy 設定です。</p>

<p>production 環境はちゃんと名前が決まっているので <code>APP_NAME</code> を上書きします。</p>

<p>Heroku への deploy には <a href="https://docs.gitlab.com/ce/ci/examples/test-and-deploy-ruby-application-to-heroku.html">Test and Deploy a ruby application</a> に書いてある dpl gem を使っています。
git push による deploy の方が好みなら git push を使っても良いと思います。</p>

<p>environment を設定することで GitLab の Web のプロジェクトの Pipelines の Environments からリンクが貼られます。</p>

<p>only で tags を指定することで tag が push されたら開始するようにしています。</p>

<p>only で master のみに制限しています。</p>

<pre><code>production:
  stage: production
  variables:
    APP_NAME: hello-app
  script:
  - gem install dpl
  - dpl --provider=heroku --app=$APP_NAME --api-key=$HEROKU_PRODUCTION_API_KEY
  environment:
    name: production
    url: https://$APP_NAME.herokuapp.com/
  only:
  - tags
</code></pre>

<h2>staging 環境への deploy</h2>

<p>production 環境と同様に staging 環境への deploy 設定をしています。</p>

<p><code>APP_NAME</code> や API key や URL などが違う以外は基本的に production と同じです。</p>

<pre><code>staging:
  stage: staging
  variables:
    APP_NAME: hello-staging-app
  script:
  - gem install dpl
  - dpl --provider=heroku --app=$APP_NAME --api-key=$HEROKU_STAGING_API_KEY
  environment:
    name: staging
    url: https://$APP_NAME.herokuapp.com/
  only:
  - master
</code></pre>

<h2>review 環境への deploy</h2>

<p>review 環境への deploy は前回と同じです。</p>

<p>deploy 本体の script は事前に定義した <code>deploy_script</code> を使います。
結局ここでしか使っていないので、直接ここに書いても良かったかもしれません。</p>

<p>environment は name に <code>review/</code> をつけることで複数の review 環境が同時に存在している時に折りたたまれるようになります。</p>

<p>review 環境は動的に作ったり消したりするので、 https ではなく http になっています。</p>

<p><code>on_stop</code> を指定することで環境の削除ジョブを指定できます。</p>

<p>only と except で master 以外のブランチの時に review 環境が作成されるようにしています。</p>

<pre><code>review:
  stage: review
  before_script: *before_ssh
  script: *deploy_script
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: http://$CI_ENVIRONMENT_SLUG.$DOKKU_DOMAIN
    on_stop: stop_review
  only:
    - branches
  except:
    - master
</code></pre>

<h2>review 環境の削除</h2>

<p>ここも前回と同じです。</p>

<p><code>action: stop</code> で環境を削除するジョブとして設定しています。</p>

<p><code>when: manual</code> で手動実行するように設定していますが、基本的にはマージリクエストがマージされた時に Remove source branch にチェックを入れて、自動で停止しています。</p>

<p><code>GIT_STRATEGY: none</code> で git 関連の操作はせずに速やかに停止処理のみするようにしています。</p>

<p>postgres は使用中だと停止できないので、先にアプリケーションを削除してからデータベースを削除しています。
自動実行なので <code>--force</code> で確認なしに削除するようにしています。</p>

<pre><code>stop_review:
  stage: review
  variables:
    GIT_STRATEGY: none
  before_script: *before_ssh
  script:
    - $DOKKU apps:destroy $CI_ENVIRONMENT_SLUG --force || echo $?
    - $DOKKU postgres:destroy $CI_ENVIRONMENT_SLUG-database --force || echo $?
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  when: manual
  only:
    - branches
  except:
    - master
</code></pre>

<h2>まとめ</h2>

<p>GitLab CI と Dokku と Heroku を組み合わせて CI/CD 環境を作る例を紹介しました。</p>

<p>今回紹介した様に、 Heroku に似ていてもある程度違いのある Dokku で自由に review 環境を作成して、 production に近い方が良い staging 環境は Heroku を使うというのが、自前の環境のリソースには余裕がある場合には良いのではないでしょうか。</p>

<p>GitLab + Dokku 関連の記事は<a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[.gitlab-ci.ymlでDokkuにdeployする]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-11-gitlab-ci-dokku.html"/>
    <updated>2017-07-11T22:15:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/gitlab-ci-dokku</id>
    <content type="html"><![CDATA[<p>GitLab と Dokku (と一部 Heroku) を使って CI/CD (Continuous Integration / Continuous Deployment) 環境を作ってみた話の続きです。
CI 部分のメインとなる <code>.gitlab-ci.yml</code> の設定の話です。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Ubuntu 16.04.2 LTS</li>
<li>Omnibus GitLab 9.1.4-ce.0 (インストール時) から 9.3.5-ce.0 (記事執筆時)</li>
<li>gitlab-ci-multi-runner 9.2.0 (インストール時) から 9.3.0 (記事執筆時)</li>
<li>Dokku 0.9.4 (インストール時) から 0.10.2 (記事執筆時)</li>
</ul>


<h2>構成</h2>

<p><a href="https://docs.gitlab.com/ce/ci/README.html">GitLab Continuous Integration (GitLab CI)</a>の冒頭の画像にあるように、
git push すると CI が走り、 master 以外のブランチなら review 環境にデプロイされて、
master ブランチなら staging 環境にデプロイして、その後、手動で production 環境にデプロイできる、
という状態にします。</p>

<h2>.gitlab-ci.yml</h2>

<p>この後は <code>.gitlab-ci.yml</code> に設定する内容の説明になります。</p>

<h2>image 設定</h2>

<p>ここでは <a href="https://hub.docker.com/r/_/ruby/">library/ruby - Docker Hub</a> の 2.3.3 を使いました。
<code>.ruby-version</code> や <code>Gemfile</code> と同じバージョンを指定します。</p>

<pre><code>image: ruby:2.3.3
</code></pre>

<p>2.3 だと 2.3.4 になるので、 2.3.3 まで指定しています。
2.3.4 はセキュリティアップデートではなかったので、まだ 2.3.3 のままですが、様子をみてあげる予定です。</p>

<h2>cache 設定</h2>

<p><a href="https://docs.gitlab.com/ce/ci/yaml/README.html#cache-key">cache:key</a> から per-branch caching を選んで以下のように設定しました。</p>

<pre><code>cache:
  key: "$CI_COMMIT_REF_NAME"
  untracked: true
</code></pre>

<h2>環境変数設定</h2>

<p><a href="https://hub.docker.com/r/_/postgres/">library/postgres - Docker Hub</a> で使う <code>POSTGRES_PASSWORD</code> などと、それに接続するための Rails 用の <code>DATABASE_URL</code>、
デプロイ用の省略表記のための <code>DOKKU</code> などを設定しています。</p>

<p><code>APP_NAME</code> と <code>DB_NAME</code> は <code>CI_ENVIRONMENT_SLUG</code> を使ってブランチごとに自動生成される名前を使っています。</p>

<pre><code>variables:
  # for test
  POSTGRES_DB: dbname
  POSTGRES_USER: dbuser
  POSTGRES_PASSWORD: dbpass
  DATABASE_URL: "postgres://dbuser:dbpass@postgres:5432/dbname"
  # for deploy
  DOKKU: ssh dokku@$DOKKU_HOST
  APP_NAME: $CI_ENVIRONMENT_SLUG
  DB_NAME: $CI_ENVIRONMENT_SLUG-database
</code></pre>

<h2>stages 設定</h2>

<p>最初に説明したように、 test の後に review、 staging の後に production となるように stages を設定します。</p>

<pre><code>stages:
  - test
  - review
  - staging
  - production
</code></pre>

<h2>before_script</h2>

<p>テスト用の before_script を設定しています。(デプロイの方は個別に上書きしています。)</p>

<p>apt や bundler ではキャッシュ用のディレクトリである <code>/cache</code> を使うように指定しています。</p>

<p>開発環境と共通になっている都合上、 sqlite3 を入れています。
JavaScript ランタイムも必要なので、 nodejs も入れています。</p>

<pre><code>before_script:
  - 'apt-get update -qq &amp;&amp; apt-get -o dir::cache::archives="/cache/apt" install -y -qq sqlite3 libsqlite3-dev nodejs'
  - ruby -v
  - gem install bundler --no-ri --no-rdoc
  - bundle install --jobs $(nproc) --path=/cache/bundler
  - ln -nfs .test.env .env
</code></pre>

<h2>デプロイ用の before_script</h2>

<p><a href="https://docs.gitlab.com/ce/ci/yaml/README.html#hidden-keys">Hidden keys</a>に書いてあるようにキーが <code>.</code> で始まるものは無視されるので、
YAML のアンカーを使って参照用に使えます。</p>

<p>ruby image には openssh-client は入っていたのですが、他の image に変えても動くように参考にした <a href="https://docs.gitlab.com/ce/ci/ssh_keys/README.html">Using SSH keys</a> に書いてあった通り、 openssh-client のインストール手順も入れています。</p>

<p><code>~/.ssh/config</code> で Hostname や Port や User などを指定したかったことがあったので、設定できるようにしました。</p>

<pre><code>.before_ssh: &amp;before_ssh
  # https://docs.gitlab.com/ce/ci/ssh_keys/README.html
  - 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get -o dir::cache::archives="/cache/apt" install -y openssh-client )'
  - eval $(ssh-agent -s)
  - ssh-add &lt;(echo "$SSH_PRIVATE_KEY")
  - mkdir -p ~/.ssh
  # Set `ssh-keyscan $DOKKU_HOST` to SSH_SERVER_HOSTKEYS
  - '[[ -f /.dockerenv ]] &amp;&amp; echo "$SSH_SERVER_HOSTKEYS" &gt; ~/.ssh/known_hosts'
  - '[[ -f /.dockerenv ]] &amp;&amp; echo "$SSH_CONFIG" &gt; ~/.ssh/config'
</code></pre>

<h2>GitLab の Web での環境変数設定</h2>

<p>ここで <code>.gitlab-ci.yml</code> の話は中断して、 Secret variables の設定の話です。</p>

<p>GitLab で該当プロジェクトを開いて、 Settings の Pipelines から Secret variables で <code>SSH_PRIVATE_KEY</code> などを設定します。</p>

<p>ここでは、以下のように設定しました。</p>

<ul>
<li><code>DOKKU_HOST</code> : Dokku に ssh するときのホスト名 (<code>dokku.example.com</code> など)</li>
<li><code>DOKKU_DOMAIN</code> : Dokku の VHOST に設定したドメイン (<code>10.1.2.3.xip.io</code> など)</li>
<li><code>SSH_PRIVATE_KEY</code> : 秘密鍵 (<code>~/.ssh/id_gitlab</code> など) の内容</li>
<li><code>SSH_SERVER_HOSTKEYS</code> : <code>ssh-keyscan $DOKKU_HOST</code> の出力</li>
<li><code>PRODUCTION_DOKKU_HOST</code> : production 用の Dokku に ssh するときのホスト名</li>
<li><code>SSH_CONFIG</code> : <code>~/.ssh/config</code> に設定したい内容</li>
</ul>


<p><code>SSH_PRIVATE_KEY</code> は Protected を Yes にしたいところですが、 review 環境への deploy に失敗するので、 No のままにする必要がありました。</p>

<h2>review 環境への deploy 用 script</h2>

<p>まず Dokku でアプリとデータベースを作成して接続します。
2度目以降は同じアプリを更新するので、作成などのエラーは無視します。</p>

<p>環境変数は <code>TZ</code> と <code>RAILS_SERVE_STATIC_FILES</code> あたりがほぼ必須だと思いますが、他は staging 環境や review 環境用に独自に設定できるようにしています。
<code>RACK_DEV_MARK_ENV</code> は rack-dev-mark gem の設定です。</p>

<p><code>Procfile</code> で web だけではなく clockwork gem を使ったプロセスも動かしている関係で <code>letter_opener</code> 用のディレクトリをマウントしていますが、
<code>/usr/bin/find '/var/lib/dokku/data/storage/letter_opener' -mtime '+2' -delete</code> のような感じで古いファイルは自動削除する予定です。
(自動削除はまだしていません。)</p>

<p>デプロイ本体部分の <code>git push</code> は、単純に <code>master</code> だとうまくいかないことがあったので、 <code>HEAD:refs/heads/master</code> という指定にしています。
Heroku にデプロイするときも git でデプロイするなら同様になります。</p>

<p><code>db:seed</code> の実行は <code>ssh</code> に <code>-tt</code> をつけて強制的に tty を確保する必要がありました。</p>

<pre><code>.deploy_script: &amp;deploy_script
  - $DOKKU apps:create $APP_NAME || echo $?
  # require `sudo dokku plugin:install https://github.com/dokku/dokku-postgres`
  - $DOKKU postgres:create $DB_NAME || echo $?
  - $DOKKU postgres:link $DB_NAME $APP_NAME || echo $?
  - $DOKKU config:set --no-restart $APP_NAME
    TZ=Asia/Tokyo
    RAILS_SERVE_STATIC_FILES=1
    NO_FORCE_SSL=1
    USE_LETTER_OPENER_WEB=1
    RACK_DEV_MARK_ENV=review
    RACK_ENV=review
    RAILS_ENV=review
  - $DOKKU storage:mount $APP_NAME /var/lib/dokku/data/storage/letter_opener/$APP_NAME:/app/tmp/letter_opener || echo $?
  - git push dokku@$DOKKU_HOST:$APP_NAME HEAD:refs/heads/master
  - $DOKKU -tt run $APP_NAME bundle exec rake db:seed db:seed_fu
</code></pre>

<h2>test stage のジョブ</h2>

<p>postgres を使って rake でテストを走らせます。</p>

<p>データベースの設定は <code>DATABASE_URL</code> で指定しているので、 <code>config/database.yml</code> は特に何もしていません。</p>

<pre><code>rake:
  stage: test
  services:
    - postgres:latest
  script:
    - bundle exec rake db:setup RAILS_ENV=test
    - bundle exec rake
</code></pre>

<p>rubocop なども使うなら同様に設定します。</p>

<h2>production 環境への deploy</h2>

<p>順番が前後しますが、最初に production 環境への deploy 設定です。</p>

<p>production 環境はちゃんと名前が決まっているので <code>APP_NAME</code> を上書きします。</p>

<p><code>before_script</code> はテスト環境用のものを <code>before_ssh</code> で上書きします。
(デプロイ用のジョブの方が多いので逆にテスト用のジョブで <code>before_script</code> を上書きする方がよかったかもしれません。)</p>

<p>production 環境は環境がすでに整っているはずなので、デプロイは <code>git push</code> による更新のみです。</p>

<p>environment を設定することで GitLab の Web のプロジェクトの Pipelines の Environments からリンクが貼られます。</p>

<p><code>when: manual</code> にすることで手動で開始するようにしています。</p>

<p>only で master のみに制限しています。</p>

<pre><code>production:
  stage: production
  variables:
    APP_NAME: hello-app
  before_script: *before_ssh
  script:
    - git push dokku@$PRODUCTION_DOKKU_HOST:$APP_NAME HEAD:refs/heads/master
  environment:
    name: production
    url: https://hello-app.example.jp/
  when: manual
  only:
    - master
</code></pre>

<h2>staging 環境への deploy</h2>

<p>production 環境と同様に staging 環境への deploy 設定をしています。</p>

<p>テストが通ったら自動実行されるのと <code>APP_NAME</code> や URL などが違う以外は基本的に production と同じです。</p>

<pre><code>staging:
  stage: staging
  variables:
    APP_NAME: hello-app-staging
  before_script: *before_ssh
  script:
    - git push dokku@$PRODUCTION_DOKKU_HOST:$APP_NAME HEAD:refs/heads/master
  environment:
    name: staging
    url: https://hello-app-staging.example.jp/
  only:
    - master
</code></pre>

<h2>review 環境への deploy</h2>

<p>review 環境への deploy も似たような感じです。</p>

<p>deploy 本体の script は事前に定義した <code>deploy_script</code> を使います。
結局ここでしか使っていないので、直接ここに書いても良かったかもしれません。</p>

<p>environment は name に <code>review/</code> をつけることで複数の review 環境が同時に存在している時に折りたたまれるようになります。</p>

<p>review 環境は動的に作ったり消したりするので、 https ではなく http になっています。</p>

<p><code>on_stop</code> を指定することで環境の削除ジョブを指定できます。</p>

<p>only と except で master 以外のブランチの時に review 環境が作成されるようにしています。</p>

<pre><code>review:
  stage: review
  before_script: *before_ssh
  script: *deploy_script
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: http://$CI_ENVIRONMENT_SLUG.$DOKKU_DOMAIN
    on_stop: stop_review
  only:
    - branches
  except:
    - master
</code></pre>

<h2>review 環境の削除</h2>

<p><code>action: stop</code> で環境を削除するジョブとして設定しています。</p>

<p><code>when: manual</code> で手動実行するように設定していますが、基本的にはマージリクエストがマージされた時に Remove source branch にチェックを入れて、自動で停止しています。</p>

<p><code>GIT_STRATEGY: none</code> で git 関連の操作はせずに速やかに停止処理のみするようにしています。</p>

<p>postgres は使用中だと停止できないので、先にアプリケーションを削除してからデータベースを削除しています。
自動実行なので <code>--force</code> で確認なしに削除するようにしています。</p>

<pre><code>stop_review:
  stage: review
  variables:
    GIT_STRATEGY: none
  before_script: *before_ssh
  script:
    - $DOKKU apps:destroy $CI_ENVIRONMENT_SLUG --force || echo $?
    - $DOKKU postgres:destroy $CI_ENVIRONMENT_SLUG-database --force || echo $?
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  when: manual
  only:
    - branches
  except:
    - master
</code></pre>

<h2>まとめ</h2>

<p>GitLab CI と Dokku を組み合わせて CI/CD 環境を作る例を紹介しました。</p>

<p>ちゃんと動く review 環境にするには seed の設定だったり、メール関係の設定だったり、色々とアプリケーション側でも対応が必要ですが、一度環境ができてしまえば変更の確認を他の人にもしてもらいやすくなるので、便利になるのではないでしょうか。</p>

<p>次は staging 環境と production 環境に Heroku を使う例を紹介します。</p>

<p>GitLab + Dokku 関連の記事は<a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitLabと連携するDokkuの初期設定]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-10-gitlab-dokku.html"/>
    <updated>2017-07-10T21:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/gitlab-dokku</id>
    <content type="html"><![CDATA[<p>GitLab と Dokku (と一部 Heroku) を使って CI/CD (Continuous Integration / Continuous Deployment) 環境を作ってみた話の続きです。
今回は Dokku の設定の話になります。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Ubuntu 16.04.2 LTS</li>
<li>Omnibus GitLab 9.1.4-ce.0 (インストール時) から 9.3.5-ce.0 (記事執筆時)</li>
<li>gitlab-ci-multi-runner 9.2.0 (インストール時) から 9.3.0 (記事執筆時)</li>
<li>Dokku 0.9.4 (インストール時) から 0.10.2 (記事執筆時)</li>
</ul>


<h2>Dokku とは?</h2>

<p><a href="http://dokku.viewdocs.io/dokku/">Dokku - The smallest PaaS implementation you&rsquo;ve ever seen</a>は bash で書かれた OSS の PaaS です。</p>

<p>Heroku のように git push でデプロイするというのが基本的な使い方になります。</p>

<p>環境変数の操作などのような heroku コマンドで操作に相当することは ssh 経由と Dokku ホスト上での dokku コマンドの両方でできることが多いです。
プラグインのインストールなど、一部の操作は Dokku ホスト上で直接実行する必要があります。</p>

<p>データベースなどはプラグインで対応しています。</p>

<p>Dokku の更新が止まっていた時にできた <a href="https://github.com/dokku-alt/dokku-alt">Dokku Alternative</a> という fork もありましたが、メンテナンスが止まっているので使うべきではありません。</p>

<p>最近はコアプラグインから少しずつ Go 言語への移行を進めているようです。</p>

<h2>インストール</h2>

<p><a href="http://dokku.viewdocs.io/dokku/">Dokku</a> に書いてあるように <code>bootstrap.sh</code> を使うと自動で <code>get.docker.com</code> からの docker のインストールも含めて、 apt から dokku をインストールしてくれます。</p>

<h2>初期設定</h2>

<p>debconf であらかじめ設定しておくか、<code>web_config</code> を使って設定します。</p>

<p>デフォルトのままなどで <code>web_config</code> が有効な場合、 Dokku をインストールしたホストをブラウザーで開くと初期設定画面が出てきます。</p>

<p>そこでデプロイや ssh 経由での操作に使う ssh の公開鍵の登録とホスト名の設定をします。
ホスト名はアプリケーションごとに個別のバーチャルホストを別途設定できるので、とりあえず xip.io や nip.io を使っておくのが手軽だと思います。</p>

<h2>プラグインのインストール</h2>

<p><a href="http://dokku.viewdocs.io/dokku/community/plugins/">プラグイン一覧</a>から Compatibility を確認して必要なプラグインをインストールします。</p>

<p>Heroku と似た感じで使いたいのなら <a href="https://github.com/dokku/dokku-postgres">dokku postgres</a> を入れておくと良いと思います。</p>

<p>Dokku ホストで</p>

<pre><code>sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git postgres
</code></pre>

<p>でインストールできます。</p>

<p><a href="https://github.com/dokku/dokku-maintenance">dokku-maintenance</a> のように Heroku だと標準で対応していることがプラグインになっていたり、
<a href="https://github.com/F4-Group/dokku-apt">dokku-apt</a> のように Heroku だと複数 buildpack で対応していたようなことがプラグインになっていたりすることもあります。</p>

<h2>ssh の公開鍵設定</h2>

<p>後で GitLab CI の secret variables に秘密鍵を設定するので、専用の鍵ペアを作成して、 <a href="http://dokku.viewdocs.io/dokku/deployment/user-management/">User Management</a> の方法で Dokku に公開鍵を登録しておきます。</p>

<pre><code>% ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/vagrant/.ssh/id_rsa): /home/vagrant/.ssh/id_gitlab
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/vagrant/.ssh/id_gitlab.
Your public key has been saved in /home/vagrant/.ssh/id_gitlab.pub.
The key fingerprint is:
(略)
% cat ~/.ssh/id_gitlab.pub | ssh dokku@dokku.example.jp ssh-keys:add gitlab
</code></pre>

<h2>動作確認</h2>

<p>データベースの必要な例を試すなら、<a href="http://dokku.viewdocs.io/dokku/deployment/application-deployment/">Deploy tutorial</a>を試してみると良いと思います。</p>

<p>データベースの不要な例を試すなら、<a href="https://devcenter.heroku.com/articles/rack">Deploying Rack-based Apps | Heroku Dev Center</a> の <code>heroku create</code> を <code>git remote add dokku dokku@dokku.example.test:hello</code> に変えて、 <code>git push heroku master</code> の代わりに <code>git push dokku master</code> で試してみたりすると良いと思います。</p>

<h2>まとめ</h2>

<p>Dokku のインストールから簡単な動作確認方法まで紹介しました。
次は <code>.gitlab-ci.yml</code> を作成して連携する話です。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React On Rails の react-webpack-rails-tutorial を Dokku で試してみた]]></title>
    <link href="http://blog.n-z.jp/blog/2016-10-02-react-webpack-rails-tutorial-on-dokku.html"/>
    <updated>2016-10-02T22:24:55+09:00</updated>
    <id>http://blog.n-z.jp/blog/react-webpack-rails-tutorial-on-dokku</id>
    <content type="html"><![CDATA[<p>react.js を rails と組み合わせて使うにはどうすればいいんだろうと思って調べてみると、<code>react-rails</code> gem の他に <code>react_on_rails</code> gem というもっとまとめていろんなことの面倒を見てくれるものがあったので、そのサンプルアプリである
<a href="https://github.com/shakacode/react-webpack-rails-tutorial" title="react-webpack-rails-tutorial">react-webpack-rails-tutorial</a>
を <a href="https://github.com/dokku/dokku/" title="Dokku">Dokku</a> にデプロイできるか試してみました。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>OS X El Capitan 10.11.6</li>
<li>VirtualBox 5.1.6</li>
<li>Vagrant 1.8.6</li>
<li>Dokku master (0.7.2 からちょっと変更が進んだもの)</li>
<li>react-webpack-rails-tutorial master</li>
<li>ruby 2.3.1</li>
<li>rails 5.0.0</li>
<li>node 6.7.0</li>
</ul>


<h2>環境構築</h2>

<p>まず <a href="https://github.com/dokku/dokku">https://github.com/dokku/dokku</a> を git clone したディレクトリで作業します。</p>

<p>vagrant の provision から何度も試すようなら、 apt で日本のミラーを使うように shell provisioning を追加しておきます。</p>

<pre><code class="diff">diff --git a/Vagrantfile b/Vagrantfile
index 4f3fc6c..bccceb9 100644
--- a/Vagrantfile
+++ b/Vagrantfile
@@ -47,6 +47,7 @@ Vagrant::configure("2") do |config|
       vb.customize ["modifyvm", :id, "--natdnsproxy1", "off"]
     end

+    vm.vm.provision :shell, :inline =&gt; "sed -i -e 's,//us\\.archive\\.ubuntu\\.com,//jp.archive.ubuntu.com,' /etc/apt/sources.list"
     vm.vm.provision :shell, :inline =&gt; "export DEBIAN_FRONTEND=noninteractive &amp;&amp; apt-get update &gt; /dev/null &amp;&amp; apt-get -qq -y install git &gt; /dev/null &amp;&amp; cd /root/dokku &amp;&amp; #{make_cmd}"
     vm.vm.provision :shell, :inline =&gt; "cd /root/dokku &amp;&amp; make dokku-installer"
     vm.vm.provision :shell do |s|
</code></pre>

<p><code>vagrant up</code> します。
gliderlabs/herokuish の docker イメージのダウンロードなどもあるので時間がかかります。</p>

<h2>Web UI での設定</h2>

<p><a href="http://dokku.me/">http://dokku.me/</a> を開いて初期設定します。
<code>Hostname</code> を <code>dokku.me</code> に変更して <code>Use virtualhost naming for apps</code> にチェックを入れて <code>Finish Setup</code> を押します。</p>

<p>意図した動作かどうかはわかりませんが、この作業をしなくても <code>app-name.dokku.me</code> は使えました。
(<code>not-found-app.dokku.me</code> で初期設定画面は出てくるまま)</p>

<h2>初期設定</h2>

<p><code>/vagrant/tmp/init.sh</code> に以下のファイルをおいて実行します。
<code>tmp</code> は <code>.gitignore</code> に入っていてローカルな作業ファイルをおくのに都合が良いです。</p>

<p>内容としては以下のようなことをしています。</p>

<ul>
<li><code>docker</code> コマンドを <code>sudo</code> なしで呼べるように <code>docker</code> グループに <code>vagrant</code> ユーザーを追加</li>
<li><code>/home/dokku</code> を調べたりするときなどに都合が良いように <code>dokku</code> グループに <code>vagrant</code> ユーザーを追加</li>
<li>ruby などのダウンロードでタイムアウトしないように <code>CURL_TIMEOUT</code> を増やす</li>
<li><code>dokku run</code> などで一時的に作成されるコンテナーをデフォルトで削除するように <code>DOKKU_RM_CONTAINER</code> を設定</li>
<li><code>~/.ssh/known_hosts</code> がハッシュ化されているとどの行がどのホストかわからなくなるので <code>HashKnownHosts no</code> で無効化</li>
<li>あとで git push のときに使う <code>10.0.0.2</code> のホスト鍵を <code>~/.ssh/known_hosts</code> に追加</li>
<li>ssh の鍵ペアを作成して <code>dokku ssh-keys:add</code> で登録</li>
<li>ruby のビルドに必要なパッケージなどをインストール</li>
<li>anyenv, rbenv, ndenv をインストール</li>
<li><code>~/.gemrc</code> を作成してデフォルトでドキュメントのインストールを無効化</li>
<li>ndenv で最新の node をインストール</li>
</ul>


<p>デプロイするだけなら anyenv などは不要ですが、あとで開発環境としても動かしたかったので入れています。</p>

<pre><code class="sh">#!/bin/bash
set -euo pipefail
set -x
cd /home/vagrant
sudo usermod -aG docker vagrant
sudo usermod -aG dokku vagrant
dokku config:set --global CURL_TIMEOUT=120
dokku config:set --global DOKKU_RM_CONTAINER=1
if [[ ! -e "$HOME/.ssh/config" ]]; then
  echo "HashKnownHosts no" &gt;"$HOME/.ssh/config"
fi
if [[ ! -e "$HOME/.ssh/known_hosts" ]]; then
  ssh-keyscan -t ecdsa-sha2-nistp256 10.0.0.2 | grep -v '#' &gt; "$HOME/.ssh/known_hosts"
fi
if [[ ! -e "$HOME/.ssh/id_rsa" ]]; then
  ssh-keygen -N '' -f "$HOME/.ssh/id_rsa"
  sudo dokku ssh-keys:add vagrant "$HOME/.ssh/id_rsa.pub"
fi

if [[ -z "$(dpkg -l | grep libsqlite3-dev)" ]]; then
  sudo sed -i~ -e 's/us\.archive/jp.archive/' /etc/apt/sources.list
  sudo apt-get update
  sudo apt-get -y install autoconf bison build-essential libssl-dev libyaml-dev libreadline6-dev zlib1g-dev libncurses5-dev libffi-dev libgdbm3 libgdbm-dev
  sudo apt-get -y install libpq-dev
  sudo apt-get -y install libsqlite3-dev
  sudo apt-get -y install jq
fi
if [[ ! -d ~/.anyenv ]]; then
  git clone https://github.com/riywo/anyenv.git ~/.anyenv
  echo 'export PATH="$HOME/.anyenv/bin:$PATH"' &gt;&gt; ~/.bashrc
  echo 'eval "$(anyenv init -)"' &gt;&gt; ~/.bashrc
fi
if [[ -z "$(command -v anyenv)" ]]; then
  export PATH="$HOME/.anyenv/bin:$PATH"
  set +x
  eval "$(anyenv init - --no-rehash)"
  set -x
fi
if [[ ! -d ~/.anyenv/envs/rbenv ]]; then
  anyenv install rbenv
fi
if [[ ! -f ~/.gemrc ]]; then
  cat &lt;&lt;EOF &gt;~/.gemrc
install: --no-rdoc --no-ri --format-executable
update: --no-rdoc --no-ri --format-executable
EOF
fi
if [[ ! -d "$HOME/.anyenv/envs/ndenv" ]]; then
  anyenv install ndenv
fi
node_version=$(ndenv install -l | grep '^ *v' | tail -n1 | xargs)
if ! ndenv versions | grep -q "$node_version"; then
  ndenv install "$node_version"
  ndenv global "$node_version"
fi
</code></pre>

<h2>react-webpack-rails-tutorial のデプロイ</h2>

<p>一度 <code>exit</code> で抜けて <code>vagrant ssh</code> で入りなおしてグループの変更や anyenv などのインストールを反映します。</p>

<p><code>/vagrant/tmp/react-webpack-rails-tutorial.sh</code> に以下のファイルをおいて実行します。</p>

<p>内容としては以下のようなことをしています。</p>

<ul>
<li><a href="https://github.com/shakacode/react-webpack-rails-tutorial">https://github.com/shakacode/react-webpack-rails-tutorial</a> の取得</li>
<li>react-webpack-rails-tutorial アプリの作成 (リンク作業に必要)</li>
<li>dokku-postgres が入っていなければ入れる</li>
<li>react-webpack-rails-tutorial-db を作ってリンク</li>
<li>dokku という remote を追加</li>
<li><a href="https://github.com/heroku/heroku-buildpack-multi">https://github.com/heroku/heroku-buildpack-multi</a> を使うため <code>.buildpacks</code> を作成</li>
<li><code>rake db:migrate</code> の自動実行のため <code>app.json</code> を作成</li>
<li>デプロイ</li>
</ul>


<pre><code class="sh">#!/bin/bash
set -euo pipefail
set -x
cd
if [[ ! -d react-webpack-rails-tutorial ]]; then
  git clone https://github.com/shakacode/react-webpack-rails-tutorial
fi
if [[ ! -d /home/dokku/react-webpack-rails-tutorial ]]; then
  dokku apps:create react-webpack-rails-tutorial
fi
if [[ ! -d /var/lib/dokku/plugins/available/postgres ]]; then
  sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git || :
  sudo docker pull gliderlabs/herokuish
fi
if [[ ! -f /home/dokku/react-webpack-rails-tutorial/DOCKER_OPTIONS_RUN ]]; then
  dokku postgres:create react-webpack-rails-tutorial-db || :
  dokku postgres:link react-webpack-rails-tutorial-db react-webpack-rails-tutorial
fi
cd react-webpack-rails-tutorial
if ! git remote | grep -q dokku; then
  git remote add dokku dokku@10.0.0.2:react-webpack-rails-tutorial
fi
cat &gt;.buildpacks &lt;&lt;EOF
https://github.com/heroku/heroku-buildpack-nodejs
https://github.com/heroku/heroku-buildpack-ruby
EOF
git add .buildpacks
git commit -m 'Add .buildpacks' || :
cat &lt;&lt;EOF &gt;app.json
{
  "scripts": {
    "dokku": {
      "predeploy": "bundle exec rake db:migrate"
    }
  }
}
EOF
git add app.json
git commit -m "Set script.dokku.predeploy to app.json" || :
git push dokku master
</code></pre>

<h2>動作確認</h2>

<p>ブラウザーで <a href="http://react-webpack-rails-tutorial.dokku.me/">http://react-webpack-rails-tutorial.dokku.me/</a> を開いて動作確認します。</p>

<h2>.buildpacks の順番</h2>

<p><code>.buildpacks</code> で nodejs, ruby という順番で指定しましたが、逆の順番にすると以下のエラーで失敗しました。
<code>react_on_rails</code> で使っているので、 nodejs の方を先に入れる必要があるようです。</p>

<pre><code class="text">-----&gt; Preparing app for Rails asset pipeline
       Running: rake assets:precompile
       cd client &amp;&amp; npm run build:production
       sh: 1: npm: not found
       rake aborted!
       Command failed with status (127): [cd client &amp;&amp; npm run build:production...]
       /tmp/build/vendor/bundle/ruby/2.3.0/gems/react_on_rails-6.1.0/lib/tasks/assets.rake:33:in `block (3 levels) in &lt;top (required)&gt;'
       /tmp/build/vendor/bundle/ruby/2.3.0/gems/rake-11.2.2/exe/rake:27:in `&lt;top (required)&gt;'
       Tasks: TOP =&gt; assets:precompile =&gt; react_on_rails:assets:compile_environment =&gt; react_on_rails:assets:webpack
       (See full trace by running task with --trace)
       !
       !     Precompiling assets failed.
       !
</code></pre>

<h2>開発環境設定</h2>

<p><a href="https://github.com/shakacode/react-webpack-rails-tutorial#basic-demo-setup">https://github.com/shakacode/react-webpack-rails-tutorial#basic-demo-setup</a> を参考にして設定します。</p>

<p><code>/vagrant/tmp/react-webpack-rails-tutorial-dev.sh</code> に以下のファイルをおいて実行します。</p>

<p>内容としては以下のようなことをしています。</p>

<ul>
<li><code>.ruby-version</code> で指定されている ruby のインストール
<a href="https://github.com/thoughtbot/capybara-webkit/wiki/Installing-Qt-and-compiling-capybara-webkit#ubuntu-trusty-1404">https://github.com/thoughtbot/capybara-webkit/wiki/Installing-Qt-and-compiling-capybara-webkit#ubuntu-trusty-1404</a> のインストール (OS X 上で直接試したときにはこの依存をインストールする部分が大変でした)</li>
<li>余計な差分が出ないように <code>Gemfile.lock</code> に記録されているバージョンの bundler をインストール</li>
<li><code>bundle install</code> で依存している gem をインストール</li>
<li><code>npm install</code> で依存している node modules をインストール</li>
<li>sqlite3 のデータベース作成</li>
</ul>


<pre><code class="sh">#!/bin/bash
set -euo pipefail
set -x
cd "$HOME/react-webpack-rails-tutorial"
ruby_version="$(&lt;.ruby-version)"
if ! rbenv versions | grep -q "$ruby_version"; then
  rbenv install "$ruby_version"
fi
sudo apt-get -y install libqt4-dev libqtwebkit-dev
bundler_version=$(grep -A1 'BUNDLED WITH' Gemfile.lock | tail -n1 | tr -d ' ')
if ! gem list | grep -q bundler; then
  gem install bundler -v "$bundler_version"
fi
bundle install
npm install
rake db:setup
</code></pre>

<h2>開発環境追加設定</h2>

<p><code>foreman start -f Procfile.hot</code> で起動して
<a href="http://dokku.me:5000/">http://dokku.me:5000/</a> で表示を確認すると「FATAL: Listen error: unable to monitor directories for changes. Visit <a href="https://github.com/guard/listen/wiki/Increasing-the-amount-of-inotify-watchers">https://github.com/guard/listen/wiki/Increasing-the-amount-of-inotify-watchers</a> for info on how to fix this.」というエラーになるので、サイトに書いてある通り、
<code>echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</code>
を実行しました。</p>

<p>実行前の <code>cat /proc/sys/fs/inotify/max_user_watches</code> は 8192 でした。</p>

<p>起動途中だと <code>ActionView::Template::Error (No such file or directory @ rb_file_s_mtime - app/assets/webpack/server-bundle.js):</code> というエラーになるので少し待てば良いようです。</p>

<p>しかし、次にアクセスしてみるとなぜか hot-assets が落ちてしまってうまく動きませんでした。
そして <code>ps x</code> でプロセスを確認するとちゃんと終了せずに残ってしまっているプロセスがあるので <code>pkill -f puma</code>, <code>pkill node</code> で終了させる必要がありました。</p>

<p>表示できても assets として <code>http://localhost:3500/</code> を参照しているため、ポートフォワーディングの設定追加が必要そうでした。</p>

<h2>Procfile.static</h2>

<p><code>foreman start -f Procfile.static</code> で起動して <code>http://dokku.me:5000/</code> を開いたところ、開けることもありましたが、落ちることも多くて安定しませんでした。</p>

<h2>まとめ</h2>

<p>Vagrant の VM は開発環境としてはなぜか安定しませんでしたが、 Dokku をデプロイ先としては安定して使えたので、
<code>react_on_rails</code> は開発対象の選択肢として入れても良さそうな感じがしました。</p>

<p>開発環境として OS X 上で直接動かしたときは問題なく動いたので、<code>localhost</code> ではなく <code>10.0.2.2</code> を使ってしまったのが不具合の原因だったのかもしれませんが、もう少し調べてみないとなんとも言えません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dokku-letsencrypt を使ってみた]]></title>
    <link href="http://blog.n-z.jp/blog/2016-04-06-dokku-letsencrypt.html"/>
    <updated>2016-04-06T23:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/dokku-letsencrypt</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/dokku/dokku-letsencrypt">dokku-letsencrypt</a> を試してみたのでそのメモです。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Ubuntu 14.04.4 LTS</li>
<li>Docker 1.10.3</li>
<li>Dokku 0.5.3</li>
<li>dokku-letsencrypt v0.7.0-7-gb4950b8</li>
</ul>


<h2>インストール</h2>

<p>README.md に書いてある手順の通りインストールして、 <code>git describe --tags</code> でバージョンを確認しておきました。</p>

<pre><code>$ sudo dokku plugin:install https://github.com/dokku/dokku-letsencrypt.git
-----&gt; Cloning plugin repo https://github.com/dokku/dokku-letsencrypt.git to /var/lib/dokku/plugins/available/letsencrypt
Cloning into 'letsencrypt'...
remote: Counting objects: 233, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 233 (delta 0), reused 0 (delta 0), pack-reused 229
Receiving objects: 100% (233/233), 48.62 KiB | 0 bytes/s, done.
Resolving deltas: 100% (136/136), done.
Checking connectivity... done.
-----&gt; Plugin letsencrypt enabled
-----&gt; Migrating zero downtime env variables. The following variables have been deprecated
=====&gt; DOKKU_SKIP_ALL_CHECKS DOKKU_SKIP_DEFAULT_CHECKS
=====&gt; Please use dokku checks:[disable|enable] &lt;app&gt; to control zero downtime functionality
=====&gt; Migration complete
=====&gt;
=====&gt; Migration complete
=====&gt;
=====&gt; Migration complete
=====&gt;
=====&gt; Migration complete
=====&gt;
=====&gt; Migration complete
=====&gt;
Adding user dokku to group adm
$ cd /var/lib/dokku/plugins/available/letsencrypt/
$ git describe --tags
v0.7.0-7-gb4950b8
$ cd
</code></pre>

<h2>アップグレード</h2>

<p>README.md にアップグレードの手順も書いてあったので、試しておきました。</p>

<pre><code>$ sudo dokku plugin:update letsencrypt
Plugin (letsencrypt) updated
</code></pre>

<h2>対象アプリの確認</h2>

<p><code>dokku apps</code> でアプリケーション一覧を表示して、対象とするアプリケーションの名前を確認しておきました。</p>

<ul>
<li><code>dokku help</code></li>
<li><code>dokku apps:help</code></li>
<li><code>dokku apps</code></li>
</ul>


<h2>メールアドレス設定</h2>

<p>Let&rsquo;s Encrypt に登録するメールアドレスを設定しておきます。
<a href="https://letsencrypt.jp/usage/" title="Let's Encrypt の使い方">Let&rsquo;s Encrypt の使い方</a>の説明によると「ここで入力したメールアドレスは、緊急の通知や鍵を紛失したときの復旧に使われます。」</p>

<p>dokku-letsencrypt プラグインでは「利用規約への同意」に相当する手順がありませんが、念のため利用規約 (現在のバージョンは <a href="https://letsencrypt.org/documents/LE-SA-v1.0.1-July-27-2015.pdf">https://letsencrypt.org/documents/LE-SA-v1.0.1-July-27-2015.pdf</a> ) に目を通しておくと良いと思います。</p>

<p>ちなみに今のところ letsencrypt に登録したメールアドレスに letsencrypt からメールが来たことはありません。</p>

<pre><code>$ dokku config:set --no-restart staging.example.co.jp DOKKU_LETSENCRYPT_EMAIL=root@example.co.jp
-----&gt; Setting config vars
       DOKKU_LETSENCRYPT_EMAIL: root@example.co.jp
</code></pre>

<h2>メールアドレスをグローバルに設定するかアプリケーションごとに設定するか</h2>

<p>グローバルに設定することも可能だと思いますが、メールアドレスを設定していなければ <code>dokku letsencrypt APP</code> の最初のチェックで止まって、既存の TLS 設定を上書きされる心配がないので、すべてのアプリケーションで letsencrypt を使うのでなければ、アプリケーションごとに設定することをおすすめします。</p>

<p>メールアドレスを設定していなければ、以下のように失敗して止まってくれます。</p>

<pre><code>$ dokku letsencrypt node-js-app
=====&gt; Let's Encrypt node-js-app...
 !     ERROR: Cannot request a certificate without an e-mail address!
 !       please provide your e-mail address using
 !       dokku config:set --no-restart node-js-app DOKKU_LETSENCRYPT_EMAIL=&lt;e-mail&gt;
</code></pre>

<h2>証明書発行と設定</h2>

<p><code>dokku letsencrypt APP</code> で証明書発行から設定まで自動で実行されます。</p>

<p>すでに <code>tls/server.{crt,key}</code> が存在していても強制的にシンボリックリンクで上書きされるので、他で発行された証明書を使っている場合は注意が必要です。</p>

<pre><code>$ dokku letsencrypt staging.example.co.jp
=====&gt; Let's Encrypt staging.example.co.jp...
-----&gt; Updating letsencrypt docker image...
latest: Pulling from m3adow/letsencrypt-simp_le
420890c9e918: Pull complete
acbaf1e6012f: Pull complete
5f71a1a2d3dc: Pull complete
Digest: sha256:be1d7aca214d5277af18d7bf75a2bc78afa5a1eabf98aaa8a606c4ca2a7fdeb5
Status: Downloaded newer image for m3adow/letsencrypt-simp_le:latest
       done
-----&gt; Enabling ACME proxy for staging.example.co.jp...
-----&gt; Getting letsencrypt certificate for staging.example.co.jp...
        - Domain 'staging.example.co.jp'
darkhttpd/1.11, copyright (c) 2003-2015 Emil Mikulic.
listening on: http://0.0.0.0:80/
2016-04-04 03:26:42,946:INFO:__main__:1202: Generating new account key
2016-04-04 03:26:43,831:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:44,110:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:44,302:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:44,841:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): letsencrypt.org
2016-04-04 03:26:45,410:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:45,664:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:45,940:INFO:requests.packages.urllib3.connectionpool:207: Starting new HTTP connection (1): staging.example.co.jp
2016-04-04 03:26:45,946:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): staging.example.co.jp
2016-04-04 03:26:45,995:INFO:__main__:1294: staging.example.co.jp was successfully self-verified
2016-04-04 03:26:46,022:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:46,272:INFO:__main__:1302: Generating new certificate private key
2016-04-04 03:26:47,528:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:47,723:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:47,987:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:48,215:INFO:__main__:385: Saving account_key.json
2016-04-04 03:26:48,216:INFO:__main__:385: Saving fullchain.pem
2016-04-04 03:26:48,216:INFO:__main__:385: Saving chain.pem
2016-04-04 03:26:48,216:INFO:__main__:385: Saving cert.pem
2016-04-04 03:26:48,216:INFO:__main__:385: Saving key.pem
-----&gt; Certificate retrieved successfully.
-----&gt; Symlinking let's encrypt certificates
-----&gt; Configuring staging.example.co.jp...(using built-in template)
-----&gt; Creating https nginx.conf
-----&gt; Running nginx-pre-reload
       Reloading nginx
-----&gt; Disabling ACME proxy for staging.example.co.jp...
       done
</code></pre>

<h2>有効になっているアプリケーション一覧確認</h2>

<p><code>dokku letsencrypt:ls</code> で有効になっているアプリケーションとその有効期限を確認します。</p>

<pre><code>$ dokku letsencrypt:ls
-----&gt; App name           Certificate Expiry        Time before expiry        Time before renewal
staging.example.co.jp 2016-07-03 11:27:00       89d, 22h, 56m, 55s        59d, 22h, 56m, 55s
</code></pre>

<h2>自動更新</h2>

<p>有効期限が 30 日 (<code>DOKKU_LETSENCRYPT_GRACEPERIOD</code> で変更可能) を切ると自動更新してくれる <code>dokku letsencrypt:auto-renew</code> も試しておきます。</p>

<pre><code>$ dokku letsencrypt:auto-renew
=====&gt; Auto-renewing all apps...
       staging.example.co.jp still has 59d, 22h, 48m, 36s days left before renewal
=====&gt; Finished auto-renewal
</code></pre>

<p>問題なさそうなので、<code>dokku</code> ユーザーの <code>crontab</code> で設定して自動実行するようにしておきます。
リモートからのトリガーで実行されるように ssh で入れるユーザーの <code>crontab</code> で <code>ssh dokku letsencrypt:auto-renew</code> を設定しておくのでも良いと思います。</p>

<h2>セキュリティ上の問題点</h2>

<p><code>dokku-letsencrypt</code> が使用している <a href="https://github.com/kuba/simp_le" title="Simple Let's Encrypt Client">Simple Let&rsquo;s Encrypt Client</a> の issue の <a href="https://github.com/kuba/simp_le/issues/29" title="private key permissions">private key permissions</a> で指摘されているように、 <code>ls -al /home/dokku/staging.example.co.jp/letsencrypt/certs/current/</code> で確認してみると、他のユーザーからは読めなくするべき <code>account_key.json</code> や <code>key.pem</code> も誰でも読めるパーミッションになってしまっているので、 <code>sudo chmod 700 /home/dokku/staging.example.co.jp/letsencrypt</code> などでパーミッションを落としておく方が良さそうです。</p>

<p>ファイル自体のパーミッションを落としても良さそうですが、更新された後のことも考えると <code>/home/dokku/APP/letsencrypt</code> ディレクトリ自体のパーミッションを落としておくのが良さそうです。</p>

<h2>Rate Limit</h2>

<p><a href="https://letsencrypt.jp/faq/#RateLimiting" title="Let's Encrypt の証明書に取得数制限はありますか？">Let&rsquo;s Encrypt の証明書に取得数制限はありますか？</a> のリンク先に書いてあるように、この記事執筆時点では「アカウント登録/IP アドレスごと」(3 時間で 10 個) と「証明書発行/ドメインごと」(1 週間で 5 個) の制限があるので、注意が必要です。</p>

<p>特に dokku-letsencrypt では<a href="https://github.com/letsencrypt/letsencrypt">公式のクライアント</a>が <code>/etc/letsencrypt/accounts</code> でアカウントを共有するのと違って、 <code>account_key.json</code> をアプリケーションごとに作成しているので、注意が必要そうです。</p>

<p>ただし、現状の制限だと証明書発行数の制限の方が引っかかりやすいので、アカウント登録の制限は問題にならないようにも思います。</p>

<p>証明書発行数の制限については <code>dokku domains:add</code> や <code>dokku domains:remove</code> で適切にドメインの追加や削除をしてから <code>dokku letsencrypt</code> を実行するように README.md の <a href="https://github.com/dokku/dokku-letsencrypt/tree/b4950b8254f683e4af775bad44e390763a699de1#dealing-with-rate-limit" title="Dealing with rate limit">Dealing with rate limit</a> に書いてあります。</p>

<h2>証明書の情報表示</h2>

<p><code>dokku certs:info</code> で letsencrypt のものに限らず、証明書の情報を表示できます。</p>

<pre><code>adminuser@tk2-213-16013:~$ dokku certs:info staging.example.co.jp
-----&gt; Fetching SSL Endpoint info for staging.example.co.jp...
-----&gt; Certificate details:
=====&gt; Common Name(s):
=====&gt;    staging.example.co.jp
=====&gt;    staging.example.co.jp
=====&gt; Expires At: Jul  3 02:27:00 2016 GMT
=====&gt; Issuer: C=US, O=Lets Encrypt, CN=Lets Encrypt Authority X3
=====&gt; Starts At: Apr  4 02:27:00 2016 GMT
=====&gt; Subject: CN=staging.example.co.jp
=====&gt; SSL certificate is self signed.
adminuser@tk2-213-16013:~$ dokku certs:info production.example.co.jp
-----&gt; Fetching SSL Endpoint info for production.example.co.jp...
-----&gt; Certificate details:
=====&gt; Common Name(s):
=====&gt;    production.example.co.jp
=====&gt;    production.example.co.jp
=====&gt;    example.co.jp
=====&gt; Expires At: Aug  4 00:05:31 2016 GMT
=====&gt; Issuer: C=IL, O=StartCom Ltd., OU=Secure Digital Certificate Signing, CN=StartCom Class 1 Primary Intermediate Server CA
=====&gt; Starts At: Aug  3 18:20:22 2015 GMT
=====&gt; Subject: C=JP; CN=production.example.co.jp; emailAddress=hostmaster@example.co.jp
=====&gt; SSL certificate is self signed.
adminuser@tk2-213-16013:~$ dokku certs:info another.example.co.jp
-----&gt; Fetching SSL Endpoint info for another.example.co.jp...
-----&gt; Certificate details:
=====&gt; Common Name(s):
=====&gt;    another.example.co.jp
=====&gt;    another.example.co.jp
=====&gt;    example.co.jp
=====&gt; Expires At: Apr 23 04:56:14 2016 GMT
=====&gt; Issuer: C=IL, O=StartCom Ltd., OU=Secure Digital Certificate Signing, CN=StartCom Class 1 Primary Intermediate Server CA
=====&gt; Starts At: Apr 22 23:55:13 2015 GMT
=====&gt; Subject: C=JP; CN=another.example.co.jp; emailAddress=hostmaster@example.co.jp
=====&gt; SSL certificate is self signed.
adminuser@tk2-213-16013:~$
</code></pre>
]]></content>
  </entry>
  
</feed>
