<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: event | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/event/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2017-08-15T20:54:07+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OSS Gate大阪ワークショップ2017-08-12 with さくらクラブに参加しました]]></title>
    <link href="http://blog.n-z.jp/blog/2017-08-12-oss-gate-osaka.html"/>
    <updated>2017-08-12T23:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/oss-gate-osaka</id>
    <content type="html"><![CDATA[<p><a href="https://oss-gate.doorkeeper.jp/events/63163">OSS Gate大阪ワークショップ2017-08-12 with さくらクラブ</a>に参加しました。</p>

<!--more-->


<p>以下、今回感じたことを適当にメモしておきます。</p>

<h2>会場</h2>

<p>最近よく行っている気がするグランフロント大阪タワーA 35Fのさくらインターネットさんでした。
やはり1階からは入れなくて、2階から入る必要がありました。
9階で乗り換えが必要なのも最初はわかりにくそうです。</p>

<p>プロジェクター3台に同じ画面を出すには分配器を用意してもらう必要があったようで、今回は途中で用意してもらいましたが、必要なら開始前に用意しておいてもらうのが良さそうでした。</p>

<h2>座席</h2>

<p>4人がけできるテーブルがメインだったので、1人のサポーターの左右に2人のビギナーという体制でした。
余ったサポーターはサポートメンターということになったので、一応サポートメンターでした。</p>

<h2>改善できそうだと思ったところ</h2>

<p>Doorkeeper で参加申し込みするところに壁があるという話があったので、 <a href="https://oss-gate.github.io/">https://oss-gate.github.io/</a> では良い感じに目立っている動画を doorkeeper の方でも気付きやすいところで紹介すると良いのではないかという話がありました。</p>

<h2>未経験者の理由</h2>

<p>スライドに書いてある理由の予想とはだいたい違う回答が出てくるのですが、今回は英語だからという感じの理由でした。</p>

<h2>BOM 問題</h2>

<p>アンケートの集計で BOM 付きの YAML ファイルになっていた人がいて、結構はまったので、YAML は意外と難しいなと思いました。</p>

<p>今は BOM 対応が入ったので次回以降は大丈夫だと思います。</p>

<h2>事前準備</h2>

<p>初めてのサポーターの人には動画を見てもらっておくと、だいたいどんな感じのことをするのか、わかってもらえて良いのではないかと思いました。</p>

<h2>ふりかえり</h2>

<p>サポーター1人にビギナー2人だとふりかえりの時間にフィードバックをしっかりしていると時間が足りないと感じました。</p>

<h2>ドキュメント</h2>

<p>モデレーター(進行役)やサポートメンター用のドキュメントが不足しているようなので、もっとまとめられると良さそうに思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オープンソースカンファレンス2017 Kyotoに参加した]]></title>
    <link href="http://blog.n-z.jp/blog/2017-08-05-osc2017-kyoto.html"/>
    <updated>2017-08-05T20:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/osc2017-kyoto</id>
    <content type="html"><![CDATA[<p><a href="https://www.ospn.jp/osc2017-kyoto/">オープンソースカンファレンス2017 Kyoto</a>
に参加しました。</p>

<!--more-->


<p>以下、メモです。</p>

<h2>会場</h2>

<p>KRP は遠いですが、行きは西院駅から歩きました。
帰りは天気が悪かったので、丹波口駅から帰りました。</p>

<p>朝からは行けなかったので、13時すぎに到着しました。</p>

<h2>「DLL読み込みの問題」を読み解く</h2>

<p>よく見かける DLL 読み込みの脆弱性がどういうことなのか気になっていたので、途中からになってしまいましたが、聴きに行きました。</p>

<ul>
<li><p>DLL の検索パス <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85%29.aspx">Dynamic-Link Library Search Order (Windows)</a></p>

<ul>
<li>KnownDLLs に登録されているかどうか</li>
<li>実行ファイルがあるディレクトリ (アプリケーションディレクトリ)</li>
<li>Windows システムディレクトリ</li>
<li>Windows ディレクトリ</li>
<li>カレントディレクトリ</li>
<li>環境変数 PATH</li>
</ul>
</li>
<li><p>sysinternals の Process Monitor (procmon)</p></li>
<li>Dependency Walker</li>
<li><p>procmon の使い方の例</p></li>
<li><p>2010年ごろの状況</p></li>
<li>DLL 読み込みの脆弱性に対する攻撃手法が公開され、注目を集める</li>
<li><a href="https://www.jpcert.or.jp/sc-magazine/codezine02-8.html">第8回　WindowsのDLLだけが危ないのか？DLL hijacking vulnerability概説（前編）</a></li>
<li>ドキュメントと一緒に細工した DLL を置いてアプリを起動するとカレントディレクトリの DLL を読み込む</li>
<li><p>この対策としてカレントディレクトリの優先順位が下がった</p></li>
<li><p>2016年ごろから「インストーラ」「自己解凍書庫」に対するDLL読み込み脆弱性の届出が増える</p></li>
<li><p>インストーラーと一緒に細工した DLL を置いてインストーラーを起動すると同一ディレクトリにある DLL を使ってしまう</p></li>
<li><p>Windows や Program Files といったシステム領域はアプリ側ではなくシステム側が保護</p></li>
<li>ユーザディレクトリは管理はユーザーの責任だが</li>
<li>システム領域外で動作するアプリには、よりセキュアな実装を求めたい</li>
<li><p>インストーラ、自己解凍書庫、ポータブルアプリなど</p></li>
<li><p>ユーザーが行うべき対策</p></li>
<li>あやしいファイルを放置しない</li>
<li>インストーラーや自己解凍書庫を安全な形で実行する</li>
<li><p>安全な形で実行: インストーラーをダウンロード、新規にディレクトリを作成、作成したディレクトリにインストーラーを移動、インストーラーを起動</p></li>
<li><p>開発者が行うべき対策</p></li>
<li>DLL の読み込み方法に注意する</li>
<li>アプリ/インストーラーの挙動についてユーザーに説明し、注意を促す</li>
<li>SetDefaultDllDirectories() や SetDllDirectory() でアプリケーションディレクトリやカレントディレクトリを排除</li>
<li>DLL 読み込みは可能な限り絶対パスで</li>
<li><p>インストーラー作成ツールによるインストーラー作成やアーカイバーによる自己解凍書庫作成時にはツールの対応状況を確認</p></li>
<li><p>開発者が対処しきれないケース</p></li>
<li>アプリのスタートアップ部分で勝手にロード</li>
<li>Windows 標準 DLL が独自に他 DLL をロード</li>
<li>Windows 標準機能 (DLL forwarding, OS 互換機能の発動など)</li>
<li>動作監視ソフトの影響など</li>
<li><p>(参考: <a href="http://micco.mars.jp/vul/2017/mhsvi20170515_01.htm">UNLHA32.DLLで作成された自己解凍書庫における任意のDLL読み込みに関する脆弱性</a>など)</p></li>
<li><p>DLL 読み込みと合わせてコマンド呼び出しについても注意</p></li>
<li><p>関連情報</p></li>
<li><a href="https://www.slideshare.net/jpcert_securecoding/dll-78581339">DLL読み込みの問題を読み解く</a></li>
</ul>


<p>ユーザーの対策として、ダウンロードしたファイルを実行する際に別途ディレクトリを作って、という話があったので、ブラウザーにダウンロード時にディレクトリを作る機能を要望したりはしていないのでしょうか? という質問をしてみました。
今の所、そういう話はしていないが、話をしてみるのは良いかもというかランダムなディレクトリを作るのは利便性が問題なのではとか、ブラウザーのアップデーターはランダムなディレクトリを作って実行しているから大丈夫という感じの回答だったと思います。</p>

<h2>Ubuntuはどこへ向かうのか～方針転換の解説～</h2>

<p>どういう系統の話か全然わかってなくて聴きにいったら、 Unity の話でした。
狭い部屋がほぼいっぱいで人気でした。</p>

<ul>
<li>R.I.P. Unity 2010-2017</li>
<li>2007年頃(?) に Netbook の登場</li>
<li>ディスプレイが狭いので専用のチューニングが求められた</li>
<li>Dell Inspiron Mini 9 : 日本で発売された Ubuntu プリインストールの Netbook</li>
<li>1024×600</li>
<li>Ubuntu Netbook Remix の登場 : Ubuntu 9.04 ベース</li>
<li>Remix はアンオフィシャル</li>
<li>Ubuntu Netbook Edition : Ubuntu 10.04 ベースと 10.10 ベースのみ</li>
<li>Edition はオフィシャルリリース</li>
<li>10.04 は LTS だが Netbook Edition は LTS ではなかった</li>
<li>Unity 初登場は Ubuntu Netbook Edition 10.10</li>
<li>Mutter ベース</li>
<li>Ubuntu 11.04 : Unity がデフォルトになった最初の Ubuntu</li>
<li>Desktop Edition と Netbook Edition を統合</li>
<li>Compiz ベースの Unity と Metacity ベースの Unity 2D</li>
<li>Ubuntu 11.10 の Unity</li>
<li>Ubuntu 12.04 LTS : Unity がデフォルトになって初めての LTS</li>
<li>じゃんけんタイム: 日経 Linux 6 月号</li>
<li>Ubuntu 12.10 : Unity 2D はなくなった</li>
<li>Ubuntu 13.04 : Unity 7 になった</li>
<li><p>逆に言えばここから 4 年間 Unity 7 が続いた</p></li>
<li><p>Unity 8</p></li>
<li>デスクトップ用とスマートデバイス用 Ubuntu を統合する UI が必要となった</li>
<li>スクラッチから開発</li>
<li>UI だけでなく、ディスプレイマネージャ (Mir) から開発</li>
<li>X.Org ではスマートデバイスは辛い</li>
<li>2012年8月: 当初 qml-phone-shell という名前</li>
<li>2013年6月から Unity 8 に</li>
<li><p>Ubuntu 17.10 で概ね実用的に (日本語を打たなければという条件付きで)</p></li>
<li><p>じゃんけんタイム: 日経 Linux 7 月号</p></li>
<li><p>2017.04.05 <a href="https://insights.ubuntu.com/?p=65030">https://insights.ubuntu.com/?p=65030</a></p></li>
<li>スマートデバイスやコンバージェンスよりもクラウドや IoT に重点的に投資するという内容</li>
<li>Unity 8 への投資も中止し、 GNOME に戻る</li>
<li><p>Ubuntu デスクトップはユーザーも多く今尚重要である</p></li>
<li><p>現時点での確定事項</p></li>
<li>GNOME Shell と GDM をデフォルトに</li>
<li>Ubuntu GNOME はリリースせず</li>
<li><p>Unity 7 から GNOME Shell への移行サポート</p></li>
<li><p>現時点での未確定事項</p></li>
<li>デフォルトのアプリケーション</li>
<li>インプットメソッド: Fcitx の現行バージョンは Wayland 非対応</li>
<li><p>ディスプレイマネージャ: Wayland がデフォルトになりそう</p></li>
<li><p>Unity 7 を使用したいなら Ubuntu 16.04 LTS にするのがおすすめ</p></li>
<li><p>Unity 8 は yunit というフォークとして生き残る見込み <a href="https://yunit.io/">https://yunit.io/</a></p></li>
<li><p>Ubuntu のセカンドチョイスは Ubuntu GNOME だった</p></li>
<li><p>今後その役目は Ubuntu MATE か?</p></li>
<li><p>Ubuntu Weekly Topics 2017年4月7日号</p></li>
<li>Ubuntu Weekly Recipe 第 467 回 GNOME 初心者向け</li>
<li>Software Design</li>
<li>日経 Linux</li>
</ul>


<h2>Debian updates</h2>

<p>とりあえず OSC に行こうかと思ったきっかけになった Debian の話も聴きました。
時間がなくなったので後半は急いで終わりました。</p>

<ul>
<li>Debian とは?</li>
<li>Debian は連携する個人の集団</li>
<li>Debian は開発元企業はなく、ボランティアのみ</li>
<li>世界中に開発者がいる</li>
<li>Debian Free Software Guideline</li>
<li><a href="https://www.debian.org/social_contract#guidelines">https://www.debian.org/social_contract#guidelines</a></li>
<li><a href="http://www.opensource.jp/osd/osd-japanese.html">http://www.opensource.jp/osd/osd-japanese.html</a></li>
<li><a href="https://www.debian.org/social_contract">https://www.debian.org/social_contract</a></li>
<li>Debian Policy</li>
<li>Debian Derivatives</li>
<li><a href="https://en.wikipedia.org/wiki/List_of_Linux_distributions">https://en.wikipedia.org/wiki/List_of_Linux_distributions</a> の図</li>
<li>stable, testing, unstable</li>
<li>Debian JP Project とは?</li>
<li>次回の関西勉強会は 8/27(日) に IM の話</li>
<li>Debian 9 Stretch</li>
<li>2017-06-17: Debian 9.0</li>
<li>2017-07-22: Debian 9.1</li>
<li>主な変更点</li>
<li>サポートアーキテクチャ</li>
<li>mips64el</li>
<li>i386 が i686 以降に変更</li>
<li>サポートから外れたアーキテクチャ: powerpc</li>
<li>kFreeBSD はテクノロジープレビューから porter (?) になった</li>
<li>ポメラで Debian (armhf) が動く</li>
<li>theme: softwaves</li>
<li>主な Software のバージョン</li>
<li>クロスコンパイルがデフォルトでサポート</li>
<li>変更点, 注意点</li>
<li>実行ファイルは PIE が有効になっている</li>
<li>iproute2 が推奨、 net-tools は非推奨 (net-tools: ifconfig, arp, netstat, route, &hellip;)</li>
<li>iceweasel → firefox 、 icedove → thunderbird</li>
<li>mysql から mariadb : jessie からのアップグレードの際には自動的に mariadb へ</li>
<li>Xorg がユーザー権限でも動作可能に</li>
<li>セキュリティ関連</li>
<li>Firefox, Chromium のセキュリティ更新の提供</li>
<li>Firefox ESR, Thunderbird ESR</li>
<li>libv8, nodejs, node-* のセキュリティ更新は提供されない</li>
<li>OpenSSL: 3DES, RC4 の TLS/SSL 利用は提供されない</li>
<li>Ruby チームは Redmine と他2個ぐらいのパッケージが必要とする gem を中心にメンテしている</li>
<li>Adobe Flash が Stretch に入らない</li>
<li>互換性</li>
<li>PIE</li>
<li>NIC : predictable name (jessie からの更新の際には据え置き)</li>
<li>OpenSSH : 旧式暗号と SSH v2 が無効</li>
<li>Xorg: evdev から libinput</li>
<li>Upstart は削除</li>
<li>デフォルトは systemd</li>
<li>sysvinit, OpenRC も利用可能</li>
<li>installer</li>
<li>GUI インストールがデフォルト</li>
<li>UEFI のセキュアブートは未対応</li>
<li>screen 対応</li>
<li>CD イメージを廃止</li>
<li>アップグレード</li>
<li>リリースノートを読むことを推奨</li>
<li>apt-line が <code>ftp://</code> の場合は <code>http://</code> に変更が必須</li>
<li>Debian 8.8 以降にあげてから一度再起動してからあげないと PIE 関連ではまる</li>
</ul>


<h2>ライトニングトーク＆閉会式</h2>

<ul>
<li><a href="https://github.com/verifast/verifast">https://github.com/verifast/verifast</a></li>
<li>コメントで注釈を入れるとC言語のプログラムを検証してくれる</li>
<li><p><a href="https://metasepi.connpass.com/event/55350/">#静的コード解析の会 第4回@大阪 - connpass</a></p></li>
<li><p>近くの海外カンファレンスに行こう！</p></li>
<li><p>openSUSE.Asia Summit 2017 Tokyo</p></li>
<li><p><a href="https://opensuseja.connpass.com/event/62902/">openSUSE Leap 42.3 Release Party Kyoto &amp; もくもく会 - connpass</a></p></li>
<li><p>KRP 周辺グルメガイド</p></li>
<li><p>順番に紹介していってドラがなったところで終了だった</p></li>
<li><p>鉄道とオープンデータ</p></li>
<li><p>時刻表データは自由なものが少ないので架空の路線を作っていろいろやっている話だった</p></li>
<li><p>どうしてもあれが欲しくなった</p></li>
<li>500兆円ほしいジェネレーターを fork してクリッピングするようにした</li>
<li>iOS も対応した</li>
<li><p><a href="http://tmx3.net/5000choyen/">http://tmx3.net/5000choyen/</a></p></li>
<li><p>大学で無理やり Splatoon2 をやった話</p></li>
<li>VPN + mac のインターネット共有</li>
<li><p>共有する接続経路で VPN を選ぶ必要があった</p></li>
<li><p>便利？な機能を使って開発していく</p></li>
<li><p><a href="https://github.com/shiotomo/cPractice">https://github.com/shiotomo/cPractice</a></p></li>
<li><p>最近の学生コミュニティーについて</p></li>
<li>ICT トラブルシューティングコンテスト</li>
<li>ネットワーク講座</li>
<li>OITLT</li>
<li>東京に負けない魅力的なコミュニティーとイベントを作りたい</li>
<li>関西を盛り上げたい</li>
<li><p>「とある工大生の死活日記」で検索</p></li>
<li><p>山形で OSC 開催したい！</p></li>
<li><p>OSC サミットと  11/26(日) OSC 広島のご紹介</p></li>
<li><p>IT 企業の裏側を知りたい！ アンケート調査</p></li>
<li>会場でアンケートをとっていたらしく、その結果発表でした。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ELFとDWARF勉強会に参加しました]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-30-elf-dwarf.html"/>
    <updated>2017-07-30T13:19:55+09:00</updated>
    <id>http://blog.n-z.jp/blog/elf-dwarf</id>
    <content type="html"><![CDATA[<p><a href="https://techplay.jp/event/626491">ELFとDWARF勉強会</a>
に参加しました。</p>

<!--more-->


<p>以下、今回のメモです。</p>

<p>資料は後日公開されるようなので、公開されたらリンクする予定です。</p>

<h2>会場</h2>

<p>昨日と同じ場所なので、迷わずたどり着けましたが、なぜか1階からはタワーAに入れなくて2階から入る必要がありました。</p>

<h2>参加者自己紹介</h2>

<p>一言ずつぐらい参加者の自己紹介がありました。
大阪以外からきている人も多く、遠くからきている人もいて驚きました。
組み込み系などで普段から関連するようなことをしていそうな人が多そうな感じでした。</p>

<p>遠くから参加といえば Binary 2.0 カンファレンス2005 の時はイベントのためだけにわざわざ東京に行ったような覚えがあるので、レアなイベントだと遠くからの参加もよくあることなのかもしれません。</p>

<h2>ドキュメントを読まずに知るELF入門</h2>

<ul>
<li><a href="http://kozos.jp/">http://kozos.jp/</a></li>
<li>本日の内容は<a href="http://amzn.to/2waRSkD">リンカ・ローダ実践開発テクニック</a> という本にかいてある内容のさわり</li>
<li><a href="http://amzn.to/2uNvsqs">Linkers and Loaders</a> は概要だけで実装するには他の資料に当たる必要がある</li>
<li>リンカ・ローダについて詳しくかいてある本は他にはないのではないか</li>
<li>発表者が主に使っているのが FreeBSD なので FreeBSD の話が中心</li>
<li>Executable and Linking Format なので本来は ELF フォーマットというのはおかしい (が、RPG などのエルフと紛らわしいので ELF フォーマットといってしまうことも多い)</li>
<li>実行ファイルやオブジェクトファイル、共有ライブラリだけではなくコアダンプも表現可能</li>
<li>「リンク」のための領域情報と「ロード」のための領域情報を別々に持つというのは珍しい</li>
<li>リンクとロードの説明</li>
<li>バイナリエディタを入れるのがおすすめ</li>
<li>hexedit というのを使っている</li>
<li>最初の方は 00 が多い部分、次に ASCII データっぽい部分、配列データっぽい部分、機械語コードっぽい部分のように領域ごとに特徴が分かれている</li>
<li>xpm に変換して眺める</li>
<li>英語のドキュメントを探すのではなく <code>/usr/include/**/*elf*</code> などを探すことが多い</li>
<li><code>/usr/include/elf.h</code> → <code>/usr/include/sys/elf32.h</code> をみてみる</li>
<li>hdr は header など、略語などを知っているとソースコードを読むのがはやくなる</li>
<li>ELF ヘッダ - ファイルの先頭に1個</li>
<li>プログラムヘッダ - ロード用 - セグメントをさしている</li>
<li>セクションヘッダ - リンク用 - セクションをさしている</li>
<li>セグメントとセクションは独立した領域だが、セグメントの中に複数セクションがあったりする</li>
<li><code>Elf32_Half</code> は 2 バイト</li>
<li><code>Elf32_Word</code> は 4 バイト</li>
<li><code>Elf32_Addr</code> は 4 バイト (32ビット環境をみているので)</li>
<li>readelf -a 実行ファイル で情報表示できる</li>
<li><code>elf_common.h</code> に <code>EM_386</code> として 3 が定義されている</li>
<li><code>e_machine</code> のところを書き換えて readelf -a で変わったのを確認して、実行してみて実行できないのを確認 (間違ったアーキテクチャです と出てきた)</li>
<li>2,3 種類以上の情報を見比べて確認すると良い</li>
<li>ロードしてエラーにしている部分を探す</li>
<li>FreeBSD は <code>/usr/src/sys</code> にカーネルソースがある</li>
<li>重要なものはそんなに深いところにはないので <code>find . -name "*elf*"</code> ではなく <code>ls */*elf*</code> ぐらいで探せば良い</li>
<li>ちょっと見つからなかったのでパス</li>
<li>セグメントをロードしている部分をみてみる</li>
<li>実際のロード処理は <code>load_section</code> という名前になっているっぽい (<code>load_segment</code> の方が良いのではないかという指摘)</li>
<li>セクションという単語は割と適当に使う人もいるらしいので注意が必要</li>
<li>プログラムヘッダの情報をみていくのは簡単に作れる (<code>e_phoff</code> から <code>e_phentsize</code> バイト を <code>e_phnum</code> 個みていけば良い)</li>
<li>実際にライブコーディングで作ってみる</li>
<li>OS を作っているとフラグをちょっと変えたいとかいうことがある</li>
<li>objcopy などでできることもあるが、対応できない場合に自作のコードがあると応用できるので、 <code>readelf</code> でできるようなことでも自作できると良いことがある</li>
<li>Debian などでは bintuils にある (ビンユーティリティと読んでいた)</li>
<li>kozos のブートローダをみる (本質的にはプログラムヘッダをループでコピーしているだけ)</li>
<li>リンクはセグメントではなくセクションを見ていく</li>
<li>readelf -a 実行ファイルの <code>.text</code> セクションのオフセット部分を実際にバイナリエディタで見てみると確かに機械語っぽい</li>
<li>オブジェクトファイルの <code>.text</code> をみてみる</li>
<li>デフォルトのリンカスクリプトは <code>ld -verbose</code> でみえる</li>
<li>リンカスクリプトの自作例 (<code>-Wl,Tld.scr</code> で指定)</li>
<li><code>objdump -d hello.o</code> と <code>objdump -d hello</code> をみてみる</li>
<li>関数呼び出しのアドレスがオブジェクトファイルだと 0 (空欄) になっているのが実行ファイルだと埋められている</li>
<li><code>.rela.text</code> セクションに埋める必要のある位置が書かれている</li>
<li>リンカがやっているのはセクションを寄せ集めるのと再配置情報を埋めること</li>
<li>書籍では簡易リンカを作るサンプルコードがある</li>
<li>コアダンプをみてみる</li>
<li>prstatus というキーワードでカーネルのソースコードをみてみる</li>
<li>質疑応答</li>
<li>各セクションが何なのかの説明はまとまったものはなさそう</li>
<li>調べるときは FreeBSD と Linux 両方のソースコードをみることが多い</li>
<li>リンカスクリプトで <code>.text</code> セクションのアドレスを指定しなかったらアボートしていたが指定したアドレスの意味は?</li>
<li>他で使っていたアドレスをそのまま使っているだけで詳細は不明</li>
<li>CPU などで決まっているアーキテクチャの場合はそのアドレスを使う</li>
<li>リンカスクリプトの文法は info ld の Scripts が一番詳しい (だいたいは書籍にもかいてある)</li>
</ul>


<h2>休憩</h2>

<h2>DWARFとデバッガのからくり</h2>

<ul>
<li>自己紹介</li>
<li><a href="https://github.com/takubo">https://github.com/takubo</a></li>
<li>UNIX 文化 (ハッカー文化) と、組み込み文化を結びつけたい</li>
<li>関西でも、勉強する勉強する勉強会をしたい</li>
<li>「〜の使い方」じゃなくて50年戦える「技術」と「知識」を</li>
<li>AWK, sed</li>
<li>今回は AWK ではなく DWARF の話</li>
<li>基礎情報</li>
<li>デバッグ情報フォーマット (の規格)</li>
<li>Debug With Attributed Record Format の略</li>
<li>デバッガでできること、わかること (ユーザ視点): 実行制御 (ブレークポイント、ステップ実行、〜まで実行)、スタックトレース、変数の値を表示</li>
<li>デバッガに課せられた任務: 実際は機械語が実行されているが、ソースコードがそのまま実行されているかのような錯覚を与える</li>
<li>デバッガが知るべきこと: ソースの各行に対応する機械語、関数の先頭・末尾に対応する機械語、変数のありか、変数のビット幅・表現形式(文字列、整数、浮動小数)、文字列や配列の境界、コールスタックを巻き戻す方法</li>
<li>コールスタックの例: スタックに return アドレスを持つ、レジスタウィンドウ、リンクリスト</li>
<li>ブレークポイントの仕組みの例: デバッグレジスタにアドレスを設定、メモリアクセスを監視、MMU などでメモリ番地の rwx を落として例外を発生させる、命令を書き換えて例外を発生させる</li>
<li>どの方法でもブレークポイントを設定するアドレスを知る必要がある</li>
<li>デバッグ情報とは: 「デバッガが知るべきこと」が保存されている情報が「デバッグ情報」</li>
<li>デバッグ情報を生成するのはコンパイラやリンカの役目</li>
<li>ソースの情報を直接知れるのはコンパイラのみ</li>
<li>リンカは再配置に伴う処理や重複情報の削除</li>
<li>デバッグ情報の課題、あるいは、デバッガにとっての難問</li>
<li>最適化:</li>
<li>ソースの原型をとどめない機械語: 対応がめちゃくちゃ、ソースと機械語の対応は1対1ではない、インライン展開</li>
<li>不要な変数は消される</li>
<li>消されなかった変数もどこへ行った</li>
<li>メモリ上になかったりレジスタも関数呼び出しを挟んで同じ変数が別のレジスタになっているかもしれない</li>
<li>RISC の台頭: デバッグ中でも最適化を切れない</li>
<li>アセンブラさえも命令の並べ替えを行うことがある (例: 遅延スロット)</li>
<li>デバッガがソースを再現するための全ての情報は、通常は非常に巨大になる: ディスクを圧迫する、メモリにはとても乗らない</li>
<li>これをなんとかして小さくしないといけない</li>
<li>DWARF の特徴: オープンかつフリー、デバッグフォーマットとして優秀、実際に広く使われている</li>
<li><a href="http://www.dwarfstd.org/">http://www.dwarfstd.org/</a></li>
<li>GFDL</li>
<li>DWARF の歴史</li>
<li>1992 に Version 1</li>
<li>現在は 2017.2 リリースの Version 5</li>
<li>他のデバッグ形式: STABS, *COFF, PDB, IEEE695</li>
<li>DWARF の精神: 何にも依存しない、暗黙ではなく明示、ゆるい標準、ベンダー拡張対応、より小さなデータ表現、効率的に処理できる</li>
<li>DWARF の目標</li>
<li>DWARF はなぜ難しいのか?: 日本語の情報も英語の情報も少ない、より小さなデータ表現</li>
<li>圧縮について確認</li>
<li>DWARF フォーマット解説</li>
<li>重要な用語</li>
<li>LEB128 (Little Endian Base 128)</li>
<li>uLEB128 (unsigned LEB128、符号なし)</li>
<li>sLEB128 (signed LEB128、符号付き)</li>
<li>CU (Compilation Unit)</li>
<li>翻訳単位</li>
</ul>


<h2>休憩</h2>

<p>時間がおしているので短めに</p>

<h2>バイナリかるた体験</h2>

<ul>
<li><a href="http://kozos.jp/binary-karuta/">http://kozos.jp/binary-karuta/</a></li>
<li><a href="http://amzn.to/2eYaTnn">0と1のコンピュータ世界 バイナリで遊ぼう!</a> という本に解説あり</li>
<li>説明があった後、「バイナリかるたのサンプル」の「スライド」をみながら実際に何のファイルなのかという話をしていました。</li>
<li>最後までいかなくても、問題の区切りで終了できるので、最後のセッションに最適だそうで、時間があまりなかったこともあって、スライドの途中で終了しました。</li>
</ul>


<h2>クロージング、後片付け</h2>

<ul>
<li>振り返り</li>
<li>振り返りの中の意見であったライブコーディング (とは言ってなかったけど) がよかったというのは同感でした。</li>
<li>資料は ELF の方も DWARF の方も後日公開してもらえるということでした。バイナリかるたはサイトをみながらだったので、特に別途用意された資料はありませんでした。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第78回 Ruby関西 勉強会に参加しました]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-29-rubykansai78.html"/>
    <updated>2017-07-29T13:04:59+09:00</updated>
    <id>http://blog.n-z.jp/blog/rubykansai78</id>
    <content type="html"><![CDATA[<p><a href="https://rubykansai.doorkeeper.jp/events/62491">第78回 Ruby関西 勉強会</a>
に参加しました。</p>

<!--more-->


<p>以下、そのメモです。</p>

<h2>会場</h2>

<p>グランフロントでわかりにくい場所でしたが、きたことがあったので、すんなり来れました。
会場無線 LAN も前回の設定のまま使えました。</p>

<h2>rails にコントリビュートしてきました</h2>

<ul>
<li>integration test は get などを使う</li>
<li>system test は visit などを使う</li>
<li>system test のクラスは integration test のクラスを継承しているので get が使えて何も起こらなくてはまった</li>
<li>メソッドを消す pull request を送った</li>
<li>迷ったらとりあえず送ってみてリジェクトされても気にしない</li>
<li>英語もだいたいなんとかなる</li>
</ul>


<h2>GitLab + Dokku で作る CI/CD 環境</h2>

<p>発表資料はいつも通り<a href="">github</a>, <a href="https://slide.rabbit-shocker.org/authors/znz/rubykansai78-gitlab-dokku/">Rabbit Slide Show</a>, <a href="https://www.slideshare.net/znzjp/gitlab-dokku-cicd">slideshare</a>, <a href="https://speakerdeck.com/znz/cd-huan-jing">Speaker Deck</a>, <a href="https://rubygems.org/gems/rabbit-slide-znz-rubykansai78-gitlab-dokku">RubyGems</a> にあげています。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>の一覧へのリンクを発表直前に追加したので、GitHub のソース以外には7月30日になってから反映しました。</p>

<iframe src="https://slide.rabbit-shocker.org/authors/znz/rubykansai78-gitlab-dokku/viewer.html"
        width="640" height="524"
        frameborder="0"
        marginwidth="0"
        marginheight="0"
        scrolling="no"
        style="border: 1px solid #ccc; border-width: 1px 1px 0; margin-bottom: 5px"
        allowfullscreen> </iframe>


<div style="margin-bottom: 5px">
  <a href="https://slide.rabbit-shocker.org/authors/znz/rubykansai78-gitlab-dokku/" title="GitLab + Dokku で作る CI/CD 環境">GitLab + Dokku で作る CI/CD 環境</a>
</div>


<h2>AM/PMって知ってます？</h2>

<ul>
<li>acquisition (獲得) metaphor</li>
<li>participation (参加) metaphor</li>
</ul>


<h2>rubocopとの付き合い方　〜守・破・離〜</h2>

<ul>
<li>コードレビュー</li>
<li>新人教育, 品質向上, 相互学習</li>
<li><a href="http://d.hatena.ne.jp/naoya/20140313/1394664578">些末なコードレビュー - naoyaのはてなダイアリー</a> の &ldquo;やらなければいけないのは、「その設計は拡張に対して開いていないから開くべき」とか「これではエッジケースが想定されていないからこういう不具合につながるのでは」とか「そのテストでは後日見返したときに第三者が要求仕様を解釈しづらい」とかそういう指摘である。&rdquo;</li>
<li>&ldquo;lint ツールか何かで機械的にチェックすればよい&rdquo;</li>
<li><a href="https://github.com/bbatsov/ruby-style-guide">https://github.com/bbatsov/ruby-style-guide</a></li>
<li>Cop: StyleCop, LayoutCop, LintCop, MetricsCop, PerformanceCop, SecurityCop, RailsCop, BundlerCop</li>
<li>auto-correct</li>
<li>Todo リスト: <code>rubocop --auto-gen-config</code></li>
<li>守・破・離</li>
<li>houndci, sideci など</li>
<li>エディタ連携, guard-rubocop</li>
<li>syntastic だと非同期処理してくれなくて保存の度に固まるので deoplete (+neovim) を使っている</li>
<li>rails developer meetup, 次回: 8/24(木)19:30から, connpass での募集は8/1から, ハッシュタグ <code>#railsdm</code></li>
</ul>


<h2>Ruby と C# をつなぐ</h2>

<ul>
<li><a href="https://github.com/masoo/ruby-csharp_script">https://github.com/masoo/ruby-csharp_script</a></li>
<li>Ruby から C# を使う話だった</li>
<li>色々大変そうだった</li>
</ul>


<h2>RubyはPythonにしてやられてはいない</h2>

<ul>
<li>Ruby ビジネスフォーラムに参加した</li>
<li>午後のパネルディスカッションの内容の紹介</li>
<li>午前の基調講演の内容の紹介</li>
<li>その他イベント紹介</li>
</ul>


<h2>Ruby 初級者向けレッスン 61回 - 文字列</h2>

<p>安定したいつものような内容でした。</p>

<h2>クロージング</h2>

<ul>
<li>イベント告知など</li>
<li>明日同じ場所で<a href="https://techplay.jp/event/626491">ELFとDWARF勉強会</a></li>
<li><a href="https://dddrb.doorkeeper.jp/events/63433">DDD.rb #14 Redux で気軽に始める テスト駆動開発 - DDD.rb | Doorkeeper</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shinosaka.rb #27 (GraphQL) に参加した]]></title>
    <link href="http://blog.n-z.jp/blog/2017-06-24-shinosaka-rb-graphql.html"/>
    <updated>2017-06-24T13:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/shinosaka-rb-graphql</id>
    <content type="html"><![CDATA[<p><a href="https://shinosakarb.doorkeeper.jp/events/61090">Shinosaka.rb #27</a> に参加しました。
Shinosaka.rb 自体は初参加でした。</p>

<p>今回は GraphQL の解説と node と rails でのハンズオンでした。</p>

<!--more-->


<p>以下、メモです。</p>

<h2>メモ</h2>

<ul>
<li><a href="http://www.kokuchpro.com/event/tddbcosaka4/">TDDBC大阪4.0 2017年7月1日（大阪府） - こくちーずプロ（告知'sプロ）</a></li>
<li><a href="https://management30.doorkeeper.jp/events/61787">［認定証発行］アジャイル・リーダーシップとチェンジ・マネジメント・ワークショップ（Management 3.0） - Management 3.0（アジャイル・リーダーシップ、チェンジ･マネジメント、イノベーション・マネジメント） | Doorkeeper</a></li>
<li>自己紹介</li>
<li>QraphQL とは?</li>
<li>単一のエンドポイント</li>
<li>ライブラリーもいろんな言語や環境に対応している</li>
<li>REST API がツライから</li>
<li>GraphQL の微妙な点: pagination, 認証も考慮されていない</li>
<li>React との相性が良い: データ駆動</li>
<li>GitHub が GraphQL を採用: <a href="https://developer.github.com/v4/explorer/">https://developer.github.com/v4/explorer/</a></li>
<li><a href="http://graphql.org/">http://graphql.org/</a></li>
</ul>


<h2>動作確認環境</h2>

<ul>
<li>macOS Sierra 10.12.5</li>
<li>node v8.1.2</li>
<li>npm 5.0.3</li>
<li>graphql などのバージョン: <a href="https://github.com/znz/getting_started_graphql">https://github.com/znz/getting_started_graphql</a> を参照</li>
<li>ruby ruby 2.3.3p222 (2016-11-21 revision 56859) [x86_64-darwin15]</li>
<li>Bundler version 1.15.1</li>
<li>Rails 5.1.1</li>
<li>graphql 1.6.4, graphiql-rails 1.4.2</li>
<li>その他: <a href="https://github.com/znz/getting_started_graphql_ruby">https://github.com/znz/getting_started_graphql_ruby</a> を参照</li>
</ul>


<h2>ソースコード</h2>

<ul>
<li>node 版は <a href="https://github.com/znz/getting_started_graphql">https://github.com/znz/getting_started_graphql</a> を参照</li>
<li>Rails 版は <a href="https://github.com/znz/getting_started_graphql_ruby">https://github.com/znz/getting_started_graphql_ruby</a> を参照</li>
</ul>


<p>途中での graphiql での確認方法は下の作業メモの方に書いてあるので、あわせて参照してください。</p>

<h2>感想</h2>

<p>作業メモが長く続くので、先に感想を書いておきます。</p>

<p>node の方はエラーも json で帰ってきてブラウザーで見えて開発環境として使いやすそうな感じでしたが、
graphiql-rails の方はエラーの時に <code>SyntaxError: Unexpected token &lt; in JSON at position 0</code> とだけ出て、
詳細はサーバー側のログをみないといけないので、node に比べるとちょっと使いづらいかもしれない、と思いました。</p>

<p>GraphQL 自体は色々と利点も多そうだと思いましたが、サーバー側は結局 REST とは別に作り込まないといけなさそうで、
アクセス権限などを考えると、既存のアプリケーションで簡単に置き換えられるものでもなさそうかな、と思いました。</p>

<h2>実際に使ってみる</h2>

<ul>
<li><a href="http://graphql.org/code/">http://graphql.org/code/</a></li>
<li>npm init -y</li>
<li>npm install graphql</li>
</ul>


<h2>step 1</h2>

<p>index.js として以下の内容を作成:</p>

<pre><code>'use strict'

const { graphql, buildSchema } = require('graphql')

const schema = buildSchema(`
type Query {
  foo: String
}

type Schema {
  query: Query
}
`)

const resolvers = {
  foo: () =&gt; 'bar',
}

const query = `
query myQuery {
  foo
}
`

graphql(schema, query, resolvers)
  .then(result =&gt; console.log(result))
  .catch(err =&gt; console.log(err))
</code></pre>

<p>実行結果:</p>

<pre><code>% node.index.js
{ data: { foo: 'bar' } }
</code></pre>

<h2>step 2</h2>

<pre><code>const schema = buildSchema(`
type Query {
  id: ID,
  title: String,
  watched: Boolean,
}

type Schema {
  query: Query
}
`)
</code></pre>

<pre><code>const resolvers = {
  id: () =&gt; 1,
  title: () =&gt; 'bar',
  watched: () =&gt; true,
}
</code></pre>

<pre><code>const query = `
query myQuery {
  id,
  title,
  watched,
}
`
</code></pre>

<pre><code>% node index.js
{ data: { id: '1', title: 'bar', watched: true } }
</code></pre>

<p>query から watched を削ると <code>{ data: { id: '1', title: 'bar' } }</code> になる。</p>

<h2>step 3</h2>

<pre><code>const schema = buildSchema(`
type Video {
  id: ID,
  title: String,
  watched: Boolean,
}

type Query {
  video: Video
}

type Schema {
  query: Query
}
`)
</code></pre>

<pre><code>const resolvers = {
  video: () =&gt;({
    id: 1,
    title: 'bar',
    watched: true
  }),
}
</code></pre>

<pre><code>const query = `
query myQuery {
  video {
    id,
    title,
    watched,
  }
}
`
</code></pre>

<h2>step 4</h2>

<p>videos 対応</p>

<pre><code>const schema = buildSchema(`
type Video {
  id: ID,
  title: String,
  watched: Boolean,
}

type Query {
  video: Video,
  videos: [Video],
}

type Schema {
  query: Query
}
`)
</code></pre>

<pre><code>const videoA = {
  id: 1,
  title: 'title1',
  watched: true
}
const videoB = {
  id: 2,
  title: 'title2',
  watched: false
}
const videos = [videoA, videoB]
</code></pre>

<pre><code>const resolvers = {
  video: () =&gt; ({
    id: 1,
    title: 'bar',
    watched: true,
  }),
  videos: () =&gt; videos,
}
</code></pre>

<pre><code>const query = `
query myQuery {
  videos {
    id,
    title,
    watched,
  }
}
`
</code></pre>

<pre><code>% node index.js
{ data: { videos: [ [Object], [Object] ] } }
</code></pre>

<h2>step 5</h2>

<p><code>yarn add express express-graphql</code> or <code>npm install express express-graphql</code></p>

<p><code>require('graphql')</code> の行の上に追加:</p>

<pre><code>const express = require('express')
const graphqlHTTP = require('express-graphql')
</code></pre>

<p>追加:</p>

<pre><code>const PORT = process.env.PORT || 3000
const server = express()
</code></pre>

<p>末尾の <code>graphql</code> の呼び出しを置き換え:</p>

<pre><code>server.use('/graphql', graphqlHTTP({
  schema,
  graphiql: true,
  rootValue: resolvers,
}))

server.listen(PORT, () =&gt; {
  console.log(`Listening on http://localhost:${PORT}`)
})
</code></pre>

<p><code>http://localhost:3000/graphql</code> を開いて</p>

<pre><code>{
  videos {
    id,
    title,
    watched,
  }
}
</code></pre>

<p>などを試す。</p>

<p>右上の Docs でスキーマも見える。</p>

<h2>step 6</h2>

<p>graphql の require のところを書き換え:</p>

<pre><code>const {
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLID,
  GraphQLString,
  GraphQLBoolean,
} = require('graphql')
</code></pre>

<p>buildSchema を書き換え:</p>

<pre><code>const videoType = new GraphQLObjectType({
  name: 'Video',
  description: 'video',
  fields: {
    id: {
      type: GraphQLID,
      description: 'id of video',
    },
    title: {
      type: GraphQLString,
      description: 'title of video'
    },
    watched: {
      type: GraphQLBoolean,
      description: 'has watched'
    }
  }
})
</code></pre>

<pre><code>const queryType = new GraphQLObjectType({
  name: 'QueryType',
  description: 'root query',
  fields: {
    video: {
      type: videoType,
      resolve: () =&gt; new Promise(resolve =&gt; {
        resolve({
          id: 1,
          title: 'title1',
          watched: true,
        })
      })
    }
  }
})
</code></pre>

<pre><code>const schema = new GraphQLSchema({
  query: queryType,
})
</code></pre>

<p><code>node index.js</code> を再起動して <code>http://localhost:3000/graphql</code> で</p>

<pre><code>{
  video {
    id
    title
    watched
  }
}
</code></pre>

<p>などを試す。</p>

<h2>休憩</h2>

<h2>id: 1 だけ欲しいときなど</h2>

<p>videos を移動して data.js を作成:</p>

<pre><code>'use strict'

const videoA = {
  id: 1,
  title: 'title1',
  watched: true
}
const videoB = {
  id: 2,
  title: 'title2',
  watched: false
}
const videos = [videoA, videoB]

const getVideoById = (id) =&gt; new Promise(resolve =&gt; {
  const [video] = videos.filter(v =&gt; (v.id + '') === id)
  resolve(video)
})

exports.getVideoById = getVideoById
</code></pre>

<pre><code>const { getVideoById } = require('./data')
</code></pre>

<pre><code>const queryType = new GraphQLObjectType({
  name: 'QueryType',
  description: 'root query',
  fields: {
    video: {
      type: videoType,
      args: {
        id: {
          type: GraphQLID,
          description: 'id of video',
        },
      },
      resolve: (_, args) =&gt; getVideoById(args.id)
    }
  }
})
</code></pre>

<p><code>node index.js</code> を再起動して <code>http://localhost:3000/graphql</code> で</p>

<pre><code>{
  video(id: 2) {
    id
    title
    watched
  }
}
</code></pre>

<p>などを試す。</p>

<h2>id を必須にしたい</h2>

<p><code>require('graphql')</code> のところに <code>GraphQLNonNull,</code> を追加。</p>

<p><code>type: new GraphQLNonNull(GraphQLID),</code> にする。</p>

<pre><code>{
  "errors": [
    {
      "message": "Unknown operation named \"null\"."
    }
  ]
}
</code></pre>

<p>になってしまったが、 getVideos の追加の後、もう一度試したら動いたので謎。
謎のエラーが発生した時は Prettify を押すとエラーが起きなくなるみたい。</p>

<pre><code>{
  video {
    id
    title
    watched
  }
}
</code></pre>

<p>などを試すと以下のように意図通りのエラーになる。</p>

<pre><code>{
  "errors": [
    {
      "message": "Field \"video\" argument \"id\" of type \"ID!\" is required but not provided.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ]
    }
  ]
}
</code></pre>

<h2>配列</h2>

<p><code>GraphQLList</code> を追加</p>

<p>data.js に追加:</p>

<pre><code>const getVideos = () =&gt; new Promise(resolve =&gt; resolve(videos))
</code></pre>

<pre><code>exports.getVideos = getVideos
</code></pre>

<p>index.js:</p>

<pre><code>const { getVideoById, getVideos } = require('./data')
</code></pre>

<pre><code>    videos: {
      type: new GraphQLList(videoType),
      resolve: getVideos,
    },
</code></pre>

<p><code>node index.js</code> を再起動して <code>http://localhost:3000/graphql</code> で</p>

<pre><code>{
  videos {
    id
    title
    watched
  }
}
</code></pre>

<p>などを試す。</p>

<h2>mutation</h2>

<p>schema に mutation を追加:</p>

<pre><code>const schema = new GraphQLSchema({
  query: queryType,
  mutation: mutationType,
})
</code></pre>

<p>schema の上に追加:</p>

<pre><code>const mutationType = new GraphQLObjectType({
  name: 'Mutation',
  description: 'Mutation type',
  fields: {
    createVideo: {
      type: videoType,
      args: {
        title: {
          type: new GraphQLNonNull(GraphQLString),
          description: 'title of video',
        },
      },
      resolve: (_, args) =&gt; {
        return createVideo(args)
      }
    },
  },
})
</code></pre>

<p>data.js:</p>

<pre><code>const createVideo = ({ title }) =&gt; {
  const maxId = Math.max.apply(null, videos.map(v =&gt; v.id))
  const watched = false
  const video = {
    id: maxId + 1,
    title,
    watched,
  }
  return video
}
</code></pre>

<p>(videos への push が抜けていた。)</p>

<pre><code>exports.createVideo = createVideo
</code></pre>

<p>index.js:</p>

<pre><code>const { getVideoById, getVideos, createVideo } = require('./data')
</code></pre>

<p><code>node index.js</code> を再起動して <code>http://localhost:3000/graphql</code> で</p>

<pre><code>mutation M {
  createVideo(title: "hoge") {
    id
    title
    watched
  }
}
</code></pre>

<p>を試す。</p>

<p>この時点の index.js:</p>

<pre><code>'use strict'

const express = require('express')
const graphqlHTTP = require('express-graphql')
const {
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLID,
  GraphQLString,
  GraphQLBoolean,
  GraphQLNonNull,
  GraphQLList,
} = require('graphql')
const { getVideoById, getVideos, createVideo } = require('./data')

const PORT = process.env.PORT || 3000
const server = express()

/*
video
  id
  title
  watched
*/

const videoType = new GraphQLObjectType({
  name: 'Video',
  description: 'video',
  fields: {
    id: {
      type: GraphQLID,
      description: 'id of video',
    },
    title: {
      type: GraphQLString,
      description: 'title of video'
    },
    watched: {
      type: GraphQLBoolean,
      description: 'has watched'
    }
  }
})

const queryType = new GraphQLObjectType({
  name: 'QueryType',
  description: 'root query',
  fields: {
    videos: {
      type: new GraphQLList(videoType),
      resolve: getVideos,
    },
    video: {
      type: videoType,
      args: {
        id: {
          type: new GraphQLNonNull(GraphQLID),
          description: 'id of video',
        }
      },
      resolve: (_, args) =&gt; getVideoById(args.id)
    }
  }
})

const mutationType = new GraphQLObjectType({
  name: 'Mutation',
  description: 'Mutation type',
  fields: {
    createVideo: {
      type: videoType,
      args: {
        title: {
          type: new GraphQLNonNull(GraphQLString),
          description: 'title of video',
        },
      },
      resolve: (_, args) =&gt; {
        return createVideo(args)
      }
    },
  },
})

const schema = new GraphQLSchema({
  query: queryType,
  mutation: mutationType,
})

server.use('/graphql', graphqlHTTP({
  schema,
  graphiql: true,
}))

server.listen(PORT, () =&gt; {
  console.log(`Listening on http://localhost:${PORT}`)
})
</code></pre>

<p>data.js:</p>

<pre><code>'use strict'

const videoA = {
  id: 1,
  title: 'title1',
  watched: true
}
const videoB = {
  id: 2,
  title: 'title2',
  watched: false
}
const videos = [videoA, videoB]

const getVideos = () =&gt; new Promise(resolve =&gt; resolve(videos))

const createVideo = ({ title }) =&gt; {
  const maxId = Math.max.apply(null, videos.map(v =&gt; v.id))
  const watched = false
  const video = {
    id: maxId + 1,
    title,
    watched,
  }
  videos.push(video)
  return video
}

const getVideoById = (id) =&gt; new Promise(resolve =&gt; {
  const [video] = videos.filter(v =&gt; (v.id + '') === id)
  resolve(video)
})

exports.getVideoById = getVideoById
exports.getVideos = getVideos
exports.createVideo = createVideo
</code></pre>

<h2>createVideo の args を分離したい</h2>

<p>require のところに <code>GraphQLInputObjectType,</code> を追加。</p>

<pre><code>const videoInputType = new GraphQLInputObjectType({
  name: 'VideoInputType',
  description: 'video input type',
  fields: {
    title: {
      type: new GraphQLNonNull(GraphQLString),
      description: 'title of video',
    },
  }
})

const mutationType = new GraphQLObjectType({
  name: 'Mutation',
  description: 'Mutation type',
  fields: {
    createVideo: {
      type: videoType,
      args: {
        video: {
          type: new GraphQLNonNull(videoInputType)
        },
      },
      resolve: (_, args) =&gt; {
        return createVideo(args.video)
      }
    },
  },
})
</code></pre>

<p><code>node index.js</code> を再起動して <code>http://localhost:3000/graphql</code> で</p>

<pre><code>mutation M {
  createVideo(video: {title: "hoge"}) {
    id
    title
    watched
  }
}
</code></pre>

<p>を試す (<code>video:</code> で一段増えているので注意)</p>

<pre><code>{
  videos {
    id
    title
  }
}
</code></pre>

<p>などを試す。</p>

<h2>休憩</h2>

<h3>createVideo も Promise にするとどうか</h3>

<p>createVideo の末尾を <code>return Promise.resolve(video)</code> にしても問題なく動いた。</p>

<h2>ruby でどうか</h2>

<ul>
<li><code>rails new getting_started_graphql_ruby</code></li>
<li><a href="http://graphql-ruby.org/getting_started">http://graphql-ruby.org/getting_started</a></li>
<li>Gemfile に <code>gem 'graphql'</code> を追加</li>
<li><code>bundle install</code></li>
<li><code>rails g graphql:install</code></li>
<li>Gemfile に <code>graphiql-rails</code> が追加されているので <code>bundle install</code></li>
</ul>


<h2>video 追加</h2>

<ul>
<li><code>rails g graphql:object Video id:Int title:String watched:Boolean</code></li>
<li>id は Int ではなく ID が正しいので <code>rails d graphql:object Video id:Int title:String watched:Boolean</code> で消してやり直し</li>
<li><code>rails g graphql:object Video id:ID title:String watched:Boolean</code></li>
<li><code>app/graphql/types/query_type.rb</code> を変更</li>
</ul>


<pre><code>  field :video do
    type Types::VideoType
    argument :id, !types.ID
    description 'Find video by ID'
    resolve -&gt;(obj, args, ctx) { Video.find(args["id"]) }
  end
</code></pre>

<p><code>rails s</code> を起動して <code>http://localhost:3000/graphiql</code> (express-graphql での例と違って <code>/graphql</code> ではなく <code>i</code> が入る) で</p>

<pre><code>{
  video(id: 1) {
    id
    title
  }
}
</code></pre>

<p>を試すと server 側で <code>NameError (uninitialized constant Video):</code> になるのを確認。</p>

<ul>
<li><code>rails g model video title watched:boolean</code></li>
<li><code>rake db:migrate</code></li>
<li><code>rails c</code> で <code>Video.create(title: "Hoge", watched: false)</code> などでレコードを作成しておく</li>
<li>graphiql で試す</li>
</ul>


<pre><code>{
  video(id: 1) {
    id
    title
    watched
  }
}
</code></pre>

<h2>mutation</h2>

<ul>
<li><code>app/graphql/mutations/create_video.rb</code></li>
</ul>


<pre><code># 動かない
Mutations::CreateVideo = GraphQL::Relay::Mutation.define do
  name "CreateVideo"

  return_field :video, Types::VideoType

  input_field :title, !types.String

  resolve -&gt;(obj, args, ctx) {
    return Video.create(title: args["title"])
  }
end
</code></pre>

<ul>
<li><code>app/graphql/getting_started_graphql_ruby_schema.rb</code> に <code>mutation(Mutations::CreateVideo)</code> を追加</li>
<li><code>GraphQL::Schema::InvalidTypeError (CreateVideo has an invalid type: must be an instance of GraphQL::BaseType, not GraphQL::Relay::Mutation</code> になってうまくいかない</li>
<li><code>rails g graphql:mutation</code> は relay mutation 用で違うらしい</li>
</ul>


<h2>クライアント</h2>

<ul>
<li><a href="http://dev.apollodata.com/react/">http://dev.apollodata.com/react/</a> が redux っぽくてしっくりきたらしい。</li>
<li>rack-cors の設定が必要?</li>
<li><a href="https://github.com/facebook/relay">https://github.com/facebook/relay</a></li>
</ul>


<h2>mutation の動くコード例</h2>

<p>rito さんに動く例をみせてもらって修正。</p>

<p><code>app/graphql/mutations/video.rb</code>:</p>

<pre><code>Mutations::Video = GraphQL::ObjectType.define do
  name "mutation"

  field :video, Types::VideoType do
    description "Create a video"
    argument :title, !types.String

    resolve -&gt;(obj, args, ctx) {
      Video.create(title: args["title"], watched: false)
    }
  end
end
</code></pre>

<p>(<code>name "Video"</code> にすると <code>Duplicate type definition found for name 'Video'</code> で動かなかった。)</p>

<p><code>app/graphql/getting_started_graphql_ruby_schema.rb</code>:</p>

<pre><code>GettingStartedGraphqlRubySchema = GraphQL::Schema.define do
  query(Types::QueryType)
  mutation(Mutations::Video)
end
</code></pre>

<p><code>http://localhost:3000/graphiql</code> で以下を試す。</p>

<pre><code>mutation M {
  video(title: "foo") {
    id
    title
    watched
  }
}
</code></pre>

<pre><code>{
  video(id: 2) {
    id
    title
    watched
  }
}
</code></pre>

<p>追加されたのがみえたら OK</p>

<p>時間切れで試せなかったけど、 mutation を複数追加する場合はどうなるのかがわからなかった。</p>
]]></content>
  </entry>
  
</feed>
