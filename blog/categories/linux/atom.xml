<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2017-07-09T14:24:12+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GitLab Runner の設定]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-09-gitlab-runner.html"/>
    <updated>2017-07-09T14:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/gitlab-runner</id>
    <content type="html"><![CDATA[<p>GitLab と Dokku (と一部 Heroku) を使って CI/CD (Continuous Integration / Continuous Deployment) 環境を作ってみた話の続きです。
CI 部分のメインとなる GitLab Runner の設定の話です。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Ubuntu 16.04.2 LTS</li>
<li>Omnibus GitLab 9.1.4-ce.0 (インストール時) から 9.3.5-ce.0 (記事執筆時)</li>
<li>gitlab-ci-multi-runner 9.2.0 (インストール時) から 9.3.0 (記事執筆時)</li>
<li>Dokku 0.9.4 (インストール時) から 0.10.2 (記事執筆時)</li>
</ul>


<h2>GitLab Runner とは?</h2>

<p><a href="https://docs.gitlab.com/runner/">GitLab Runner</a> とは GitLab CI のジョブを実行する部分のことです。</p>

<p>Jenkins でいうと (ジョブを実行しない設定にした) master が GitLab CI で、 slave が GitLab Runner に相当します。</p>

<h2>名前について</h2>

<p>昔は gitlab-ci-multi-runner という名前だったらしく、 repository は <a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner">https://gitlab.com/gitlab-org/gitlab-ci-multi-runner</a> になっています。</p>

<p>GitLab CI は GitLab 8.x の時に GitLab 本体に統合されたということで、古いドキュメントを参照するときは注意が必要そうです。</p>

<h2>executor 選択</h2>

<p>GitLab Runner を入れたマシン上で直接実行する Shell executor や Docker で実行する Docker executor などがありますが、一番簡単で便利そうな Docker executor を使うことにしました。
また、管理を簡単にするために全てのプロジェクトで共通の Runner を使うことにしました。</p>

<p>必要なら複数登録してタグで使い分けることもできます。
プロジェクトごとに使い分けることもできます。</p>

<h2>インストール</h2>

<p>GitLab とは別マシンが推奨のようなので、別仮想マシンを用意しました。
<a href="https://docs.gitlab.com/runner/install/linux-repository.html">Install GitLab Runner using the official GitLab repositories</a> の方法でパッケージをインストールしました。</p>

<p>「Note: Debian users should use APT pinning」とありますが、<a href="https://packages.debian.org/gitlab-ci-multi-runner">Debian の gitlab-ci-multi-runner パッケージ</a>をみてもリリースされた Stretch には入っていないようです。<a href="https://packages.ubuntu.com/gitlab-ci-multi-runner">Ubuntu の gitlab-ci-multi-runner パッケージ</a>も xenial (16.04LTS) には入っていないようなので、 APT pinning はなくても良さそうです。(今回の設定では念のため入れています。)</p>

<h2>GitLab CI に登録</h2>

<p><a href="https://docs.gitlab.com/runner/register/index.html">Registering Runners</a> に書いてあるように <code>sudo gitlab-runner register</code> で登録します。
オプションなしで実行すると対話的にいろいろきかれます。</p>

<p>gitlab-ci coordinator URL は古いドキュメントだと <code>/ci</code> が付いていることがあるようですが、今はあってもなくてもどちらでも大丈夫のようです。</p>

<p>自動設定するなら token は GitLab 側の初期設定をする時に <code>gitlab_rails['initial_shared_runners_registration_token']</code> で固定しておくと良いと思います。</p>

<p>タグを空欄にした場合はタグなしのジョブも実行されるのですが、タグを設定した場合は run untagged jobs も設定しておかないとジョブが実行されなくて悩むことになります。
(タグは GitLab の Web UI で後から空欄にできなくて、実行されない条件を絞り込むのに unregister して register し直す必要があって面倒だったのですが、当時のバージョンのバグだったのか、GitLab 9.3.5 では問題なく空欄に変更できました。)</p>

<p>Docker executor を選んだ時のデフォルトの Docker image は <code>hello-world</code> ぐらいの使いにくいものにしておいて、 <code>.gitlab-ci.yml</code> で image を常に指定する方が Runner の設定に影響されないので無難かもしれません。</p>

<h2>GitLab CI から登録解除</h2>

<p><code>gitlab-runner list</code> で token などを確認して <code>gitlab-runner unregister</code> で登録解除できます。</p>

<p>unregister せずに GitLab Runner がいなくなってしまった場合は GitLab の Admin Area の Runners から Remove できます。</p>

<h2>同時実行数指定</h2>

<p><code>/etc/gitlab-runner/config.toml</code> の <code>concurrent =</code> で同時に実行するジョブ数を指定できます。
自動で再読み込みしているらしく、試した感じだと runner の restart をしなくても設定が反映されるようでした。</p>

<h2>.gitlab-ci.yml の Lint</h2>

<p><a href="http://qiita.com/sei40kr/items/407e08cc45f218738d4c">GitLab CIの設定ファイルを手元でLintする</a>によると <code>/api/v4/ci/lint</code> で Lint できるようなので、 curl と jq をインストールしておいて、</p>

<pre><code>linter_api_url='https://gitlab.com/api/v4/ci/lint'
curl -sH 'Content-Type: application/json' "$linter_api_url" -d "$(jq -Rs '{"content":.}' &lt; .gitlab-ci.yml)" | jq
</code></pre>

<p>のようにすれば良いようです。</p>

<p><code>linter_api_url</code> を自前の GitLab の URL にしておけば外部に送信することなく Lint できます。</p>

<h2>GitLab Container Registry と連携</h2>

<p>Docker executor を使って GitLab Container Registry を扱いたい場合、 Docker executor と同じホスト側の docker を使う方法と docker in docker を使う方法があります。</p>

<p>詳細は <a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html">Using Docker Build</a> を参考にしてください。</p>

<p>GitLab Container Registry にちゃんとした https の証明書が設定できる場合は良いのですが、テスト環境などで http しか有効にできない場合は困ることがあります。</p>

<h3>ホスト側の docker を使う方法</h3>

<p>ホスト側の docker を使うということは、ホスト側の docker の権限を GitLab CI で使えるようにしてしまうということなので、信頼できないユーザーが <code>.gitlab-ci.yml</code> を操作できる環境では使えません。</p>

<p>使い方としては GitLab Runner の register の時に <code>--docker-volumes /var/run/docker.sock:/var/run/docker.sock</code> を指定します。</p>

<p>GitLab Container Registry が http のみの場合は、ホスト側の Docker に insecure-registry の設定をすることになります。</p>

<p><code>/etc/systemd/system/docker.service.d/local.conf</code> などで <code>ExecStart</code> を上書きして設定するか、 <code>/etc/docker/daemon.json</code> に</p>

<pre><code>{"insecure-registries": ["registry.example.test"]}
</code></pre>

<p>のように設定することで http で接続できるようになります。
(daemon.json では<a href="http://docs.docker.jp/engine/reference/commandline/daemon.html#daemon-configuration-file">デーモン設定ファイル</a>に書いてあるようにコマンドラインオプションの <code>--insecure-registry</code> が複数形の <code>"insecure-registries"</code> になります。 <code>dns</code> のように複数形でも変わらないものもあるので、指定できるオプションはドキュメントを参照するのが無難です。)</p>

<h3>docker in docker を使う方法</h3>

<p><code>.gitlab-ci.yml</code> の services に <code>docker:dind</code> を指定して使う、という方法になります。
<code>docker:dind</code> サービスに insecure-registry を設定する方法がないので、試していませんが http のみで使いたい場合は派生 image を自分で作るなどの対応が必要そうです。</p>

<p>使い方としては GitLab Runner の register の時に <code>--docker-privileged</code> を指定します。
register の時に指定し忘れていた場合は、後から config.toml に <code>privileged = true</code> を追加でも良いと思います。</p>

<h3>.gitlab-ci.yml での設定</h3>

<p><a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html">Using Docker Build</a> に書いてあるように</p>

<pre><code>- docker login -u gitlab-ci-token -p $CI_JOB_TOKEN registry.example.com
</code></pre>

<p>か</p>

<pre><code>- docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
</code></pre>

<p>のようにログインした後、 build や push などができるようになります。</p>

<p><code>gitlab-ci-token</code> も固定ではなく環境変数を参照するようにできますが、固定で書いてある設定例が多いので、変わる可能性は低そうなので、固定で書いておいても良いと思います。</p>

<h2>まとめ</h2>

<p>GitLab Runner の設定と Lint の使い方、 GitLab Container Registry と連携方法を紹介しました。
次は Dokku の設定になります。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Omnibus GitLabをContainer RegistryやMattermostを有効にして使う]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-08-omnibus-gitlab.html"/>
    <updated>2017-07-08T16:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/omnibus-gitlab</id>
    <content type="html"><![CDATA[<p>GitLab と Dokku (と一部 Heroku) を使って CI/CD (Continuous Integration / Continuous Deployment) 環境を作ってみたので、何回かにわけてその話を書いていきます。
最初は Omnibus GitLab 自体の設定の話です。
certbot で https を有効にして、 GitLab Container Registry や GitLab Mattermost も有効にします。
GitLab Pages も有効にしますが、 certbot での自動化はできなかったので http のみの設定です。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Ubuntu 16.04.2 LTS</li>
<li>Omnibus GitLab 9.1.4-ce.0 (インストール時) から 9.3.5-ce.0 (記事執筆時)</li>
<li>gitlab-ci-multi-runner 9.2.0 (インストール時) から 9.3.0 (記事執筆時)</li>
<li>Dokku 0.9.4 (インストール時) から 0.10.2 (記事執筆時)</li>
</ul>


<h2>インストール方法選択</h2>

<p><a href="https://about.gitlab.com/installation/">Installation methods for GitLab</a> にある方法のうち、Omnibus package installation (recommended) を選択しました。
理由としては以下のようなことを考慮しました。</p>

<ul>
<li>ソースインストールはインストールもバージョンアップも管理も大変そうなので除外</li>
<li>Docker でのインストールはバージョンを上げて問題がおきた場合に戻しやすそうだが、バージョンアップ情報を自分で追いかけないといけない</li>
<li>Omnibus package は apt で他のパッケージの更新と同様にバージョンアップが検知可能</li>
<li>GitLab 自体は仮想マシン1台で動かすのでバージョンアップ時に停止時間が発生するのは許容</li>
</ul>


<h2>カスタマイズ方法</h2>

<p>Docker イメージは <code>GITLAB_OMNIBUS_CONFIG</code> で、 Omnibus package は <code>/etc/gitlab/gitlab.rb</code> でカスタマイズできます。
(設定できる項目は <a href="https://docs.gitlab.com/omnibus/docker/README.html">https://docs.gitlab.com/omnibus/docker/README.html</a> からリンクされている <a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template">Omnibus GitLab template</a> 参照)</p>

<p>自動構築したい場合は <code>gitlab_rails['initial_root_password']</code> や <code>gitlab_rails['initial_shared_runners_registration_token']</code> が設定できるというのを知っておくと良さそうです。</p>

<p>設定項目によっては Web UI で変更しても <code>sudo gitlab-ctl reconfigure</code> を実行すると再設定されてしまうものもあるようなので、影響しそうな設定を変更するときは気にしておくと良さそうです。
(気づいた範囲では GitLab Mattermost 関係の設定が再設定されました。)</p>

<h2>最低限の設定</h2>

<p>相対時間で表示されることも多いので、デフォルトのままでもあまり気にならないかもしれませんが、</p>

<pre><code>gitlab_rails['time_zone'] = 'Asia/Tokyo'
</code></pre>

<p>でタイムゾーンの設定をしておくと良いと思います。</p>

<h2>メール設定</h2>

<p><a href="https://docs.gitlab.com/omnibus/settings/smtp.html">SMTP settings</a> を参考にしてメール送信の設定をしておきます。</p>

<p>以下は SMTP over TLS (smtps) で送信する例です。</p>

<pre><code># https://docs.gitlab.com/omnibus/settings/smtp.html
gitlab_rails['smtp_enable'] = true
gitlab_rails['smtp_address'] = 'smtp.example.com'
gitlab_rails['smtp_port'] = 465
gitlab_rails['smtp_user_name'] = 'username'
gitlab_rails['smtp_password'] = 'password'
gitlab_rails['smtp_tls'] = true
</code></pre>

<p>Mattermost も使うなら一緒に設定しておきます。</p>

<pre><code>mattermost['email_smtp_username'] = 'username'
mattermost['email_smtp_password'] = 'password'
mattermost['email_smtp_server'] = 'smtp.example.com'
mattermost['email_smtp_port'] = 465
mattermost['email_connection_security'] = 'TLS'
mattermost['email_feedback_name'] = 'GitLab Mattermost'
mattermost['email_feedback_email'] = 'email@example.com'
mattermost['support_email'] =  'support@example.com'
</code></pre>

<h2>後で使う変数設定</h2>

<p>config は ruby のコードなので、ローカル変数でドメインをまとめて設定できるようにしておきます。</p>

<pre><code>base_domain = 'example.test'
gitlab_domain = "gitlab.#{base_domain}"
registry_domain = "registry.#{base_domain}"
mattermost_domain = "mattermost.#{base_domain}"
</code></pre>

<h2>https 設定</h2>

<p>GitLab で <a href="https://launchpad.net/~certbot/+archive/ubuntu/certbot">Certbot</a> で <a href="https://letsencrypt.org/">Let&rsquo;s Encrypt - Free SSL/TLS Certificates</a> の証明書を使うので、そのファイルの有無で設定を分岐します。</p>

<p>これで、最初の証明書がない状態や vagrant などでの検証環境では http でつながり、証明書発行後に <code>sudo gitlab-ctl reconfigure</code> すれば https でつながるようになる、という設定が実現できます。</p>

<pre><code>if File.exist?("/etc/letsencrypt/live/#{gitlab_domain}/fullchain.pem")
  external_url "https://#{gitlab_domain}"
  nginx['redirect_http_to_https'] = true
  nginx['ssl_certificate'] = "/etc/letsencrypt/live/#{gitlab_domain}/fullchain.pem"
  nginx['ssl_certificate_key'] = "/etc/letsencrypt/live/#{gitlab_domain}/privkey.pem"
else
  external_url "http://#{gitlab_domain}"
end
nginx['custom_gitlab_server_config'] = 'location ^~ /.well-known { root /var/www/letsencrypt; }'
</code></pre>

<h2>GitLab Container Registry 設定</h2>

<p>Docker の Container Registry の <a href="https://docs.gitlab.com/ce/user/project/container_registry.html">GitLab Container Registry</a> も設定します。
GitLab と同様に証明書の有無で分岐しています。</p>

<p>Container Registry は https を使わない場合、 insecure-registry で困ることになると思います。</p>

<pre><code>if File.exist?("/etc/letsencrypt/live/#{registry_domain}/fullchain.pem")
  registry_external_url "https://#{registry_domain}"
  registry_nginx['redirect_http_to_https'] = true
  registry_nginx['ssl_certificate'] = "/etc/letsencrypt/live/#{registry_domain}/fullchain.pem"
  registry_nginx['ssl_certificate_key'] = "/etc/letsencrypt/live/#{registry_domain}/privkey.pem"
else
  registry_external_url "http://#{registry_domain}"
end
registry_nginx['custom_gitlab_server_config'] = 'location ^~ /.well-known { root /var/www/letsencrypt; }'
</code></pre>

<p>設定はしましたが、今のところ使っていません。</p>

<h2>GitLab Mattermost 設定</h2>

<p>GitLab Mattermost も同様に https の設定をします。</p>

<pre><code>if File.exist?("/etc/letsencrypt/live/#{mattermost_domain}/fullchain.pem")
  mattermost_scheme = "https"
  mattermost_port = 443
  mattermost_external_url "#{mattermost_scheme}://#{mattermost_domain}"
  mattermost_nginx['redirect_http_to_https'] = true
  mattermost_nginx['ssl_certificate'] = "/etc/letsencrypt/live/#{mattermost_domain}/fullchain.pem"
  mattermost_nginx['ssl_certificate_key'] = "/etc/letsencrypt/live/#{mattermost_domain}/privkey.pem"
  mattermost['service_use_ssl'] = true
else
  mattermost_scheme = "http"
  mattermost_port = 80
  mattermost_external_url "#{mattermost_scheme}://#{mattermost_domain}"
end
mattermost_nginx['custom_gitlab_mattermost_server_config'] = 'location ^~ /.well-known { root /var/www/letsencrypt; }'
</code></pre>

<p><a href="https://docs.gitlab.com/omnibus/gitlab-mattermost/#email-batching">Email Batching</a> にはポート番号付きで書いてありますが、ポート番号付きで設定していると Omnibus GitLab 9.2.0 の Mattermost で Bad token type error になってしまってログインできなくなってしまったので、ポート番号なしで設定しています。</p>

<pre><code># required by Email Batching
#mattermost['service_site_url'] = "#{mattermost_scheme}://#{mattermost_domain}:#{mattermost_port}"
# port causes Bad token type error https://github.com/mattermost/platform/issues/6489
mattermost['service_site_url'] = "#{mattermost_scheme}://#{mattermost_domain}"
mattermost['email_enable_batching'] = true
</code></pre>

<p>Mattermost の方だけにアカウントを作れる必要はなかったので、 GitLab 連携のアカウントだけに制限しています。</p>

<pre><code>mattermost['email_enable_sign_in_with_email'] = false # gitlab accounts only
mattermost['email_enable_sign_up_with_email'] = false # default
</code></pre>

<p>チーム作成も GitLab のグループ作成のときに連動して作ることを想定して制限しています。
ただし Admin Area の方からグループを作成しようとすると「Create a Mattermost team for this group」のチェックボックスが出てこないので、 Dashboard の Groups の方から New group で作成する必要があるようです。</p>

<pre><code>mattermost['team_enable_team_creation'] = false
mattermost['team_enable_user_creation'] = true # default, required by GitLab SSO
mattermost['team_restrict_creation_to_domains'] = 'example.com'
</code></pre>

<p>デフォルトの言語設定をしておきます。</p>

<pre><code>mattermost['localization_server_locale'] = 'ja'
mattermost['localization_client_locale'] = 'ja'
</code></pre>

<p>Webhook を有効にします。
このあたりの設定は Web UI から変更しても <code>sudo gitlab-ctl reconfigure</code> すると、こちらの設定が優先されるようです。</p>

<pre><code>mattermost['service_enable_incoming_webhooks'] = true
</code></pre>

<h2>GitLab Pages</h2>

<p><a href="https://docs.gitlab.com/ce/user/project/pages/index.html">GitLab Pages</a> の設定をします。</p>

<p>github.io と同様にグループやユーザーのサブドメインで見えるようになるので、 xip.io や nip.io などのようなワイルドカード DNS を使うのが簡単だと思います。</p>

<pre><code>pages_external_url 'http://10.0.0.10.nip.io'
</code></pre>

<p>この設定で <code>http://hello.10.0.0.10.nip.io/world/</code> などでみえるようになります。</p>

<p>https を使うには証明書と秘密鍵を Web UI から設定する必要があるようなので、自動化は難しそうな印象を受けました。</p>

<h2>機能制限</h2>

<p>デフォルトではグループを作成できないようにしました。</p>

<pre><code># GitLab user privileges
gitlab_rails['gitlab_default_can_create_group'] = false
gitlab_rails['gitlab_username_changing_enabled'] = false
</code></pre>

<p>すべてのプロジェクトですべての機能を使うわけではないので、デフォルトでは無効にしました。</p>

<pre><code># Default project feature settings
gitlab_rails['gitlab_default_projects_features_issues'] = false
gitlab_rails['gitlab_default_projects_features_merge_requests'] = false
gitlab_rails['gitlab_default_projects_features_wiki'] = false
gitlab_rails['gitlab_default_projects_features_snippets'] = false
gitlab_rails['gitlab_default_projects_features_builds'] = false
gitlab_rails['gitlab_default_projects_features_container_registry'] = false
</code></pre>

<h2>certbot 実行</h2>

<p>Ubuntu 16.04.2 LTS にはまだ certbot が含まれていないので、 <a href="https://launchpad.net/~certbot/+archive/ubuntu/certbot">Certbot PPA</a> から certbot パッケージをインストールして、</p>

<pre><code>sudo certbot certonly --webroot --webroot-path=/var/www/letsencrypt -d gitlab.example.jp
sudo certbot certonly --webroot --webroot-path=/var/www/letsencrypt -d registry.example.jp
sudo certbot certonly --webroot --webroot-path=/var/www/letsencrypt -d mattermost.example.jp
</code></pre>

<p>のように証明書を発行して、</p>

<pre><code>sudo gitlab-ctl reconfigure
</code></pre>

<p>で反映させました。</p>

<p>後は certbot の timer で 60 日ごとに証明書が自動更新されるはずです。</p>

<h2>Web から設定</h2>

<p>以上で <code>/etc/gitlab/gitlab.rb</code> での設定や端末での作業は終わりなので、 Web から設定していきます。</p>

<h2>グループ作成</h2>

<p>Mattermost のチーム作成に必要だったので、 GitLab の Administrator (@root) ユーザーには Web UI からグループ作成権限をつけて、 Dashboard の Groups の方から New group で「Create a Mattermost team for this group」のチェックを入れてグループを作成しました。</p>

<p>チェックを入れて作成しても、特にリンクなどはつかないようなので、 Group の Description に <code>https://mattermost.example.jp/</code> の URL を書いておきました。</p>

<h2>GitLab からの通知用 Webhook 設定</h2>

<p>Mattermost のチャンネルのサイドバー3点マークから「統合機能」を選んで「内向きのウェブフック」を追加します。
事前に通知用にチャンネルを作成して、送信先を分離しておくと良いかもしれません。
追加したら URL を控えておきます。</p>

<p>GitLab の Admin area (上のレンチ) を開いて、右上の歯車から「Service Templates」を開きます。
「Mattermost notifications」を選んで「Active」にチェックを入れて、「Webhook」に先ほどの URL を貼り付けます。
できるだけ通知して欲しいので「Notify only broken pipelines」と「Notify only default branch」のチェックは外しました。
最後に「Save」で設定を保存するとプロジェクトを作成する時に自動で通知する設定が入るようになります。</p>

<h2>まとめ</h2>

<p>以上で GitLab の基本的な機能は使えるようになります。
後は GitLab CI (GitLab Runner) の設定と Dokku の設定とバックアップの設定になります。</p>

<p><a href="/blog/categories/gitlab/">gitlab カテゴリー</a>で一覧が見えます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hyper-V のゲスト環境で systemd timer がうまく動いていなかった]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-07-hyperv-systemd-timer.html"/>
    <updated>2017-07-07T00:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/hyperv-systemd-timer</id>
    <content type="html"><![CDATA[<p>Hyper-V のゲストとしてインストールした Linux 環境で systemd timer の <code>RandomizedDelaySec</code> がおかしくて timer が実行されないことがあったのですが、Hyper-V の時刻の同期との相性が悪いのが原因でした。</p>

<!--more-->


<h2>環境</h2>

<ul>
<li>ホスト: Windows Server 2012</li>
<li>ゲスト: Ubuntu 16.04.2 LTS (xenial) と Debian GNU/Linux 9.0 (stretch)</li>
</ul>


<h2>現象</h2>

<p>journalctl で過去のログを確認してみると</p>

<pre><code> 6月 28 12:07:56 hostname systemd[9928]: Time has been changed
 6月 28 12:07:59 hostname systemd[9928]: Time has been changed
 6月 28 12:08:04 hostname systemd[9928]: Time has been changed
 6月 28 12:08:09 hostname systemd[9928]: Time has been changed
 6月 28 12:08:14 hostname systemd[9928]: Time has been changed
 6月 28 12:08:19 hostname systemd[9928]: Time has been changed
</code></pre>

<p>のように Time has been changed が頻繁に記録されていました。</p>

<p>再起動した後からは RandomizedDelaySec が設定されている timer のランダムな時間挿入が Time has been changed の直後におきていました。</p>

<pre><code> 6月 28 15:07:51 hostname systemd[1]: Time has been changed
 6月 28 15:07:51 hostname systemd[1]: apt-daily-upgrade.timer: Adding 46min 16.478521s random time.
 6月 28 15:07:51 hostname systemd[1]: apt-daily.timer: Adding 3h 45min 54.621700s random time.
 6月 28 15:07:56 hostname systemd[1]: Time has been changed
 6月 28 15:07:56 hostname systemd[1]: apt-daily-upgrade.timer: Adding 25min 59.320458s random time.
 6月 28 15:07:56 hostname systemd[1]: apt-daily.timer: Adding 11h 34min 9.012513s random time.
 6月 28 15:08:01 hostname systemd[1]: Time has been changed
 6月 28 15:08:01 hostname systemd[1]: apt-daily-upgrade.timer: Adding 42min 37.932995s random time.
 6月 28 15:08:01 hostname systemd[1]: apt-daily.timer: Adding 4h 48min 31.255279s random time.
 6月 28 15:08:06 hostname systemd[1]: Time has been changed
 6月 28 15:08:06 hostname systemd[1]: apt-daily-upgrade.timer: Adding 13min 44.192537s random time.
 6月 28 15:08:06 hostname systemd[1]: apt-daily.timer: Adding 38min 56.349412s random time.
</code></pre>

<p>自作した timer が実行されなくて <code>journalctl -u local-backup.timer</code> のように調べた時に「Adding &hellip; random time.」のログで埋まっていて、他の動いている timer との違いも特になくて悩んでいましたが、ふと <code>journalctl</code> (引数なし) を実行してみたら「Time has been changed」とセットでおきていることに気づきました。</p>

<h2>解決策</h2>

<p>「Time has been changed」で検索して最初に出てきた <a href="https://askubuntu.com/questions/888493/var-log-syslog-systemd1-time-has-been-changed-message-every-5-seconds">16.04 - /var/log/syslog &lsquo;systemd[1]: Time has been changed&rsquo; message every 5 seconds - Ask Ubuntu</a> に</p>

<blockquote><p>I encountered this issue of &ldquo;systemd[&hellip;]Time has been changed&rdquo; messages logged every five seconds in /var/log/syslog on a 16.04 server running under Windows 8.1 Hyper-V. To fix it, I disabled time synchronization on the Hyper-V side. In Hyper-V Manager, I highlighted the VM, selected &ldquo;Settings&hellip;&rdquo;, then &ldquo;Integration Services&rdquo;, unchecked &ldquo;Time synchronization&rdquo;, and clicked Apply. The messages stopped instantly - no VM restart was required.</p></blockquote>

<p>と書いてあったので、「設定&hellip;」から「統合サービス」の「時刻の同期」のチェックを外して (再起動なしで) 解決しました。</p>

<h2>解決確認</h2>

<p>「Time has been changed」も出なくなって「Adding &hellip; random time.」も出なくなって、翌日まで待ってみるとちゃんと実行されていたので、解決したようです。</p>

<h2>まとめ</h2>

<p>ntp サーバー機能も必要で、 ntp パッケージを入れている環境で発生したので、時刻の同期の仕方によっては発生しないのかもしれませんが、「Time has been changed」で検索して出てきた他の方法はログを無視するだけとか、根本的な解決になっていないものが多そうだったので、Hyper-V との組み合わせなら systemd-timesyncd でも発生するのかもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debian/Ubuntuで暗号化 LVM を使いつつ自動起動する]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-01-cryptsetup.html"/>
    <updated>2017-07-01T14:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/cryptsetup</id>
    <content type="html"><![CDATA[<p>さくらの VPS 環境でも ssh などの秘密鍵を置くなら、ディスクの暗号化は使いたいので、リリースされたばかりの Debian 9 の ISO をアップロードしてインストールして、暗号化されていない <code>/boot</code> に鍵ファイルを置いて自動起動を設定しました。</p>

<p>自動起動を設定するということはセキュリティ的には弱くなりますが、そこはホストを信用するということにしています。</p>

<p>自動起動設定時に <code>/etc/crypttab</code> の設定ミスで起動しなくなるということがあったので、そういう時の直し方も含めてまとめてみました。</p>

<!--more-->


<h2>確認環境</h2>

<ul>
<li>Debian GNU/Linux 9.0 (stretch)</li>
</ul>


<p>Ubuntu でも debian-installer ベースのインストーラーを使った場合は同じだと思います。
(Live 環境が起動するデスクトップ版のインストーラーの場合は暗号化 LVM でのインストールができるかどうか確認していないのでわかりません。)</p>

<p>他のバージョンの Debian でも luks 対応の cryptsetup があれば同じだと思います。</p>

<h2>インストール</h2>

<p>普通に netinst の iso でインストールします。</p>

<p>ただし途中の「ディスクのパーティショニング」で「ガイド - ディスク全体を使い、暗号化 LVM をセットアップする」を選んだ場合が対象です。
パーティションは <code>/</code> (と <code>/boot</code>) だけを想定しています。
暗号化のパスフレーズは鍵ファイル設定前の起動時と、鍵ファイルの追加時などしか使わないので、長くて強いものにしておくと良いと思います。</p>

<p>VirtualBox などの仮想環境で試す時は、暗号化前のランダムなデータで上書きでデータ用のパーティション全体に書き込みが発生するので、可変サイズのディスクではなく固定サイズのディスクにしておくと良いかもしれません。</p>

<h2>鍵ファイル作成</h2>

<p>まず、鍵ファイルを作成します。
内容作成前に root しか読み書きできないようにするために、touch して chmod しておきます。
次に urandom から読んだランダムデータを鍵ファイルに書き込みます。
前回設定したときは count=1 で 1024 バイトにしていましたが、今回は 4096 バイトにしてみました。
最後に root はパーミッションだと書き込み禁止できないので、誤操作防止 (削除やヒストリーから dd を再実行してしまうなど) のために chattr で ext2 の immutable 属性をつけておきます。(確認は <code>sudo lsattr /boot/keyfile</code>)</p>

<pre><code>sudo touch /boot/keyfile
sudo chmod 400 /boot/keyfile
sudo dd if=/dev/urandom of=/boot/keyfile bs=1024 count=4
sudo chattr +i /boot/keyfile
</code></pre>

<h2>情報確認</h2>

<ul>
<li><code>/etc/fstab</code>: <code>/dev/mapper/HOSTNAME--vg-root</code> が <code>/</code> に、 <code>/dev/mapper/HOSTNAME--vg_swap_1</code> がスワップパーティションに設定されています (<code>HOSTNAME</code> はインストーラーで設定したホスト名)</li>
<li><code>/etc/crypttab</code>: <code>vda5_crypt UUID=... none luks</code> で UUID で指定された <code>/dev/vda5</code> の暗号化が解除された状態が <code>/dev/mapper/vda5_crypt</code> として見えるということがわかります</li>
<li><code>lsblk</code>: ツリー上にみえます (<code>lsblk -f</code> だと UUID も表示されました)</li>
<li><code>ls -l /dev/disk/by-uuid</code>: uuid とデバイスの対応を確認できます (これで確認できる vda1 のパスをあとで使います)</li>
<li><code>sudo cryptsetup luksDump /dev/vda5</code>: luks の情報が表示できます (最初は Key Slot 0 だけ ENABLED で 1 から 7 は DISABLED になっています)</li>
</ul>


<h2>鍵追加</h2>

<p><code>cryptsetup luksAddKey</code> で鍵を追加します。
ここで最初に設定したパスフレーズが必要です。
なぜか <code>Key slot 0 unlocked.</code> が2回でましたが、特に問題はなさそうです。</p>

<pre><code>$ sudo cryptsetup -v luksAddKey /dev/vda5 /boot/keyfile
Enter any passphrase:
Key slot 0 unlocked.
Key slot 0 unlocked.
Command successful.
</code></pre>

<h2>鍵削除</h2>

<p>違うファイルを登録してしまったり、同じ鍵を複数回追加してしまったりしたときには <code>cryptsetup luksRemoveKey</code> で削除できます。
この場合はその鍵自身で unlock されるようなので、パスフレーズは不要でした。</p>

<pre><code>$ sudo cryptsetup -v luksRemoveKey /dev/vda5 /boot/keyfile
Key slot 1 unlocked.
Key slot 1 selected for deletion.
Command successful.
</code></pre>

<p>特定の Key Slot を DISABLED に戻したいときは <code>cryptsetup luksKillSlot</code> が使えます。
この場合はパスフレーズが必要でした。</p>

<pre><code>$ sudo cryptsetup -v luksKillSlot /dev/vda5 2
Key slot 2 selected for deletion.
Enter any remaining passphrase:
Key slot 0 unlocked.
Command successful.
</code></pre>

<h2>自動起動設定</h2>

<p>この段階ではまだ暗号化解除に使える鍵が増えただけで、再起動してもパスフレーズを要求されるままです。</p>

<p><code>/etc/crypttab</code> を以下のように書き換えます。</p>

<pre><code>vda5_crypt UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /dev/disk/by-uuid/yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy:/keyfile luks,keyscript=/lib/cryptsetup/scripts/passdev
</code></pre>

<p>xxx&hellip; の方の UUID は <code>/dev/vda5</code> の UUID なので、そのまま書き換えません。
第3項目の <code>none</code> を <code>/boot</code> パーティションのデバイスを UUID を使って指定したパス + <code>:</code> + <code>/boot</code> パーティション内での <code>keyfile</code> へのパスに書き換えます。
第4項目の <code>luks</code> は <code>luks,keyscript=/lib/cryptsetup/scripts/passdev</code> に書き換えます。
<code>passdev</code> は <code>cryptsetup</code> パッケージで用意されているファイルなので、そのまま書きます。</p>

<h2>initramfs 更新</h2>

<p>書き換えてもまだブートプロセスに反映されていないので、再起動してもパスフレーズを要求されるままなので、
最後に initramfs を更新します。</p>

<pre><code>sudo update-initramfs -u
</code></pre>

<p>これで再起動すると自動起動するようになります。</p>

<p>keyscript のパスが間違っていると以下のように WARNING が出るので、再起動する前に気づくことができますが、
keyfile の指定は間違っていても何も出ないので注意する必要があります。</p>

<pre><code>$ sudo update-initramfs -u
update-initramfs: Generating /boot/initrd.img-4.9.0-3-amd64
cryptsetup: WARNING: target vda5_crypt has an invalid keyscript, skipped
cryptsetup: WARNING: target vda5_crypt has an invalid keyscript, skipped
</code></pre>

<h2>起動失敗した場合</h2>

<p><code>/etc/crypttab</code> の設定をミスして起動しなくなった場合、 netinst の ISO からレスキューモードで起動すればパスフレーズでマウントできます。
そしてルートファイルシステムとして <code>/dev/HOSTNAME-vg/root</code> (<code>HOSTNAME</code> はインストーラーで設定したホスト名) を選び、 <code>/boot</code> パーティションもマウントしてシェルを起動します。</p>

<p>シェルは <code>/bin/sh -i</code> なので使いにくければ <code>bash</code> を起動して、<code>/etc/crypttab</code> を修正して <code>update-initramfs -u</code> で反映させます。
そして exit で抜けて再起動します。</p>

<p>レスキュー環境での修正が難しそうなら、 <code>none</code> と <code>luks</code> だけに戻して、パスフレーズを使う通常起動にしてから直すという方法もあります。</p>

<h2>最後に</h2>

<p>知らないところで暗号化が解除できてしまうのは、コンソール接続が毎回必要になることとのトレードオフですが、鍵ファイルでも解約時に <code>chattr -i /boot/keyfile; shred --remove /boot/keyfile</code> でディスク全体の削除に似た効果を期待できます。ただし <a href="https://linuxjm.osdn.jp/html/GNU_coreutils/man1/shred.1.html">Man page of SHRED</a>の警告に書いてあるように上書きを期待しているので、 ext2 になっている <code>/boot</code> はファイルシステム的には大丈夫だとしても、その下のブロックデバイスで上書きされていない可能性は残りそうです。</p>

<h2>まとめ</h2>

<p>暗号化 LVM を使うことで macOS の FileVault や Windows BitLocker のように簡単にディスクほぼ全体 (<code>/boot</code> を除く) を暗号化できました。
そして、再起動したい時に常にコンソールに接続できるとは限らない環境向けに鍵ファイルで自動起動の設定もできました。</p>

<p>トレードオフもちゃんと考えた上で設定すれば、安全な環境が簡単に作れると思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[letsencryptの証明書の更新に失敗していた(IPv6が原因だった)]]></title>
    <link href="http://blog.n-z.jp/blog/2017-06-14-failed-to-update-letsencrypt.html"/>
    <updated>2017-06-14T19:36:08+09:00</updated>
    <id>http://blog.n-z.jp/blog/failed-to-update-letsencrypt</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s Encrypt の証明書の自動更新が失敗しているサーバーがあって、原因を調べたら AAAA レコードに設定している IPv6 アドレスが間違っていたのが原因でした。</p>

<!--more-->


<h2>環境</h2>

<ul>
<li>Debian GNU/Linux 8.8 (jessie)</li>
<li>certbot 0.10.2-1~bpo8+1</li>
<li>さくらインターネットの VPS で IPv6 を使用 (過去に tun6rd を使っていた)</li>
</ul>


<h2>現象</h2>

<p>2016-03-29 に現在のサーバーに移動した時に A レコードを書き換えただけではなく、追加で tun6rd の頃の IPv6 アドレスを AAAA レコードに設定してしまいました。
別の IPv6 アドレスを設定しているサーバーからの接続に時間がかかるという現象が発生していたものの、原因がわからず、ずっとそのままの状態でした。</p>

<p>StartCom の証明書が事実上使えなくなってしまったので、 2016-12-04 に Let&rsquo;s Encrypt の証明書に変更しました。
初回の証明書の発行のときには問題なく発行できていました。
2017-02-03,2017-04-04 の自動更新も問題なく動いていました。</p>

<p>6月の自動更新で突然失敗するようになり、数日様子を見ていましたが、失敗し続けていたので、詳しく調査することにしました。</p>

<h2>調査</h2>

<p>色々悩んだ結果、 <code>/var/log/letsencrypt/letsencrypt.log</code> を眺めていたところ <code>addressUsed</code> に IPv6 のアドレスが出ているのに気づいて、もしかして、と思ってさらに調べることにしました。</p>

<pre><code>"validationRecord": [
  {
    "url": "http://XXX.example.org/.well-known/acme-challenge/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
    "hostname": "XXX.example.org",
    "port": "80",
    "addressesResolved": [
      "XX.XXX.XXX.XX",
      "2001:e41:XXXX:XXXX::1"
    ],
    "addressUsed": "2001:e41:XXXX:XXXX::1",
    "addressesTried": []
  }
]
</code></pre>

<p>該当のサーバーから <code>ping6 www.kame.net</code> などは問題なく通り、該当サーバーへの <code>ping6</code> も問題なく通ることなどを確認していたところ、IPv6 アドレスが違うことに気づきました。</p>

<h2>修正</h2>

<p>AAAA レコードを <code>2403:3a00:XXX:XXXX:XX:XXX:XXX:XX</code> に修正して、急いでいるわけでもないので certbot の自動実行を待ってみたところ、ちゃんと更新されました。</p>

<h2>関連情報</h2>

<p><a href="https://letsencrypt.jp/usage/dvsni-challenge-error.html">DVSNI challenge エラーの対処法</a>に <code>urn:acme:error:connection</code> の原因の例として A レコードのことは書いてあったのに AAAA レコードのことが書かれていなくて、可能性に気づくのが遅れたので、 AAAA レコードのことも書いてあると良いのではないかと思いました。</p>

<h2>まとめ</h2>

<p>Let&rsquo;s Encrypt のサーバーの実装が変わったのか、IPv6 アドレスから IPv4 へのフォールバックをしなくなっていて、IPv6 アドレスの間違いに気づくことができ、接続が遅かった現象も解決しました。</p>

<p>主に IPv4 を使っているとなかなか気づかないので、 AAAA レコードを設定するときは、ちゃんと確認しておかないと、後でわかりにくいトラブルの原因になると実感しました。</p>
]]></content>
  </entry>
  
</feed>
