<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2017-01-03T13:26:39+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[jessie の certbot が 0.9.3 に上がったので設定を変更した]]></title>
    <link href="http://blog.n-z.jp/blog/2016-11-08-certbot-0-dot-9-3.html"/>
    <updated>2016-11-08T23:14:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/certbot-0-dot-9-3</id>
    <content type="html"><![CDATA[<p>jessie の certbot が 0.9.3 に上がって、
<code>/etc/cron.d/certbot</code> よりも systemd の <code>certbot.timer</code> が優先して動くように変わったので、
reload に post-hook を使うように変えたり、
ログの差分メールの仕組みを変えたりしました。</p>

<!--more-->


<h2>今までの方法</h2>

<p>今までは <code>/etc/cron.daily/local-letsencrypt</code> で <code>certbot renew</code> を呼び出して、ログを保存して <code>diff</code> を出力して cron からメールを送信させて、
<code>reload</code> は更新の有無にかかわらず実行していました。</p>

<pre><code class="sh">#!/bin/sh
LOGFILE=/var/log/certbot-renew.log
if [ -f "$LOGFILE" ]; then
    savelog -c 90 -q "$LOGFILE"
fi
if ! certbot renew &gt; "$LOGFILE" 2&gt;&amp;1 ; then
    echo Automated renewal failed:
    cat "$LOGFILE"
    exit 1
fi
if [ -f "$LOGFILE".0 ]; then
    diff -u "$LOGFILE".0 "$LOGFILE"
fi
apachectl graceful
service postfix reload
</code></pre>

<h2>certbot パッケージでインストールされた自動更新の仕組み</h2>

<p><code>/etc/cron.d/certbot</code> は <code>/run/systemd/system</code> をチェックして普通は動かないようになっていました。</p>

<pre><code> % cat /etc/cron.d/certbot
 # /etc/cron.d/certbot: crontab entries for the certbot package
 #
 # Upstream recommends attempting renewal twice a day
 #
 # Eventually, this will be an opportunity to validate certificates
 # haven't been revoked, etc.  Renewal will only occur if expiration
 # is within 30 days.
 SHELL=/bin/sh
 PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

 0 */12 * * * root test -x /usr/bin/certbot -a \! -d /run/systemd/system &amp;&amp; perl -e 'sleep int(rand(3600))' &amp;&amp; certbot -q renew
</code></pre>

<p>systemd の方では、<code>timer</code> から動かすため、有効化されていない <code>certbot.service</code> と、 service を動かすための <code>certbot.timer</code> が入っていました。</p>

<pre><code>% cat /lib/systemd/system/certbot.service
[Unit]
Description=Certbot
Documentation=file:///usr/share/doc/python-certbot-doc/html/index.html
Documentation=https://letsencrypt.readthedocs.io/en/latest/
[Service]
Type=oneshot
ExecStart=/usr/bin/certbot -q renew
PrivateTmp=true
% cat /lib/systemd/system/certbot.timer
[Unit]
Description=Run certbot twice daily

[Timer]
OnCalendar=*-*-* 00,12:00:00
RandomizedDelaySec=3600
Persistent=true

[Install]
WantedBy=timers.target
</code></pre>

<p><code>OnCalendar</code> で毎日 00:00:00 と 12:00:00 に動くようになっていました。
<code>RandomizedDelaySec</code> でランダムな遅延の設定をしようとしているようですが、
jessie の systemd は対応していないようで、
<code>systemd[1]: [/lib/systemd/system/certbot.timer:6] Unknown lvalue 'RandomizedDelaySec' in section 'Timer'</code>
というログが出ていました。
(<a href="https://bugs.debian.org/843607" title="#843607 - certbot: Unknown lvalue 'RandomizedDelaySec' in section 'Timer'">#843607 - certbot: Unknown lvalue &lsquo;RandomizedDelaySec&rsquo; in section &lsquo;Timer&rsquo;</a> として報告済みです。)</p>

<h2>ログの diff のメール送信方法変更</h2>

<p>設定を追加するには <code>/etc/systemd/system/certbot.service.d</code> にファイルをおけば良いので、
以下の内容の <code>/etc/systemd/system/certbot.service.d/diffmail.conf</code> を作成しました。</p>

<p><code>certbot.service</code> の <code>ExecStart=/usr/bin/certbot -q renew</code> の後に実行したかったので、
<code>ExecStopPost</code> を使ってみました。</p>

<pre><code>[Service]
ExecStopPost=/bin/bash -c "diff -u &lt;(cut -d: -f4- /var/log/letsencrypt/letsencrypt.log.1 | egrep -v '^DEBUG') &lt;(cut -d: -f4- /var/log/letsencrypt/letsencrypt.log | egrep -v '^DEBUG') | ifne mail -s 'Change certbot log' root"
</code></pre>

<p>前回のログ (<code>letsencrypt.log.1</code>) と今回のログ (<code>letsencrypt.log</code>) から、必ず差分になってしまう時刻を <code>cut</code> で削って、さらに DEBUG ログの中にも現在日時で変化する部分があったので除外するようにしてから差分をとっています。</p>

<p>そして <a href="https://packages.debian.org/moreutils" title="moreutils">moreutils</a> の <code>ifne</code> を使って差分があるときだけメール送信をするようにしています。</p>

<h2>post-hook への変更</h2>

<p>systemd の <code>ExecStart</code> を書き換えるのは、メンテナンスしにくいとか、手動で <code>certbot renew</code> を実行したときに使われないなど、あまりよくないかと思い、
<code>/etc/letsencrypt/cli.ini</code> で設定することにしました。</p>

<p>letsencrypt の証明書を apache のみで使っているサーバーでは post-hook にリロードするコマンドを直接設定しました。</p>

<p>ついでに <code>rsa-key-size</code> も 2048 から 4096 に変更するようにしました。</p>

<pre><code>% cat /etc/letsencrypt/cli.ini
rsa-key-size = 4096
post-hook = apachectl graceful
</code></pre>

<h2>複数コマンドの post-hook</h2>

<p><code>post-hook = apachectl graceful; service postfix reload &gt;/dev/null</code> のような書き方は
<code>certbot: error: Unexpected line 1 in /etc/letsencrypt/cli.ini: post-hook = apachectl graceful; service postfix reload &gt;/dev/null</code>
というエラーになってうまくいかなかったので、
<code>/etc/letsencrypt/post-hook</code> に実行ファイルを作って、それを post-hook に指定することにしました。</p>

<pre><code> % sudoedit /etc/letsencrypt/cli.ini
 % sudoedit /etc/letsencrypt/post-hook
 % sudo chmod +x /etc/letsencrypt/post-hook
 % cat /etc/letsencrypt/cli.ini
 rsa-key-size = 4096
 post-hook = /etc/letsencrypt/post-hook
 % cat /etc/letsencrypt/post-hook
 #!/bin/sh
 apachectl graceful
 service postfix reload &gt;/dev/null
</code></pre>

<h2>テスト実行</h2>

<p><code>sudo certbot renew</code> で試しに実行してみたところ、以下のような感じで更新の必要がないときは <code>post-hook</code> は実行されないことが確認できました。</p>

<pre><code>% sudo certbot renew
Saving debug log to /var/log/letsencrypt/letsencrypt.log

-------------------------------------------------------------------------------
Processing /etc/letsencrypt/renewal/www.example.org.conf
-------------------------------------------------------------------------------
Cert not yet due for renewal

The following certs are not due for renewal yet:
  /etc/letsencrypt/live/www.example.org/fullchain.pem (skipped)
No renewals were attempted.
No renewals attempted, so not running post-hook
</code></pre>

<h2>まとめ</h2>

<p><code>certbot renew</code> で証明書が更新されたときに実行したいことは <code>post-hook</code> に、
証明書の更新とは関係なく毎回実行したいことは systemd の <code>ExecStopPost</code> を使えば良いことがわかりました。</p>

<p>certbot の hook には <code>post-hook</code> 以外に <code>pre-hook</code> と <code>renew-hook</code> もあるので、
用途によってはそちらも使えそうです。
(<code>webroot</code> プラグインを使っているので使っていませんが、
<code>standalone</code> プラグインを使っているのなら <code>pre-hook</code> で <code>stop</code> して <code>post-hook</code> で <code>start</code> するとか、
<code>renew-hook</code> で更新されたドメインに応じて必要な時だけ <code>postfix reload</code> するとか)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash で PATH を配列に分解の続き]]></title>
    <link href="http://blog.n-z.jp/blog/2016-10-07-bash-path-to-array-again.html"/>
    <updated>2016-10-07T21:39:31+09:00</updated>
    <id>http://blog.n-z.jp/blog/bash-path-to-array-again</id>
    <content type="html"><![CDATA[<p>zsh だと <code>PATH</code> と同期している配列変数として <code>path</code> があるのですが、
bash にはそういうものがなくて困ったので、分解する方法を考えてみた話の続きです。
末尾の空文字列や改行に対応しました。</p>

<!--more-->


<h2>昨日の方法の問題点</h2>

<p><a href="/blog/2016-10-06-bash-path-to-array.html">昨日の記事</a> に書きましたが、末尾の空文字列の処理に問題がありました。
また、書いていませんでしたが、改行に対応できていませんでした。</p>

<h2>末尾対応</h2>

<p><code>PATH= bash -c 'ls'</code> を <code>/bin</code> やそれ以外で実行してみたら
空の <code>PATH</code> はカレントディレクトリのみと同じ意味のようなので、
「<a href="https://twitter.com/fixedpoint_jp/status/784229832930369536">末尾の空文字列に対応するために、PATHにの最後に:を追加した文字列をreadすればいい?</a>」
という指摘のように末尾に <code>:</code> を追加する方法で良さそうでした。</p>

<p>つまり、以下のようになります。</p>

<pre><code class="console">% bash -c 'PATH=/bin:; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin" [1]="")'
% bash -c 'PATH=/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin")'
% bash -c 'PATH=; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="")'
</code></pre>

<p>「PATH自体が空だった場合は振舞いが変わるけど。」という話もありましたが、
<code>PATH</code> 探索を再現できれば良いということを考えると空の場合も問題なさそうでした。</p>

<pre><code class="console">% bash -c 'PATH=; ls'
bash: ls: No such file or directory
% cd /bin
% bash -c 'PATH=; ls /bin/bash'
/bin/bash
</code></pre>

<h2>改行対応</h2>

<p>いろいろ試していると改行を含む <code>PATH</code> を扱えないことに気づいたのですが、
<code>-d $'\0'</code> (以下の例ではコマンドラインのエスケープでひどいことになっていますが) を
指定して区切り文字を変えると here string の末尾に付く改行も入力の一部として
扱われてしまうのでうまくいかないようでしたが、末尾の要素を <code>unset</code> で削除することで
良い感じになりました。</p>

<p><code>$'\0'</code> は NUL 文字で C 言語での終端文字なので、普通は <code>PATH</code> の途中に入らないことが期待できるので、ありえない文字として指定しています。</p>

<pre><code class="console">% bash -c 'PATH=/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin" [1]="
")'
% bash -c 'PATH=/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; unset path[-1]; declare -p path'
declare -a path='([0]="/bin")'
% bash -c 'PATH=/foo$'"'"'\n'"'"'bar:/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; unset path[-1]; declare -p path'
declare -a path='([0]="/foo
bar" [1]="/bin")'
</code></pre>

<p>わかりやすいようにファイルにして実行すると以下のような感じです。</p>

<pre><code class="console">% cat /tmp/p.bash
PATH=/foo$'\n'bar:/bin
IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
declare -p path
PATH=/foo$'\n'bar:/bin:
IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
declare -p path
% bash /tmp/p.bash
declare -a path='([0]="/foo
bar" [1]="/bin")'
declare -a path='([0]="/foo
bar" [1]="/bin" [2]="")'
</code></pre>

<h2>他の処理例</h2>

<p><code>/etc/group</code> くらいのデータになると awk などを使った方が良いと思いますが、
<code>/etc/group</code> (末尾に空文字列が入ることがある) のパースも良い感じにできるようです。</p>

<p>設定されていない状態でも構わなかったり、
末尾に空文字列が入らないことがわかっている <code>/etc/passwd</code> などの場合は
bash の組み込みコマンドだけでいけそうです。</p>

<pre><code class="console">% cat /tmp/t.bash
#!/bin/bash
sed 's/$/:/' /etc/group | while IFS=: read -r -a group; do
  declare -p group
done
% bash /tmp/t.bash
declare -a group='([0]="root" [1]="x" [2]="0" [3]="")'
declare -a group='([0]="daemon" [1]="x" [2]="1" [3]="")'
declare -a group='([0]="bin" [1]="x" [2]="2" [3]="")'
declare -a group='([0]="sys" [1]="x" [2]="3" [3]="")'
declare -a group='([0]="adm" [1]="x" [2]="4" [3]="syslog,vagrant")'
(略)
declare -a group='([0]="lpadmin" [1]="x" [2]="114" [3]="vagrant")'
declare -a group='([0]="sambashare" [1]="x" [2]="115" [3]="vagrant")'
declare -a group='([0]="vboxsf" [1]="x" [2]="999" [3]="")'
declare -a group='([0]="scanner" [1]="x" [2]="116" [3]="")'
declare -a group='([0]="colord" [1]="x" [2]="117" [3]="")'
</code></pre>

<h2>まとめ</h2>

<p>最終的には</p>

<pre><code class="bash">IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
</code></pre>

<p>で <code>PATH</code> を配列に変換できることがわかりました。</p>

<p>入力データに改行がないとわかっているなら <code>-d $'\0'</code> などは省略できるので、
入力データの性質に応じて適度に手を抜きつつ処理をするのが良いのではないでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash で PATH を配列に分解]]></title>
    <link href="http://blog.n-z.jp/blog/2016-10-06-bash-path-to-array.html"/>
    <updated>2016-10-06T23:50:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/bash-path-to-array</id>
    <content type="html"><![CDATA[<p>zsh だと <code>PATH</code> と同期している配列変数として <code>path</code> があるのですが、
bash にはそういうものがなくて困ったので、分解する方法を考えてみました。</p>

<!--more-->


<h2>結論</h2>

<p>先に結論を書いておくと、最終的には <code>IFS=: read -r -a path &lt;&lt;&lt;"$PATH"</code> という方法で分解できました。</p>

<p>2016-10-07 追記: 詳細は<a href="/blog/2016-10-07-bash-path-to-array-again.html">続き</a> に書きましたが、改行などに対応できていませんでした。</p>

<pre><code class="console">% bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
</code></pre>

<p>のように動作確認できます。</p>

<p>declare で表示というのは <a href="http://yonchu.hatenablog.com/entry/2013/07/09/230656" title="シェルスクリプトのデバッグは typeset または declare を使うと良いかも - よんちゅBlog">シェルスクリプトのデバッグは typeset または declare を使うと良いかも - よんちゅBlog</a> を参考にしました。</p>

<h2><code>-r</code> オプション</h2>

<p><code>-r</code> オプションは <code>read</code> コマンドを使うときの定石ですが、具体的には <code>\:</code> のような並びがあるときに影響がありました。</p>

<pre><code class="console">% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="/tmp/foo\\" [2]="/tmp/bar")'
% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="/tmp/foo:/tmp/bar")'
</code></pre>

<p>実際のパスの挙動は <code>-r</code> がある場合と同じようでした。</p>

<pre><code class="console">% mkdir /tmp/foo\\
% echo echo hoge &gt; /tmp/foo\\/hoge
% chmod +x /tmp/foo\\/hoge
% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -a path &lt;&lt;&lt;"$PATH"; for p in "${path[@]}"; do test -x "$p/hoge" &amp;&amp; "$p/hoge"; done'
PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; for p in "${path[@]}"; do test -x "$p/hoge" &amp;&amp; "$p/hoge"; done'
hoge
% PATH="/bin:/tmp/foo\:/tmp/bar" hoge
hoge
</code></pre>

<h2><code>-d</code> オプション</h2>

<p><code>-d</code> オプションというのもあったので試してみたのですが、そこで完全に読み込み終了になってしまって、期待した動作にはなりませんでした。</p>

<pre><code class="console">% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'read -d : -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin")'
</code></pre>

<h2><code>-a</code> オプション</h2>

<p><code>-a</code> オプションはこのように複数の変数を指定する代わりにひとつの変数を指定して配列を代入してくれるオプションでした。</p>

<p><code>-a</code> オプションがないと指定した変数のうち、最後に残り全て入ってしまうようです。</p>

<pre><code class="console">PATH="/bin:/tmp/foo\:/tmp/bar:/tmp/baz" bash -c 'IFS=: read -r path1 path2 path3 &lt;&lt;&lt;"$PATH"; declare -p path1 path2 path3'
declare -- path1="/bin"
declare -- path2="/tmp/foo\\"
declare -- path3="/tmp/bar:/tmp/baz"
</code></pre>

<h2>here string</h2>

<p><code>&lt;&lt;&lt;word</code> は <code>echo word |</code> のようなもので、標準入力に <code>word</code> を渡してくれる機能です。</p>

<h2>IFS</h2>

<p><code>read</code> などの単語区切りです。
デフォルトは空白、タブ、改行です。</p>

<p>ずっと変えてしまうと影響が大きすぎるので、 <code>read</code> の行だけ変更するようにしています。</p>

<p>また、このやり方を使うことで空白の入ったディレクトリを含むパスもうまく扱えます。</p>

<h2>カレントディレクトリを表す空のパスの扱い</h2>

<p>頭や途中に入った空文字列 (カレントディレクトリを表す) は扱えたのですが、末尾にある場合はうまくいきませんでした。</p>

<p>セキュリティ上の問題もあるので、普通は設定しないと思うので、対応しなくても問題はないと思いますが、完全に変換したい場合は特別扱いを追加する必要がありそうでした。</p>

<pre><code class="console">%  bash -c 'PATH=:/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="" [1]="/bin")'
%  bash -c 'PATH=/bin::/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="" [2]="/bin")'
%  bash -c 'PATH=/bin:; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin")'
</code></pre>

<h2>まとめ</h2>

<p>zsh には元から <code>path</code> があるし、 <code>/bin/sh</code> には配列がないので bash 限定ではありますが、
<code>IFS=: read -r -a path &lt;&lt;&lt;"$PATH"</code> で実用上問題なく変換できるということがわかったので、必要な時には使うと良いのではないでしょうか。</p>

<p>2016-10-07 追記: 末尾の空文字列や改行に対応した<a href="/blog/2016-10-07-bash-path-to-array-again.html">続き</a>を書きました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lsで丸数字で始まるファイル名の順番が変だった]]></title>
    <link href="http://blog.n-z.jp/blog/2016-08-30-lc-collate-again.html"/>
    <updated>2016-08-30T22:58:34+09:00</updated>
    <id>http://blog.n-z.jp/blog/lc-collate-again</id>
    <content type="html"><![CDATA[<p>OS X で丸数字から始まるファイル名のファイルが入ったフォルダーを Finder で開くと丸数字の数字順に並んでいたのに、 <code>ls</code> で表示すると別の順番になっていたので原因を調べてみました。</p>

<!--more-->


<h2>動作確認環境</h2>

<ul>
<li>OS X Yosemite (10.10.5)</li>
<li>ls, uniq バージョン不明</li>
<li>sort (GNU coreutils) 5.93</li>
</ul>


<h2>動作確認</h2>

<p>Unicode 的に連続している 丸1 から 丸20 までのファイル名のファイルと、それに適当な ASCII の数字をつけたファイル名のファイルを作成して <code>ls</code> で表示してみました。</p>

<pre><code>%  touch $(ruby -e 'puts ("\u{2460}".."\u{2473}").to_a')
%  touch $(ruby -e 'puts ("\u{2460}".."\u{2473}").to_a.shuffle.map.with_index{|e,i|"#{e}#{i}"}')
%  ls
①      ⑤      ⑨      ⑬      ⑰      ⑧0     ⑲12    ⑮16    ⑥2     ⑬6
②      ⑥      ⑩      ⑭      ⑱      ⑤1     ⑱13    ⑳17    ④3     ⑫7
③      ⑦      ⑪      ⑮      ⑲      ⑨10    ②14    ⑪18    ⑭4     ⑦8
④      ⑧      ⑫      ⑯      ⑳      ⑯11    ⑩15    ③19    ⑰5     ①9
</code></pre>

<p>丸数字のみだと数字順に並んでいるのに、後ろに ASCII の数字をつけた部分は ASCII の数字順に並んでいます。
(numeric sort じゃないので 1,10,2 という順番になっているのがちょっとわかりにくいかもしれませんが。)</p>

<h2>Jessie での動作確認</h2>

<p>比較のために Debian GNU/Linux 8.5 (jessie) でも同様のファイルを作成して <code>ls</code> してみると丸数字のみのところもバラバラの順番でした。
何度か実行しても同じ結果なので、ランダムというわけではなくなんらかの基準がありそうですが、どういう順番なのかはわかりませんでした。</p>

<pre><code>% ls
⑧  ⑯  ⑥  ⑬  ⑫  ⑦  ①  ③  ⑮  ⑰  ④0  ⑨10  ⑳12  ⑫14  ⑭16  ①18  ⑩2  ⑥4  ⑯6  ⑱8
⑱  ⑩  ⑨  ⑪  ⑲  ⑤  ②  ④  ⑭  ⑳  ⑪1  ⑦11  ⑲13  ⑬15  ⑮17  ⑧19  ⑤3  ②5  ⑰7  ③9
</code></pre>

<h2>LC_COLLATE</h2>

<p><a href="http://blog.n-z.jp/blog/2013-10-31-lc-collate-uniq.html" title="LC_COLLATEの問題でuniqで丸数字が同一視されてしまう">LC_COLLATEの問題でuniqで丸数字が同一視されてしまう</a>のと同じ話かと思って、 <code>sort</code> や <code>uniq</code> も試してみたところ、同じ話のように見えました。
OS X では locale data が GNU/Linux とは違うようで <code>uniq</code> で同一視されるということは起きませんでした。</p>

<pre><code>% rbenv exec irb -r irb/completion --simple-prompt
&gt;&gt; IO.popen("uniq", "r+"){|io| io.puts ("\u{2460}".."\u{2473}").to_a; io.close_write; puts io.read }
①
②
③
④
⑤
⑥
⑦
⑧
⑨
⑩
⑪
⑫
⑬
⑭
⑮
⑯
⑰
⑱
⑲
⑳
=&gt; nil
&gt;&gt; IO.popen("sort", "r+"){|io| io.puts ("\u{2460}".."\u{2473}").to_a.shuffle; io.close_write; puts io.read }
①
②
③
④
⑤
⑥
⑦
⑧
⑨
⑩
⑪
⑫
⑬
⑭
⑮
⑯
⑰
⑱
⑲
⑳
=&gt; nil
&gt;&gt; IO.popen("sort", "r+"){|io| io.puts ("\u{2460}".."\u{2473}").to_a.shuffle.map.with_index{|e,i|"#{e}#{i}"}; io.close_write; puts io.read }
⑬0
⑥1
⑰10
⑱11
⑤12
⑮13
⑦14
④15
③16
⑪17
⑩18
①19
⑧2
⑲3
⑫4
⑳5
⑭6
②7
⑯8
⑨9
=&gt; nil
&gt;&gt; IO.popen({"LC_COLLATE"=&gt;"C"}, "sort", "r+"){|io| io.puts ("\u{2460}".."\u{2473}").to_a.shuffle.map.with_index{|e,i|"#{e}#{i}"}; io.close_write; puts io.read }
①6
②5
③0
④16
⑤19
⑥18
⑦7
⑧2
⑨8
⑩3
⑪12
⑫15
⑬4
⑭9
⑮14
⑯10
⑰1
⑱17
⑲13
⑳11
=&gt; nil
</code></pre>

<h2>一番自然に感じる並び順</h2>

<p>ruby の sort での結果は <code>LC_COLLATE=C</code> と同じように文字コード順になり、意味自然な並び順に感じました。
<code>LC_COLLATE=C ls</code> も同じ並び順でした。</p>

<pre><code>&gt;&gt; puts Dir['*'].sort
①
①9
②
②14
③
③19
④
④3
⑤
⑤1
⑥
⑥2
⑦
⑦8
⑧
⑧0
⑨
⑨10
⑩
⑩15
⑪
⑪18
⑫
⑫7
⑬
⑬6
⑭
⑭4
⑮
⑮16
⑯
⑯11
⑰
⑰5
⑱
⑱13
⑲
⑲12
⑳
⑳17
=&gt; nil
</code></pre>

<pre><code>% LC_COLLATE=C ls
①      ③      ⑤      ⑦      ⑨      ⑪      ⑬      ⑮      ⑰      ⑲
①9     ③19    ⑤1     ⑦8     ⑨10    ⑪18    ⑬6     ⑮16    ⑰5     ⑲12
②      ④      ⑥      ⑧      ⑩      ⑫      ⑭      ⑯      ⑱      ⑳
②14    ④3     ⑥2     ⑧0     ⑩15    ⑫7     ⑭4     ⑯11    ⑱13    ⑳17
</code></pre>

<h2>Finder での並び順</h2>

<p>Finder での並び順は <code>LC_COLLATE=C</code> での結果と同じかと思いきや、丸1 の後に 丸10 がきて、丸19, 丸2, 丸20, 丸3 のように並んでいたので、独特な感じでした。</p>

<pre><code>①
①9
⑩
⑩15
⑪
⑪18
⑫
⑫7
⑬
⑬6
⑭
⑭4
⑮
⑮16
⑯
⑯11
⑰
⑰5
⑱
⑱13
⑲
⑲12
②
②14
⑳
⑳17
③
③19
④
④3
⑤
⑤1
⑥
⑥2
⑦
⑦8
⑧
⑧0
⑨
⑨10
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LILO&東海道らぐオフラインミーティング 2016/08/14]]></title>
    <link href="http://blog.n-z.jp/blog/2016-08-14-lilo-tokaidolug.html"/>
    <updated>2016-08-14T13:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/lilo-tokaidolug</id>
    <content type="html"><![CDATA[<p><a href="http://lilo.connpass.com/event/37410/" title="LILO&amp;東海道らぐオフラインミーティング 2016/08/14">LILO&amp;東海道らぐオフラインミーティング 2016/08/14</a> に参加しました。</p>

<p>今回もアンカンファレンス形式でした。</p>

<p><a href="https://www.doorkeeper.jp/news/2016/7/25/change-in-pricing" title="Doorkeeper料金体系の変更について">Doorkeeper料金体系の変更について</a>でアナウンスされたように Doorkeeper が有料化されることに伴い、申し込みは connpass に移行しました。</p>

<!--more-->


<h2>メモ</h2>

<p>今回のメモです。</p>

<ul>
<li>いつものように鍵担当の人が遅れていたが、代理で開けていた</li>
<li>ハッシュタグ: <code>#lilo_jp</code> <code>#東海道らぐ</code></li>
<li>登録参加者数 14名</li>
<li>自己紹介から</li>
<li>最初は自分の発表「lilo.linux.or.jp の話」</li>
<li>「OpenStreetMap で地図を作ろう!」坂ノ下さん</li>
<li>Map Compare というサイトで Google Map と OSM の平安神宮を比較すると、OSMの方が詳しい</li>
<li>JOSM というクライアントで実演</li>
<li>ノード、ウェイ、エリアででできている</li>
<li>誰でも書き込めるし消せるので、悪質なユーザーへの対処は日々行っている</li>
<li><a href="http://wiki.openstreetmap.org/wiki/JA:Map_Features">http://wiki.openstreetmap.org/wiki/JA:Map_Features</a></li>
<li>鳥居のタグの話</li>
<li>どのようにタグをつけるのかは議論しながら決まっている</li>
<li>「IoTハウス」山内さん</li>
<li><a href="http://www.pepolinux.com">http://www.pepolinux.com</a> <a href="https://twitter.com/kujiranodanna">https://twitter.com/kujiranodanna</a></li>
<li>ラズパイで IoT ハウス</li>
<li>Tocos, IRKit</li>
<li>リセッタブルヒューズ</li>
<li>休憩</li>
<li>「お前が持っているLPICってどんなものよ? LPI 304受験報告記」中野さん</li>
<li>事前に公開されていた発表資料: <a href="https://bitbucket.org/itsango/lilo20160814">https://bitbucket.org/itsango/lilo20160814</a></li>
<li>有意性の期限がある</li>
<li>メリット: Linux が使える客観的な証拠になる</li>
<li>デメリット: 高い</li>
<li>304 の参考書: <a href="https://amazon.jp/dp/4844380540">https://amazon.jp/dp/4844380540</a></li>
<li>TOEIC みたいに何か統計処理された採点方式らしい</li>
<li>「Windows 10 タブレットに Ubuntu 16.04 を色々入れてみた 2016 年度版」Kapper さん</li>
<li><a href="http://www.slideshare.net/kapper1224/windows10ubuntu16042016install-ubuntu1604-on-windows10-tablet-63862255">http://www.slideshare.net/kapper1224/windows10ubuntu16042016install-ubuntu1604-on-windows10-tablet-63862255</a></li>
<li>Wubi for Ubuntu 16.04 が公式にタブレット対応</li>
<li>「Yocto を使った Linux Distro の作り方とハマり方」山口さん</li>
<li><a href="https://github.com/watatuki">https://github.com/watatuki</a></li>
<li><a href="https://www.yoctoproject.org/">https://www.yoctoproject.org/</a></li>
<li>たとえていえば Gentoo をクロスビルドにしたようなもの</li>
<li>layer を組み合わせて構成</li>
<li>recipe はソースと 1対1 対応</li>
<li>複数の layer の組み合わせが問題でビルドが通らなくなることがある</li>
<li>Android でおなじみの repo でいい感じできた</li>
<li>例: <a href="https://github.com/watatuki/agl-jetson-tk1">https://github.com/watatuki/agl-jetson-tk1</a></li>
<li>休憩</li>
<li>「TUI作業で便利なソフト2題」島田さん</li>
<li>opencocon の紹介</li>
<li>build server</li>
<li>このごろあった悩み: ファイルツリーを駆け回るのがめんどい</li>
<li>解決法：TUI ファイラー</li>
<li>mc (Midnight Commander)</li>
<li>あんまり慣れてない</li>
<li>Ctrl キー等を多用する</li>
<li>F1-F12 を使わなければならない</li>
<li>tmux とキーバインドが干渉しやすい</li>
<li>他に選択肢がないか?</li>
<li>FDclone</li>
<li>このごろあった悩み: git コマンドをいちいち叩くのがめんどい</li>
<li>tig</li>
<li>「Docker話」左川さん</li>
<li>vagrant で docker を試した話</li>
<li>box ファイルは VirtualBox で普通にインストールして不要なものを削除して作成した。</li>
<li>会場から packer がおすすめという話</li>
<li>さくらインターネットの Arukas はまだ誰も使ったことがない</li>
<li>今回の会場費は余剰金があるので無料になった。</li>
<li>「sedの話」田川さん</li>
<li>sed はプログラミング言語</li>
<li>デバッグオプション <code>-d</code> のある sed</li>
<li>sdb というデバッガをネットワーク経由で接続</li>
<li>「せっかくのプレゼン資料なんだから Git で管理しよう Slides を公開しよう」中野さん</li>
<li>事前に公開されていた資料: <a href="https://bitbucket.org/itsango/vcsforslides">https://bitbucket.org/itsango/vcsforslides</a></li>
<li><a href="http://progit-ja.github.io/">http://progit-ja.github.io/</a></li>
<li><a href="https://ja.wikipedia.org/wiki/OSS%E3%83%9B%E3%82%B9%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E6%AF%94%E8%BC%83" title="OSSホスティングサービスの比較">OSSホスティングサービスの比較</a></li>
<li>次は冬休みの予定 (その前に k-of.jp にも参加予定)</li>
</ul>


<h2>発表した内容</h2>

<p>lilo.linux.or.jp のサーバーの前回の発表以降の話をしました。</p>

<p>内容は大きく分けると 二要素認証は進捗なし、 letsencrypt の証明書は certbot に変わっても順調に使えている話、 ufw でアタックが多いポートをログに残さないようにした話でした。</p>

<p>スライドはいつも通り <a href="http://slide.rabbit-shocker.org/authors/znz/lilo-20160814/">Rabbit Slide Show</a> (<a href="https://rubygems.org/gems/rabbit-slide-znz-lilo-20160814">RubyGems</a>), <a href="http://www.slideshare.net/znzjp/lilo-20160814">SlideShare</a>, <a href="https://speakerdeck.com/znz/lilo-dot-linux-dot-or-dot-jp-falsehua">Speaker Deck</a> にあげています。(ソースは <a href="https://github.com/znz/lilo-20160814">github</a> にあげています。)
(しかし、2016-08-14現在 slide.rabbit-shocker.org (Rabbit Slide Show) には反映されていないようなので、 SlideShare か Speaker Deck でみてください。)
(2016-08-16現在、反映されたので Rabbit Slide Show でも見えるようになりました。)</p>

<iframe src="http://slide.rabbit-shocker.org/authors/znz/lilo-20160814/viewer.html"
        width="640" height="524"
        frameborder="0"
        marginwidth="0"
        marginheight="0"
        scrolling="no"
        style="border: 1px solid #ccc; border-width: 1px 1px 0; margin-bottom: 5px"
        allowfullscreen> </iframe>


<div style="margin-bottom: 5px">
  <a href="http://slide.rabbit-shocker.org/authors/znz/lilo-20160814/" title="lilo.linux.or.jp の話">lilo.linux.or.jp の話</a>
</div>

]]></content>
  </entry>
  
</feed>
