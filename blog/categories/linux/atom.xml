<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2016-10-07T22:26:33+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[bash で PATH を配列に分解の続き]]></title>
    <link href="http://blog.n-z.jp/blog/2016-10-07-bash-path-to-array-again.html"/>
    <updated>2016-10-07T21:39:31+09:00</updated>
    <id>http://blog.n-z.jp/blog/bash-path-to-array-again</id>
    <content type="html"><![CDATA[<p>zsh だと <code>PATH</code> と同期している配列変数として <code>path</code> があるのですが、
bash にはそういうものがなくて困ったので、分解する方法を考えてみた話の続きです。
末尾の空文字列や改行に対応しました。</p>

<!--more-->


<h2>昨日の方法の問題点</h2>

<p><a href="/blog/2016-10-06-bash-path-to-array.html">昨日の記事</a> に書きましたが、末尾の空文字列の処理に問題がありました。
また、書いていませんでしたが、改行に対応できていませんでした。</p>

<h2>末尾対応</h2>

<p><code>PATH= bash -c 'ls'</code> を <code>/bin</code> やそれ以外で実行してみたら
空の <code>PATH</code> はカレントディレクトリのみと同じ意味のようなので、
「<a href="https://twitter.com/fixedpoint_jp/status/784229832930369536">末尾の空文字列に対応するために、PATHにの最後に:を追加した文字列をreadすればいい?</a>」
という指摘のように末尾に <code>:</code> を追加する方法で良さそうでした。</p>

<p>つまり、以下のようになります。</p>

<pre><code class="console">% bash -c 'PATH=/bin:; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin" [1]="")'
% bash -c 'PATH=/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin")'
% bash -c 'PATH=; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="")'
</code></pre>

<p>「PATH自体が空だった場合は振舞いが変わるけど。」という話もありましたが、
<code>PATH</code> 探索を再現できれば良いということを考えると空の場合も問題なさそうでした。</p>

<pre><code class="console">% bash -c 'PATH=; ls'
bash: ls: No such file or directory
% cd /bin
% bash -c 'PATH=; ls /bin/bash'
/bin/bash
</code></pre>

<h2>改行対応</h2>

<p>いろいろ試していると改行を含む <code>PATH</code> を扱えないことに気づいたのですが、
<code>-d $'\0'</code> (以下の例ではコマンドラインのエスケープでひどいことになっていますが) を
指定して区切り文字を変えると here string の末尾に付く改行も入力の一部として
扱われてしまうのでうまくいかないようでしたが、末尾の要素を <code>unset</code> で削除することで
良い感じになりました。</p>

<p><code>$'\0'</code> は NUL 文字で C 言語での終端文字なので、普通は <code>PATH</code> の途中に入らないことが期待できるので、ありえない文字として指定しています。</p>

<pre><code class="console">% bash -c 'PATH=/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin" [1]="
")'
% bash -c 'PATH=/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; unset path[-1]; declare -p path'
declare -a path='([0]="/bin")'
% bash -c 'PATH=/foo$'"'"'\n'"'"'bar:/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; unset path[-1]; declare -p path'
declare -a path='([0]="/foo
bar" [1]="/bin")'
</code></pre>

<p>わかりやすいようにファイルにして実行すると以下のような感じです。</p>

<pre><code class="console">% cat /tmp/p.bash
PATH=/foo$'\n'bar:/bin
IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
declare -p path
PATH=/foo$'\n'bar:/bin:
IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
declare -p path
% bash /tmp/p.bash
declare -a path='([0]="/foo
bar" [1]="/bin")'
declare -a path='([0]="/foo
bar" [1]="/bin" [2]="")'
</code></pre>

<h2>他の処理例</h2>

<p><code>/etc/group</code> くらいのデータになると awk などを使った方が良いと思いますが、
<code>/etc/group</code> (末尾に空文字列が入ることがある) のパースも良い感じにできるようです。</p>

<p>設定されていない状態でも構わなかったり、
末尾に空文字列が入らないことがわかっている <code>/etc/passwd</code> などの場合は
bash の組み込みコマンドだけでいけそうです。</p>

<pre><code class="console">% cat /tmp/t.bash
#!/bin/bash
sed 's/$/:/' /etc/group | while IFS=: read -r -a group; do
  declare -p group
done
% bash /tmp/t.bash
declare -a group='([0]="root" [1]="x" [2]="0" [3]="")'
declare -a group='([0]="daemon" [1]="x" [2]="1" [3]="")'
declare -a group='([0]="bin" [1]="x" [2]="2" [3]="")'
declare -a group='([0]="sys" [1]="x" [2]="3" [3]="")'
declare -a group='([0]="adm" [1]="x" [2]="4" [3]="syslog,vagrant")'
(略)
declare -a group='([0]="lpadmin" [1]="x" [2]="114" [3]="vagrant")'
declare -a group='([0]="sambashare" [1]="x" [2]="115" [3]="vagrant")'
declare -a group='([0]="vboxsf" [1]="x" [2]="999" [3]="")'
declare -a group='([0]="scanner" [1]="x" [2]="116" [3]="")'
declare -a group='([0]="colord" [1]="x" [2]="117" [3]="")'
</code></pre>

<h2>まとめ</h2>

<p>最終的には</p>

<pre><code class="bash">IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
</code></pre>

<p>で <code>PATH</code> を配列に変換できることがわかりました。</p>

<p>入力データに改行がないとわかっているなら <code>-d $'\0'</code> などは省略できるので、
入力データの性質に応じて適度に手を抜きつつ処理をするのが良いのではないでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash で PATH を配列に分解]]></title>
    <link href="http://blog.n-z.jp/blog/2016-10-06-bash-path-to-array.html"/>
    <updated>2016-10-06T23:50:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/bash-path-to-array</id>
    <content type="html"><![CDATA[<p>zsh だと <code>PATH</code> と同期している配列変数として <code>path</code> があるのですが、
bash にはそういうものがなくて困ったので、分解する方法を考えてみました。</p>

<!--more-->


<h2>結論</h2>

<p>先に結論を書いておくと、最終的には <code>IFS=: read -r -a path &lt;&lt;&lt;"$PATH"</code> という方法で分解できました。</p>

<p>2016-10-07 追記: 詳細は<a href="/blog/2016-10-07-bash-path-to-array-again.html">続き</a> に書きましたが、改行などに対応できていませんでした。</p>

<pre><code class="console">% bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
</code></pre>

<p>のように動作確認できます。</p>

<p>declare で表示というのは <a href="http://yonchu.hatenablog.com/entry/2013/07/09/230656" title="シェルスクリプトのデバッグは typeset または declare を使うと良いかも - よんちゅBlog">シェルスクリプトのデバッグは typeset または declare を使うと良いかも - よんちゅBlog</a> を参考にしました。</p>

<h2><code>-r</code> オプション</h2>

<p><code>-r</code> オプションは <code>read</code> コマンドを使うときの定石ですが、具体的には <code>\:</code> のような並びがあるときに影響がありました。</p>

<pre><code class="console">% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="/tmp/foo\\" [2]="/tmp/bar")'
% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="/tmp/foo:/tmp/bar")'
</code></pre>

<p>実際のパスの挙動は <code>-r</code> がある場合と同じようでした。</p>

<pre><code class="console">% mkdir /tmp/foo\\
% echo echo hoge &gt; /tmp/foo\\/hoge
% chmod +x /tmp/foo\\/hoge
% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -a path &lt;&lt;&lt;"$PATH"; for p in "${path[@]}"; do test -x "$p/hoge" &amp;&amp; "$p/hoge"; done'
PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; for p in "${path[@]}"; do test -x "$p/hoge" &amp;&amp; "$p/hoge"; done'
hoge
% PATH="/bin:/tmp/foo\:/tmp/bar" hoge
hoge
</code></pre>

<h2><code>-d</code> オプション</h2>

<p><code>-d</code> オプションというのもあったので試してみたのですが、そこで完全に読み込み終了になってしまって、期待した動作にはなりませんでした。</p>

<pre><code class="console">% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'read -d : -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin")'
</code></pre>

<h2><code>-a</code> オプション</h2>

<p><code>-a</code> オプションはこのように複数の変数を指定する代わりにひとつの変数を指定して配列を代入してくれるオプションでした。</p>

<p><code>-a</code> オプションがないと指定した変数のうち、最後に残り全て入ってしまうようです。</p>

<pre><code class="console">PATH="/bin:/tmp/foo\:/tmp/bar:/tmp/baz" bash -c 'IFS=: read -r path1 path2 path3 &lt;&lt;&lt;"$PATH"; declare -p path1 path2 path3'
declare -- path1="/bin"
declare -- path2="/tmp/foo\\"
declare -- path3="/tmp/bar:/tmp/baz"
</code></pre>

<h2>here string</h2>

<p><code>&lt;&lt;&lt;word</code> は <code>echo word |</code> のようなもので、標準入力に <code>word</code> を渡してくれる機能です。</p>

<h2>IFS</h2>

<p><code>read</code> などの単語区切りです。
デフォルトは空白、タブ、改行です。</p>

<p>ずっと変えてしまうと影響が大きすぎるので、 <code>read</code> の行だけ変更するようにしています。</p>

<p>また、このやり方を使うことで空白の入ったディレクトリを含むパスもうまく扱えます。</p>

<h2>カレントディレクトリを表す空のパスの扱い</h2>

<p>頭や途中に入った空文字列 (カレントディレクトリを表す) は扱えたのですが、末尾にある場合はうまくいきませんでした。</p>

<p>セキュリティ上の問題もあるので、普通は設定しないと思うので、対応しなくても問題はないと思いますが、完全に変換したい場合は特別扱いを追加する必要がありそうでした。</p>

<pre><code class="console">%  bash -c 'PATH=:/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="" [1]="/bin")'
%  bash -c 'PATH=/bin::/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="" [2]="/bin")'
%  bash -c 'PATH=/bin:; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin")'
</code></pre>

<h2>まとめ</h2>

<p>zsh には元から <code>path</code> があるし、 <code>/bin/sh</code> には配列がないので bash 限定ではありますが、
<code>IFS=: read -r -a path &lt;&lt;&lt;"$PATH"</code> で実用上問題なく変換できるということがわかったので、必要な時には使うと良いのではないでしょうか。</p>

<p>2016-10-07 追記: 末尾の空文字列や改行に対応した<a href="/blog/2016-10-07-bash-path-to-array-again.html">続き</a>を書きました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lsで丸数字で始まるファイル名の順番が変だった]]></title>
    <link href="http://blog.n-z.jp/blog/2016-08-30-lc-collate-again.html"/>
    <updated>2016-08-30T22:58:34+09:00</updated>
    <id>http://blog.n-z.jp/blog/lc-collate-again</id>
    <content type="html"><![CDATA[<p>OS X で丸数字から始まるファイル名のファイルが入ったフォルダーを Finder で開くと丸数字の数字順に並んでいたのに、 <code>ls</code> で表示すると別の順番になっていたので原因を調べてみました。</p>

<!--more-->


<h2>動作確認環境</h2>

<ul>
<li>OS X Yosemite (10.10.5)</li>
<li>ls, uniq バージョン不明</li>
<li>sort (GNU coreutils) 5.93</li>
</ul>


<h2>動作確認</h2>

<p>Unicode 的に連続している 丸1 から 丸20 までのファイル名のファイルと、それに適当な ASCII の数字をつけたファイル名のファイルを作成して <code>ls</code> で表示してみました。</p>

<pre><code>%  touch $(ruby -e 'puts ("\u{2460}".."\u{2473}").to_a')
%  touch $(ruby -e 'puts ("\u{2460}".."\u{2473}").to_a.shuffle.map.with_index{|e,i|"#{e}#{i}"}')
%  ls
①      ⑤      ⑨      ⑬      ⑰      ⑧0     ⑲12    ⑮16    ⑥2     ⑬6
②      ⑥      ⑩      ⑭      ⑱      ⑤1     ⑱13    ⑳17    ④3     ⑫7
③      ⑦      ⑪      ⑮      ⑲      ⑨10    ②14    ⑪18    ⑭4     ⑦8
④      ⑧      ⑫      ⑯      ⑳      ⑯11    ⑩15    ③19    ⑰5     ①9
</code></pre>

<p>丸数字のみだと数字順に並んでいるのに、後ろに ASCII の数字をつけた部分は ASCII の数字順に並んでいます。
(numeric sort じゃないので 1,10,2 という順番になっているのがちょっとわかりにくいかもしれませんが。)</p>

<h2>Jessie での動作確認</h2>

<p>比較のために Debian GNU/Linux 8.5 (jessie) でも同様のファイルを作成して <code>ls</code> してみると丸数字のみのところもバラバラの順番でした。
何度か実行しても同じ結果なので、ランダムというわけではなくなんらかの基準がありそうですが、どういう順番なのかはわかりませんでした。</p>

<pre><code>% ls
⑧  ⑯  ⑥  ⑬  ⑫  ⑦  ①  ③  ⑮  ⑰  ④0  ⑨10  ⑳12  ⑫14  ⑭16  ①18  ⑩2  ⑥4  ⑯6  ⑱8
⑱  ⑩  ⑨  ⑪  ⑲  ⑤  ②  ④  ⑭  ⑳  ⑪1  ⑦11  ⑲13  ⑬15  ⑮17  ⑧19  ⑤3  ②5  ⑰7  ③9
</code></pre>

<h2>LC_COLLATE</h2>

<p><a href="http://blog.n-z.jp/blog/2013-10-31-lc-collate-uniq.html" title="LC_COLLATEの問題でuniqで丸数字が同一視されてしまう">LC_COLLATEの問題でuniqで丸数字が同一視されてしまう</a>のと同じ話かと思って、 <code>sort</code> や <code>uniq</code> も試してみたところ、同じ話のように見えました。
OS X では locale data が GNU/Linux とは違うようで <code>uniq</code> で同一視されるということは起きませんでした。</p>

<pre><code>% rbenv exec irb -r irb/completion --simple-prompt
&gt;&gt; IO.popen("uniq", "r+"){|io| io.puts ("\u{2460}".."\u{2473}").to_a; io.close_write; puts io.read }
①
②
③
④
⑤
⑥
⑦
⑧
⑨
⑩
⑪
⑫
⑬
⑭
⑮
⑯
⑰
⑱
⑲
⑳
=&gt; nil
&gt;&gt; IO.popen("sort", "r+"){|io| io.puts ("\u{2460}".."\u{2473}").to_a.shuffle; io.close_write; puts io.read }
①
②
③
④
⑤
⑥
⑦
⑧
⑨
⑩
⑪
⑫
⑬
⑭
⑮
⑯
⑰
⑱
⑲
⑳
=&gt; nil
&gt;&gt; IO.popen("sort", "r+"){|io| io.puts ("\u{2460}".."\u{2473}").to_a.shuffle.map.with_index{|e,i|"#{e}#{i}"}; io.close_write; puts io.read }
⑬0
⑥1
⑰10
⑱11
⑤12
⑮13
⑦14
④15
③16
⑪17
⑩18
①19
⑧2
⑲3
⑫4
⑳5
⑭6
②7
⑯8
⑨9
=&gt; nil
&gt;&gt; IO.popen({"LC_COLLATE"=&gt;"C"}, "sort", "r+"){|io| io.puts ("\u{2460}".."\u{2473}").to_a.shuffle.map.with_index{|e,i|"#{e}#{i}"}; io.close_write; puts io.read }
①6
②5
③0
④16
⑤19
⑥18
⑦7
⑧2
⑨8
⑩3
⑪12
⑫15
⑬4
⑭9
⑮14
⑯10
⑰1
⑱17
⑲13
⑳11
=&gt; nil
</code></pre>

<h2>一番自然に感じる並び順</h2>

<p>ruby の sort での結果は <code>LC_COLLATE=C</code> と同じように文字コード順になり、意味自然な並び順に感じました。
<code>LC_COLLATE=C ls</code> も同じ並び順でした。</p>

<pre><code>&gt;&gt; puts Dir['*'].sort
①
①9
②
②14
③
③19
④
④3
⑤
⑤1
⑥
⑥2
⑦
⑦8
⑧
⑧0
⑨
⑨10
⑩
⑩15
⑪
⑪18
⑫
⑫7
⑬
⑬6
⑭
⑭4
⑮
⑮16
⑯
⑯11
⑰
⑰5
⑱
⑱13
⑲
⑲12
⑳
⑳17
=&gt; nil
</code></pre>

<pre><code>% LC_COLLATE=C ls
①      ③      ⑤      ⑦      ⑨      ⑪      ⑬      ⑮      ⑰      ⑲
①9     ③19    ⑤1     ⑦8     ⑨10    ⑪18    ⑬6     ⑮16    ⑰5     ⑲12
②      ④      ⑥      ⑧      ⑩      ⑫      ⑭      ⑯      ⑱      ⑳
②14    ④3     ⑥2     ⑧0     ⑩15    ⑫7     ⑭4     ⑯11    ⑱13    ⑳17
</code></pre>

<h2>Finder での並び順</h2>

<p>Finder での並び順は <code>LC_COLLATE=C</code> での結果と同じかと思いきや、丸1 の後に 丸10 がきて、丸19, 丸2, 丸20, 丸3 のように並んでいたので、独特な感じでした。</p>

<pre><code>①
①9
⑩
⑩15
⑪
⑪18
⑫
⑫7
⑬
⑬6
⑭
⑭4
⑮
⑮16
⑯
⑯11
⑰
⑰5
⑱
⑱13
⑲
⑲12
②
②14
⑳
⑳17
③
③19
④
④3
⑤
⑤1
⑥
⑥2
⑦
⑦8
⑧
⑧0
⑨
⑨10
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LILO&東海道らぐオフラインミーティング 2016/08/14]]></title>
    <link href="http://blog.n-z.jp/blog/2016-08-14-lilo-tokaidolug.html"/>
    <updated>2016-08-14T13:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/lilo-tokaidolug</id>
    <content type="html"><![CDATA[<p><a href="http://lilo.connpass.com/event/37410/" title="LILO&amp;東海道らぐオフラインミーティング 2016/08/14">LILO&amp;東海道らぐオフラインミーティング 2016/08/14</a> に参加しました。</p>

<p>今回もアンカンファレンス形式でした。</p>

<p><a href="https://www.doorkeeper.jp/news/2016/7/25/change-in-pricing" title="Doorkeeper料金体系の変更について">Doorkeeper料金体系の変更について</a>でアナウンスされたように Doorkeeper が有料化されることに伴い、申し込みは connpass に移行しました。</p>

<!--more-->


<h2>メモ</h2>

<p>今回のメモです。</p>

<ul>
<li>いつものように鍵担当の人が遅れていたが、代理で開けていた</li>
<li>ハッシュタグ: <code>#lilo_jp</code> <code>#東海道らぐ</code></li>
<li>登録参加者数 14名</li>
<li>自己紹介から</li>
<li>最初は自分の発表「lilo.linux.or.jp の話」</li>
<li>「OpenStreetMap で地図を作ろう!」坂ノ下さん</li>
<li>Map Compare というサイトで Google Map と OSM の平安神宮を比較すると、OSMの方が詳しい</li>
<li>JOSM というクライアントで実演</li>
<li>ノード、ウェイ、エリアででできている</li>
<li>誰でも書き込めるし消せるので、悪質なユーザーへの対処は日々行っている</li>
<li><a href="http://wiki.openstreetmap.org/wiki/JA:Map_Features">http://wiki.openstreetmap.org/wiki/JA:Map_Features</a></li>
<li>鳥居のタグの話</li>
<li>どのようにタグをつけるのかは議論しながら決まっている</li>
<li>「IoTハウス」山内さん</li>
<li><a href="http://www.pepolinux.com">http://www.pepolinux.com</a> <a href="https://twitter.com/kujiranodanna">https://twitter.com/kujiranodanna</a></li>
<li>ラズパイで IoT ハウス</li>
<li>Tocos, IRKit</li>
<li>リセッタブルヒューズ</li>
<li>休憩</li>
<li>「お前が持っているLPICってどんなものよ? LPI 304受験報告記」中野さん</li>
<li>事前に公開されていた発表資料: <a href="https://bitbucket.org/itsango/lilo20160814">https://bitbucket.org/itsango/lilo20160814</a></li>
<li>有意性の期限がある</li>
<li>メリット: Linux が使える客観的な証拠になる</li>
<li>デメリット: 高い</li>
<li>304 の参考書: <a href="https://amazon.jp/dp/4844380540">https://amazon.jp/dp/4844380540</a></li>
<li>TOEIC みたいに何か統計処理された採点方式らしい</li>
<li>「Windows 10 タブレットに Ubuntu 16.04 を色々入れてみた 2016 年度版」Kapper さん</li>
<li><a href="http://www.slideshare.net/kapper1224/windows10ubuntu16042016install-ubuntu1604-on-windows10-tablet-63862255">http://www.slideshare.net/kapper1224/windows10ubuntu16042016install-ubuntu1604-on-windows10-tablet-63862255</a></li>
<li>Wubi for Ubuntu 16.04 が公式にタブレット対応</li>
<li>「Yocto を使った Linux Distro の作り方とハマり方」山口さん</li>
<li><a href="https://github.com/watatuki">https://github.com/watatuki</a></li>
<li><a href="https://www.yoctoproject.org/">https://www.yoctoproject.org/</a></li>
<li>たとえていえば Gentoo をクロスビルドにしたようなもの</li>
<li>layer を組み合わせて構成</li>
<li>recipe はソースと 1対1 対応</li>
<li>複数の layer の組み合わせが問題でビルドが通らなくなることがある</li>
<li>Android でおなじみの repo でいい感じできた</li>
<li>例: <a href="https://github.com/watatuki/agl-jetson-tk1">https://github.com/watatuki/agl-jetson-tk1</a></li>
<li>休憩</li>
<li>「TUI作業で便利なソフト2題」島田さん</li>
<li>opencocon の紹介</li>
<li>build server</li>
<li>このごろあった悩み: ファイルツリーを駆け回るのがめんどい</li>
<li>解決法：TUI ファイラー</li>
<li>mc (Midnight Commander)</li>
<li>あんまり慣れてない</li>
<li>Ctrl キー等を多用する</li>
<li>F1-F12 を使わなければならない</li>
<li>tmux とキーバインドが干渉しやすい</li>
<li>他に選択肢がないか?</li>
<li>FDclone</li>
<li>このごろあった悩み: git コマンドをいちいち叩くのがめんどい</li>
<li>tig</li>
<li>「Docker話」左川さん</li>
<li>vagrant で docker を試した話</li>
<li>box ファイルは VirtualBox で普通にインストールして不要なものを削除して作成した。</li>
<li>会場から packer がおすすめという話</li>
<li>さくらインターネットの Arukas はまだ誰も使ったことがない</li>
<li>今回の会場費は余剰金があるので無料になった。</li>
<li>「sedの話」田川さん</li>
<li>sed はプログラミング言語</li>
<li>デバッグオプション <code>-d</code> のある sed</li>
<li>sdb というデバッガをネットワーク経由で接続</li>
<li>「せっかくのプレゼン資料なんだから Git で管理しよう Slides を公開しよう」中野さん</li>
<li>事前に公開されていた資料: <a href="https://bitbucket.org/itsango/vcsforslides">https://bitbucket.org/itsango/vcsforslides</a></li>
<li><a href="http://progit-ja.github.io/">http://progit-ja.github.io/</a></li>
<li><a href="https://ja.wikipedia.org/wiki/OSS%E3%83%9B%E3%82%B9%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E6%AF%94%E8%BC%83" title="OSSホスティングサービスの比較">OSSホスティングサービスの比較</a></li>
<li>次は冬休みの予定 (その前に k-of.jp にも参加予定)</li>
</ul>


<h2>発表した内容</h2>

<p>lilo.linux.or.jp のサーバーの前回の発表以降の話をしました。</p>

<p>内容は大きく分けると 二要素認証は進捗なし、 letsencrypt の証明書は certbot に変わっても順調に使えている話、 ufw でアタックが多いポートをログに残さないようにした話でした。</p>

<p>スライドはいつも通り <a href="http://slide.rabbit-shocker.org/authors/znz/lilo-20160814/">Rabbit Slide Show</a> (<a href="https://rubygems.org/gems/rabbit-slide-znz-lilo-20160814">RubyGems</a>), <a href="http://www.slideshare.net/znzjp/lilo-20160814">SlideShare</a>, <a href="https://speakerdeck.com/znz/lilo-dot-linux-dot-or-dot-jp-falsehua">Speaker Deck</a> にあげています。(ソースは <a href="https://github.com/znz/lilo-20160814">github</a> にあげています。)
(しかし、2016-08-14現在 slide.rabbit-shocker.org (Rabbit Slide Show) には反映されていないようなので、 SlideShare か Speaker Deck でみてください。)
(2016-08-16現在、反映されたので Rabbit Slide Show でも見えるようになりました。)</p>

<iframe src="http://slide.rabbit-shocker.org/authors/znz/lilo-20160814/viewer.html"
        width="640" height="524"
        frameborder="0"
        marginwidth="0"
        marginheight="0"
        scrolling="no"
        style="border: 1px solid #ccc; border-width: 1px 1px 0; margin-bottom: 5px"
        allowfullscreen> </iframe>


<div style="margin-bottom: 5px">
  <a href="http://slide.rabbit-shocker.org/authors/znz/lilo-20160814/" title="lilo.linux.or.jp の話">lilo.linux.or.jp の話</a>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[letsencrypt の Rate Limit について]]></title>
    <link href="http://blog.n-z.jp/blog/2016-06-17-letsencrypt.html"/>
    <updated>2016-06-17T15:44:18+09:00</updated>
    <id>http://blog.n-z.jp/blog/letsencrypt</id>
    <content type="html"><![CDATA[<p><a href="http://www.clear-code.com/blog/2016/6/16.html" title="Let’s Encryptをcloudapp.azure.comで使おうとするときのハマりどころ">Let’s Encryptをcloudapp.azure.comで使おうとするときのハマりどころ</a>
という記事で Rate Limit の制限解除方法について誤解があるようなので、解説してみたいと思います。</p>

<!--more-->


<h2>Rate Limit について</h2>

<p><code>細かな制限はいろいろありますが、どうやら特定ドメインに対しては、週に20個のSSL/TLSサーバー証明書しか発行しないようです。そのため*.cloudapp.azure.comなどのように、皆がこぞってSSL/TLSサーバー証明書を取得しに行くような場合、見事に制限にひっかかってしまいます。</code>
と書いてありますが、これはその通りだと思います。</p>

<p><code>これを回避するには別途独自にドメインをとるなどしなければなりません。</code>
とありますが、 Dynamic DNS や IaaS などを利用している場合はプロバイダーに対応してもらうという方法があります。
また、その方が Cookie Monster と呼ばれる問題にも対処出来て望ましいと思います。</p>

<h2>適用例外について</h2>

<p><a href="https://github.com/certbot/certbot/issues/1607" title="DDNS Rate Limited">DDNS Rate Limited</a>
や
<a href="https://github.com/certbot/certbot/issues/2186" title="Too many certificates already issued for dynamic dns provider sub domain">Too many certificates already issued for dynamic dns provider sub domain</a>
のやりとりをみてもらえば詳細はわかるのですが、簡単に言うと</p>

<ul>
<li>プロバイダーに <a href="https://publicsuffix.org/">Public Suffix List</a> に登録してもらう</li>
<li><a href="https://github.com/letsencrypt/boulder">Let&rsquo;s Encrypt のサーバー</a> に反映してもらう</li>
</ul>


<p>ということになります。</p>

<h2>「正式版じゃなくてもいいから試してみたい」について</h2>

<p><code>certbot --help all</code> で出てくるヘルプにあるように <code>--test-cert</code> オプションか <code>--staging</code> オプションを使えば <code>/usr/lib/python2.7/dist-packages/certbot/constants.py</code> を書き換えるなどという方法をとらなくてもステージング環境の ACME サーバーを使えるようになります。</p>

<pre><code>% certbot --help all
(中略)
testing:
  The following flags are meant for testing purposes only! Do NOT change
  them, unless you really know what you're doing!

  --debug               Show tracebacks in case of errors, and allow
                        letsencrypt-auto execution on experimental platforms
                        (default: False)
  --no-verify-ssl       Disable SSL certificate verification. (default: False)
  --tls-sni-01-port TLS_SNI_01_PORT
                        Port number to perform tls-sni-01 challenge. Boulder
                        in testing mode defaults to 5001. (default: 443)
  --http-01-port HTTP01_PORT
                        Port used in the SimpleHttp challenge. (default: 80)
  --break-my-certs      Be willing to replace or renew valid certs with
                        invalid (testing/staging) certs (default: False)
  --test-cert, --staging
                        Use the staging server to obtain test (invalid) certs;
                        equivalent to --server https://acme-
                        staging.api.letsencrypt.org/directory (default: False)
(後略)
</code></pre>

<h2>まとめ</h2>

<p>Dynamic DNS や IaaS などを使っていて Rate Limit に引っかかった時の対処方法について説明しました。
また Cookie Monster と呼ばれる問題の影響についても少し触れました。</p>

<p>また、ステージング環境の ACME サーバーを使うのにソースを書き換えなくてもオプション指定で済むということを説明しました。</p>
]]></content>
  </entry>
  
</feed>
