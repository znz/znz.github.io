<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2017-07-07T00:32:28+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hyper-V のゲスト環境で systemd timer がうまく動いていなかった]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-07-hyperv-systemd-timer.html"/>
    <updated>2017-07-07T00:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/hyperv-systemd-timer</id>
    <content type="html"><![CDATA[<p>Hyper-V のゲストとしてインストールした Linux 環境で systemd timer の <code>RandomizedDelaySec</code> がおかしくて timer が実行されないことがあったのですが、Hyper-V の時刻の同期との相性が悪いのが原因でした。</p>

<!--more-->


<h2>環境</h2>

<ul>
<li>ホスト: Windows Server 2012</li>
<li>ゲスト: Ubuntu 16.04.2 LTS (xenial) と Debian GNU/Linux 9.0 (stretch)</li>
</ul>


<h2>現象</h2>

<p>journalctl で過去のログを確認してみると</p>

<pre><code> 6月 28 12:07:56 hostname systemd[9928]: Time has been changed
 6月 28 12:07:59 hostname systemd[9928]: Time has been changed
 6月 28 12:08:04 hostname systemd[9928]: Time has been changed
 6月 28 12:08:09 hostname systemd[9928]: Time has been changed
 6月 28 12:08:14 hostname systemd[9928]: Time has been changed
 6月 28 12:08:19 hostname systemd[9928]: Time has been changed
</code></pre>

<p>のように Time has been changed が頻繁に記録されていました。</p>

<p>再起動した後からは RandomizedDelaySec が設定されている timer のランダムな時間挿入が Time has been changed の直後におきていました。</p>

<pre><code> 6月 28 15:07:51 hostname systemd[1]: Time has been changed
 6月 28 15:07:51 hostname systemd[1]: apt-daily-upgrade.timer: Adding 46min 16.478521s random time.
 6月 28 15:07:51 hostname systemd[1]: apt-daily.timer: Adding 3h 45min 54.621700s random time.
 6月 28 15:07:56 hostname systemd[1]: Time has been changed
 6月 28 15:07:56 hostname systemd[1]: apt-daily-upgrade.timer: Adding 25min 59.320458s random time.
 6月 28 15:07:56 hostname systemd[1]: apt-daily.timer: Adding 11h 34min 9.012513s random time.
 6月 28 15:08:01 hostname systemd[1]: Time has been changed
 6月 28 15:08:01 hostname systemd[1]: apt-daily-upgrade.timer: Adding 42min 37.932995s random time.
 6月 28 15:08:01 hostname systemd[1]: apt-daily.timer: Adding 4h 48min 31.255279s random time.
 6月 28 15:08:06 hostname systemd[1]: Time has been changed
 6月 28 15:08:06 hostname systemd[1]: apt-daily-upgrade.timer: Adding 13min 44.192537s random time.
 6月 28 15:08:06 hostname systemd[1]: apt-daily.timer: Adding 38min 56.349412s random time.
</code></pre>

<p>自作した timer が実行されなくて <code>journalctl -u local-backup.timer</code> のように調べた時に「Adding &hellip; random time.」のログで埋まっていて、他の動いている timer との違いも特になくて悩んでいましたが、ふと <code>journalctl</code> (引数なし) を実行してみたら「Time has been changed」とセットでおきていることに気づきました。</p>

<h2>解決策</h2>

<p>「Time has been changed」で検索して最初に出てきた <a href="https://askubuntu.com/questions/888493/var-log-syslog-systemd1-time-has-been-changed-message-every-5-seconds">16.04 - /var/log/syslog &lsquo;systemd[1]: Time has been changed&rsquo; message every 5 seconds - Ask Ubuntu</a> に</p>

<blockquote><p>I encountered this issue of &ldquo;systemd[&hellip;]Time has been changed&rdquo; messages logged every five seconds in /var/log/syslog on a 16.04 server running under Windows 8.1 Hyper-V. To fix it, I disabled time synchronization on the Hyper-V side. In Hyper-V Manager, I highlighted the VM, selected &ldquo;Settings&hellip;&rdquo;, then &ldquo;Integration Services&rdquo;, unchecked &ldquo;Time synchronization&rdquo;, and clicked Apply. The messages stopped instantly - no VM restart was required.</p></blockquote>

<p>と書いてあったので、「設定&hellip;」から「統合サービス」の「時刻の同期」のチェックを外して (再起動なしで) 解決しました。</p>

<h2>解決確認</h2>

<p>「Time has been changed」も出なくなって「Adding &hellip; random time.」も出なくなって、翌日まで待ってみるとちゃんと実行されていたので、解決したようです。</p>

<h2>まとめ</h2>

<p>ntp サーバー機能も必要で、 ntp パッケージを入れている環境で発生したので、時刻の同期の仕方によっては発生しないのかもしれませんが、「Time has been changed」で検索して出てきた他の方法はログを無視するだけとか、根本的な解決になっていないものが多そうだったので、Hyper-V との組み合わせなら systemd-timesyncd でも発生するのかもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debian/Ubuntuで暗号化 LVM を使いつつ自動起動する]]></title>
    <link href="http://blog.n-z.jp/blog/2017-07-01-cryptsetup.html"/>
    <updated>2017-07-01T14:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/cryptsetup</id>
    <content type="html"><![CDATA[<p>さくらの VPS 環境でも ssh などの秘密鍵を置くなら、ディスクの暗号化は使いたいので、リリースされたばかりの Debian 9 の ISO をアップロードしてインストールして、暗号化されていない <code>/boot</code> に鍵ファイルを置いて自動起動を設定しました。</p>

<p>自動起動を設定するということはセキュリティ的には弱くなりますが、そこはホストを信用するということにしています。</p>

<p>自動起動設定時に <code>/etc/crypttab</code> の設定ミスで起動しなくなるということがあったので、そういう時の直し方も含めてまとめてみました。</p>

<!--more-->


<h2>確認環境</h2>

<ul>
<li>Debian GNU/Linux 9.0 (stretch)</li>
</ul>


<p>Ubuntu でも debian-installer ベースのインストーラーを使った場合は同じだと思います。
(Live 環境が起動するデスクトップ版のインストーラーの場合は暗号化 LVM でのインストールができるかどうか確認していないのでわかりません。)</p>

<p>他のバージョンの Debian でも luks 対応の cryptsetup があれば同じだと思います。</p>

<h2>インストール</h2>

<p>普通に netinst の iso でインストールします。</p>

<p>ただし途中の「ディスクのパーティショニング」で「ガイド - ディスク全体を使い、暗号化 LVM をセットアップする」を選んだ場合が対象です。
パーティションは <code>/</code> (と <code>/boot</code>) だけを想定しています。
暗号化のパスフレーズは鍵ファイル設定前の起動時と、鍵ファイルの追加時などしか使わないので、長くて強いものにしておくと良いと思います。</p>

<p>VirtualBox などの仮想環境で試す時は、暗号化前のランダムなデータで上書きでデータ用のパーティション全体に書き込みが発生するので、可変サイズのディスクではなく固定サイズのディスクにしておくと良いかもしれません。</p>

<h2>鍵ファイル作成</h2>

<p>まず、鍵ファイルを作成します。
内容作成前に root しか読み書きできないようにするために、touch して chmod しておきます。
次に urandom から読んだランダムデータを鍵ファイルに書き込みます。
前回設定したときは count=1 で 1024 バイトにしていましたが、今回は 4096 バイトにしてみました。
最後に root はパーミッションだと書き込み禁止できないので、誤操作防止 (削除やヒストリーから dd を再実行してしまうなど) のために chattr で ext2 の immutable 属性をつけておきます。(確認は <code>sudo lsattr /boot/keyfile</code>)</p>

<pre><code>sudo touch /boot/keyfile
sudo chmod 400 /boot/keyfile
sudo dd if=/dev/urandom of=/boot/keyfile bs=1024 count=4
sudo chattr +i /boot/keyfile
</code></pre>

<h2>情報確認</h2>

<ul>
<li><code>/etc/fstab</code>: <code>/dev/mapper/HOSTNAME--vg-root</code> が <code>/</code> に、 <code>/dev/mapper/HOSTNAME--vg_swap_1</code> がスワップパーティションに設定されています (<code>HOSTNAME</code> はインストーラーで設定したホスト名)</li>
<li><code>/etc/crypttab</code>: <code>vda5_crypt UUID=... none luks</code> で UUID で指定された <code>/dev/vda5</code> の暗号化が解除された状態が <code>/dev/mapper/vda5_crypt</code> として見えるということがわかります</li>
<li><code>lsblk</code>: ツリー上にみえます (<code>lsblk -f</code> だと UUID も表示されました)</li>
<li><code>ls -l /dev/disk/by-uuid</code>: uuid とデバイスの対応を確認できます (これで確認できる vda1 のパスをあとで使います)</li>
<li><code>sudo cryptsetup luksDump /dev/vda5</code>: luks の情報が表示できます (最初は Key Slot 0 だけ ENABLED で 1 から 7 は DISABLED になっています)</li>
</ul>


<h2>鍵追加</h2>

<p><code>cryptsetup luksAddKey</code> で鍵を追加します。
ここで最初に設定したパスフレーズが必要です。
なぜか <code>Key slot 0 unlocked.</code> が2回でましたが、特に問題はなさそうです。</p>

<pre><code>$ sudo cryptsetup -v luksAddKey /dev/vda5 /boot/keyfile
Enter any passphrase:
Key slot 0 unlocked.
Key slot 0 unlocked.
Command successful.
</code></pre>

<h2>鍵削除</h2>

<p>違うファイルを登録してしまったり、同じ鍵を複数回追加してしまったりしたときには <code>cryptsetup luksRemoveKey</code> で削除できます。
この場合はその鍵自身で unlock されるようなので、パスフレーズは不要でした。</p>

<pre><code>$ sudo cryptsetup -v luksRemoveKey /dev/vda5 /boot/keyfile
Key slot 1 unlocked.
Key slot 1 selected for deletion.
Command successful.
</code></pre>

<p>特定の Key Slot を DISABLED に戻したいときは <code>cryptsetup luksKillSlot</code> が使えます。
この場合はパスフレーズが必要でした。</p>

<pre><code>$ sudo cryptsetup -v luksKillSlot /dev/vda5 2
Key slot 2 selected for deletion.
Enter any remaining passphrase:
Key slot 0 unlocked.
Command successful.
</code></pre>

<h2>自動起動設定</h2>

<p>この段階ではまだ暗号化解除に使える鍵が増えただけで、再起動してもパスフレーズを要求されるままです。</p>

<p><code>/etc/crypttab</code> を以下のように書き換えます。</p>

<pre><code>vda5_crypt UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /dev/disk/by-uuid/yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy:/keyfile luks,keyscript=/lib/cryptsetup/scripts/passdev
</code></pre>

<p>xxx&hellip; の方の UUID は <code>/dev/vda5</code> の UUID なので、そのまま書き換えません。
第3項目の <code>none</code> を <code>/boot</code> パーティションのデバイスを UUID を使って指定したパス + <code>:</code> + <code>/boot</code> パーティション内での <code>keyfile</code> へのパスに書き換えます。
第4項目の <code>luks</code> は <code>luks,keyscript=/lib/cryptsetup/scripts/passdev</code> に書き換えます。
<code>passdev</code> は <code>cryptsetup</code> パッケージで用意されているファイルなので、そのまま書きます。</p>

<h2>initramfs 更新</h2>

<p>書き換えてもまだブートプロセスに反映されていないので、再起動してもパスフレーズを要求されるままなので、
最後に initramfs を更新します。</p>

<pre><code>sudo update-initramfs -u
</code></pre>

<p>これで再起動すると自動起動するようになります。</p>

<p>keyscript のパスが間違っていると以下のように WARNING が出るので、再起動する前に気づくことができますが、
keyfile の指定は間違っていても何も出ないので注意する必要があります。</p>

<pre><code>$ sudo update-initramfs -u
update-initramfs: Generating /boot/initrd.img-4.9.0-3-amd64
cryptsetup: WARNING: target vda5_crypt has an invalid keyscript, skipped
cryptsetup: WARNING: target vda5_crypt has an invalid keyscript, skipped
</code></pre>

<h2>起動失敗した場合</h2>

<p><code>/etc/crypttab</code> の設定をミスして起動しなくなった場合、 netinst の ISO からレスキューモードで起動すればパスフレーズでマウントできます。
そしてルートファイルシステムとして <code>/dev/HOSTNAME-vg/root</code> (<code>HOSTNAME</code> はインストーラーで設定したホスト名) を選び、 <code>/boot</code> パーティションもマウントしてシェルを起動します。</p>

<p>シェルは <code>/bin/sh -i</code> なので使いにくければ <code>bash</code> を起動して、<code>/etc/crypttab</code> を修正して <code>update-initramfs -u</code> で反映させます。
そして exit で抜けて再起動します。</p>

<p>レスキュー環境での修正が難しそうなら、 <code>none</code> と <code>luks</code> だけに戻して、パスフレーズを使う通常起動にしてから直すという方法もあります。</p>

<h2>最後に</h2>

<p>知らないところで暗号化が解除できてしまうのは、コンソール接続が毎回必要になることとのトレードオフですが、鍵ファイルでも解約時に <code>chattr -i /boot/keyfile; shred --remove /boot/keyfile</code> でディスク全体の削除に似た効果を期待できます。ただし <a href="https://linuxjm.osdn.jp/html/GNU_coreutils/man1/shred.1.html">Man page of SHRED</a>の警告に書いてあるように上書きを期待しているので、 ext2 になっている <code>/boot</code> はファイルシステム的には大丈夫だとしても、その下のブロックデバイスで上書きされていない可能性は残りそうです。</p>

<h2>まとめ</h2>

<p>暗号化 LVM を使うことで macOS の FileVault や Windows BitLocker のように簡単にディスクほぼ全体 (<code>/boot</code> を除く) を暗号化できました。
そして、再起動したい時に常にコンソールに接続できるとは限らない環境向けに鍵ファイルで自動起動の設定もできました。</p>

<p>トレードオフもちゃんと考えた上で設定すれば、安全な環境が簡単に作れると思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[letsencryptの証明書の更新に失敗していた(IPv6が原因だった)]]></title>
    <link href="http://blog.n-z.jp/blog/2017-06-14-failed-to-update-letsencrypt.html"/>
    <updated>2017-06-14T19:36:08+09:00</updated>
    <id>http://blog.n-z.jp/blog/failed-to-update-letsencrypt</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s Encrypt の証明書の自動更新が失敗しているサーバーがあって、原因を調べたら AAAA レコードに設定している IPv6 アドレスが間違っていたのが原因でした。</p>

<!--more-->


<h2>環境</h2>

<ul>
<li>Debian GNU/Linux 8.8 (jessie)</li>
<li>certbot 0.10.2-1~bpo8+1</li>
<li>さくらインターネットの VPS で IPv6 を使用 (過去に tun6rd を使っていた)</li>
</ul>


<h2>現象</h2>

<p>2016-03-29 に現在のサーバーに移動した時に A レコードを書き換えただけではなく、追加で tun6rd の頃の IPv6 アドレスを AAAA レコードに設定してしまいました。
別の IPv6 アドレスを設定しているサーバーからの接続に時間がかかるという現象が発生していたものの、原因がわからず、ずっとそのままの状態でした。</p>

<p>StartCom の証明書が事実上使えなくなってしまったので、 2016-12-04 に Let&rsquo;s Encrypt の証明書に変更しました。
初回の証明書の発行のときには問題なく発行できていました。
2017-02-03,2017-04-04 の自動更新も問題なく動いていました。</p>

<p>6月の自動更新で突然失敗するようになり、数日様子を見ていましたが、失敗し続けていたので、詳しく調査することにしました。</p>

<h2>調査</h2>

<p>色々悩んだ結果、 <code>/var/log/letsencrypt/letsencrypt.log</code> を眺めていたところ <code>addressUsed</code> に IPv6 のアドレスが出ているのに気づいて、もしかして、と思ってさらに調べることにしました。</p>

<pre><code>"validationRecord": [
  {
    "url": "http://XXX.example.org/.well-known/acme-challenge/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
    "hostname": "XXX.example.org",
    "port": "80",
    "addressesResolved": [
      "XX.XXX.XXX.XX",
      "2001:e41:XXXX:XXXX::1"
    ],
    "addressUsed": "2001:e41:XXXX:XXXX::1",
    "addressesTried": []
  }
]
</code></pre>

<p>該当のサーバーから <code>ping6 www.kame.net</code> などは問題なく通り、該当サーバーへの <code>ping6</code> も問題なく通ることなどを確認していたところ、IPv6 アドレスが違うことに気づきました。</p>

<h2>修正</h2>

<p>AAAA レコードを <code>2403:3a00:XXX:XXXX:XX:XXX:XXX:XX</code> に修正して、急いでいるわけでもないので certbot の自動実行を待ってみたところ、ちゃんと更新されました。</p>

<h2>関連情報</h2>

<p><a href="https://letsencrypt.jp/usage/dvsni-challenge-error.html">DVSNI challenge エラーの対処法</a>に <code>urn:acme:error:connection</code> の原因の例として A レコードのことは書いてあったのに AAAA レコードのことが書かれていなくて、可能性に気づくのが遅れたので、 AAAA レコードのことも書いてあると良いのではないかと思いました。</p>

<h2>まとめ</h2>

<p>Let&rsquo;s Encrypt のサーバーの実装が変わったのか、IPv6 アドレスから IPv4 へのフォールバックをしなくなっていて、IPv6 アドレスの間違いに気づくことができ、接続が遅かった現象も解決しました。</p>

<p>主に IPv4 を使っているとなかなか気づかないので、 AAAA レコードを設定するときは、ちゃんと確認しておかないと、後でわかりにくいトラブルの原因になると実感しました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cron(crontab)の代わりにsystemdのtimerを使う]]></title>
    <link href="http://blog.n-z.jp/blog/2017-06-04-cron-systemd-timer.html"/>
    <updated>2017-06-04T14:18:19+09:00</updated>
    <id>http://blog.n-z.jp/blog/cron-systemd-timer</id>
    <content type="html"><![CDATA[<p>最近 <a href="https://github.com/znz/ansible-playbook-gitlab-dokku">gitlab omnibus などの環境</a>を作っていて、<a href="https://github.com/znz/ansible-role-gitlab-ce">GitLab CE の role</a> でバックアップ処理を定期実行するのに crontab ではなく systemd の timer を使ってみました。</p>

<!--more-->


<h2>利点</h2>

<ul>
<li>systemd 管理下で統一的に扱えるので、覚えれば楽</li>
<li>ログも journald で統一されるので cron だといちいちメールが飛ぶと鬱陶しいような粒度でも簡単にログに残せる</li>
<li>環境変数なども含めた環境が本番と同じ状態ですぐに実行を試しやすい</li>
<li>systemd 依存の機能が使える (後述の例では After と Requires)</li>
</ul>


<p>などが利点に感じました。</p>

<h2>欠点</h2>

<ul>
<li>情報が cron (crontab) に比べてまだ少ないので、何かあったときに調べにくい</li>
<li>systemd に大きく依存してしまう</li>
</ul>


<p>などが欠点に感じました。</p>

<h2>確認環境</h2>

<ul>
<li>Ubuntu 16.04.2 LTS (xenial)</li>
<li>systemd 229-4ubuntu17</li>
</ul>


<h2>情報表示</h2>

<ul>
<li><code>systemctl list-timers</code> でタイマーの次回実行予定時刻、前回実行時刻などを含めて表示されます。</li>
<li><code>systemctl status systemd-tmpfiles-clean.timer</code> でタイマーの情報、<code>systemctl status systemd-tmpfiles-clean.service</code> で実行されるサービスの情報が表示されます。</li>
<li><code>journalctl -u systemd-tmpfiles-clean.timer</code> や <code>journalctl -u systemd-tmpfiles-clean.service</code> でログが表示されます。 <code>systemd-journal</code> グループに入っていない場合は <code>sudo</code> が必要かもしれません。 <code>systemd-journal</code> に入っていれば <code>systemctl status</code> でも最近のログが表示されます。</li>
<li>Type=oneshot (後述) の場合、ログの Starting が実行開始時刻で Started が実行終了時刻になるようです。</li>
</ul>


<h2>設定ファイルの場所</h2>

<p><code>systemctl status</code> で <code>Loaded: loaded (/lib/systemd/system/systemd-tmpfiles-clean.timer; static; vendor preset: enabled)</code> のようにパスが出るので、システムのものは <code>/lib/systemd/system/</code> にあることがわかります。</p>

<p>タイマーではありませんが、 gitlab-ce では <code>/usr/lib/systemd/system/gitlab-runsvdir.service</code> に service が入っていたので、 <code>/usr/lib/systemd/system/</code> も参照されるようです。</p>

<p>自分で作成する場合は systemd の流儀に従って <code>/etc/systemd/system/</code> に作成すれば良いと思います。</p>

<h2>service 作成</h2>

<p><code>/etc/systemd/system/gitlab-backup.service</code> を以下の内容で作成しました。</p>

<pre><code>[Unit]
Description=Backup gitlab
After=gitlab-runsvdir.service
Requires=gitlab-runsvdir.service

[Service]
Type=oneshot
ExecStart=/opt/gitlab/bin/gitlab-rake gitlab:backup:create CRON=1
</code></pre>

<ul>
<li>Unit の Description は適当にわかりやすい説明を書けば良いと思います。</li>
<li>Service の Type は cron 代わりに使う場合は oneshot にするのが普通のようです。</li>
<li>ExecStart に crontab で書いていたようにコマンドを書きます。 crontab と同じように、複雑な場合は無理にここに書こうとせずに別途シェルスクリプトなどを作成して実行する方が良さそうです。</li>
<li>After と Requires はバックアップ処理を実行するのに postgresql などが実行されている必要がありそうだったので書きました。このあたりが必要かどうかは用途によると思います。</li>
</ul>


<h2>timer 作成</h2>

<p><code>/etc/systemd/system/gitlab-backup.timer</code> は以下の内容で作成しました。</p>

<pre><code>[Unit]
Description=Backup gitlab

[Timer]
OnCalendar=*-*-* 2,14:00
Persistent=true

[Install]
WantedBy=timers.target
</code></pre>

<ul>
<li>Unit の Description は適当にわかりやすい説明を書けば良いと思います。</li>
<li>OnCalendar で毎日 2:00 と 14:00 に実行するように設定しています。ローカルタイムでの指定になります。詳細は systemd のドキュメントを参照してください。</li>
<li>Persistent=true は<a href="https://wiki.archlinuxjp.org/index.php/Systemd/%E3%82%BF%E3%82%A4%E3%83%9E%E3%83%BC" title="systemd/タイマー - ArchWiki">systemd/タイマー - ArchWiki</a>によると「システムの電源が切られていたなどの理由で、最後の起動時間を過ぎていた場合、すぐに実行されます」ということのようで、 anacron 的な動作が期待できるかと思って指定しています。</li>
<li>Install の WantedBy=timers は <code>systemctl enable</code> や <code>systemctl disable</code> ができるようにするための定型句のようです。</li>
</ul>


<h2>設定反映</h2>

<p><code>sudo systemctl daemon-reload</code> で反映させます。
新規作成時などは必要ないかもしれませんが、実行しておくと確実です。</p>

<h2>有効化</h2>

<p><code>sudo systemctl enable gitlab-backup.timer</code> で <code>/etc/systemd/system/timers.target.wants/gitlab-backup.timer</code> に <code>/etc/systemd/system/gitlab-backup.timer</code> へのシンボリックリンクが作成されて有効になります。</p>

<h2>無効化</h2>

<p><code>sudo systemctl disable gitlab-backup.timer</code> で無効に戻せます。
timer を消したくなったときには disable してから timer ファイル (と service ファイル) を削除すると良いと思います。
(ファイル削除後は <code>sudo systemctl daemon-reload</code> もすると良いかもしれません。)</p>

<h2>テスト実行</h2>

<p><code>sudo systemctl start gitlab-backup.service</code> でテスト実行できます。</p>

<h2>実行時間を散らす</h2>

<p>Timer セクションに RandomizedDelaySec を設定するとランダムスリープをいれて実行時間をばらけさせることができます。
<code>certbot.timer</code> などで使われています。</p>

<p>試しに <code>RandomizedDelaySec=10min</code> といれてみると、これを使ったときには設定が反映されたタイミングや前回の実行終了後などの次の実行が決まった段階でランダムスリープの時間が決まるようで、 <code>journalctl -u gitlab-misc-backup.timer</code> で <code>gitlab-misc-backup.timer: Adding 6min 33.234976s random time.</code> と出て、 <code>systemctl list-timers</code> の NEXT も遅延後の時刻になっていて、実行された時のログの Starting もその時刻以降 (AccuracySec がデフォルト 1min なので NEXT に出ていた時刻よりちょっと遅かった) になっていました。</p>

<h2>atd</h2>

<p>crond の crontab の代わりは service ファイルと timer ファイルを作成して反映させて有効にして、という操作が必要でした。</p>

<p>atd の at の代わりとしては systemd-run というコマンドがあるようです。
試しに使ったことしかないので、紹介だけに留めておきます。</p>

<h2>まとめ</h2>

<p>設定ファイルが複数必要だったり、反映するのに一手間必要だったりして、使い始めは crontab より面倒ですが、 systemd との連携が必要だったり、ログ管理をまとめたかったり、 RandomizedDelaySec のように systemd の機能を使った方がすっきりする場合などは積極的に timer を使っていくと良いのではないかと思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenSSH の ~/.ssh/config の見直しをした]]></title>
    <link href="http://blog.n-z.jp/blog/2017-05-20-openssh-config.html"/>
    <updated>2017-05-20T14:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/openssh-config</id>
    <content type="html"><![CDATA[<p>最新の man を参考にしながら OpenSSH の <code>~/.ssh/config</code> の設定を見直してみたので、使っている設定項目についてまとめてみました。</p>

<!--more-->


<h2>確認バージョン</h2>

<p>全て確認したわけではないですが、古いのや新しいのを確認したいときはこの辺りを使いました。</p>

<ul>
<li>Debian GNU/Linux 8.7 (jessie) の OpenSSH_6.7p1 Debian-5+deb8u3, OpenSSL 1.0.1t  3 May 2016</li>
<li>archlinux の OpenSSH_7.5p1, OpenSSL 1.1.0e  16 Feb 2017</li>
</ul>


<h2>参考</h2>

<p><a href="https://euske.github.io/openssh-jman/ssh_config.html">https://euske.github.io/openssh-jman/ssh_config.html</a> の日本語訳や <code>man ssh_config</code> で英語のマニュアルを確認したりしました。</p>

<h2>優先順位</h2>

<ol>
<li>コマンドラインオプション</li>
<li>ユーザごとの設定ファイル <code>~/.ssh/config</code></li>
<li>システム全体にわたる (system-wide) 設定ファイル <code>/etc/ssh/ssh_config</code></li>
</ol>


<p>の順番で最初に見つかった設定が使われます。</p>

<p>設定ファイルは <code>Host</code> の行で区切られていて、設定ファイルの中でも前に見つかったものが優先されるので、ホストごとの設定をファイルの先頭の方に、全体的な設定を末尾の方に書くことを想定しているようです。</p>

<h2>Host</h2>

<p><code>Host</code> または <code>Match</code> は設定ファイルの区切りです。</p>

<p>コマンドラインで指定されたホスト名にマッチするので、<code>ssh localhost</code> の時には <code>Host localhost</code> の設定が使われて <code>Host 127.0.0.1</code> や <code>Host ::1</code> の設定は使われません。</p>

<h2>CheckHostIP</h2>

<p>同じホスト名なのに IP アドレスが変わる可能性がある場合に <code>CheckHostIP no</code> にしておくと <code>known_hosts</code> に IP アドレスが記録されないようになります。</p>

<p>DNS を工夫して LAN 内では直接、外からはルーターのポートフォワーディング経由で接続できるようにしている場合など、接続の仕方によって変わる場合や、 GitHub などのようにホスト鍵はそのままで IP アドレスが変わることがあるサービスを使っている時に使うと良いと思います。</p>

<h2>Ciphers</h2>

<p><a href="/blog/2014-08-11-openssh-arcfour256.html">vagrantなどのローカルへのssh接続のみarcfour256で高速化する</a>ということをしていたこともありましたが、<a href="https://srad.jp/comment/2875861">https://srad.jp/comment/2875861</a> のリンク先の <a href="http://www.openssh.com/txt/release-7.1">http://www.openssh.com/txt/release-7.1</a> に</p>

<pre><code>Future deprecation notice
=========================

We plan on retiring more legacy cryptography in the next release
including:

 * Refusing all RSA keys smaller than 1024 bits (the current minimum
   is 768 bits)

 * Several ciphers will be disabled by default: blowfish-cbc,
   cast128-cbc, all arcfour variants and the rijndael-cbc aliases
   for AES.

 * MD5-based HMAC algorithms will be disabled by default.

This list reflects our current intentions, but please check the final
release notes for OpenSSH 7.2 when it is released.
</code></pre>

<p>と書いてあって、 <a href="http://www.openssh.com/txt/release-7.2">http://www.openssh.com/txt/release-7.2</a> には</p>

<pre><code>Potentially-incompatible changes
================================

This release disables a number of legacy cryptographic algorithms
by default in ssh:

 * Several ciphers blowfish-cbc, cast128-cbc, all arcfour variants
   and the rijndael-cbc aliases for AES.

 * MD5-based and truncated HMAC algorithms.

These algorithms are already disabled by default in sshd.
</code></pre>

<p>となっていて arcfour 系はデフォルトでは使われないようになったようなので、 arcfour 系はもうあまり使わない方が良さそうです。</p>

<p>OpenSSH_7.5p1 で <code>ssh -Q cipher</code> を確認しても残っていますが、サーバー側で無効になっていると結局使えないので、将来的には使えないものと考えて良さそうです。</p>

<p>速度を気にするなら <a href="http://blog.uu59.org/2014-04-12-ssh-ciphers.html">OpenSSH 6.6p1の各cipherのスループットを計測した</a> を参考にして実際に計測するのが良さそうです。</p>

<p>試した感じだと <code>chacha20-poly1305@openssh.com</code> が遅くて <code>aes*-ctr</code> 系と <code>aes*-gcm@openssh.com</code> 系はそんなに違いがない感じだったので、速度を気にする場合は</p>

<pre><code>Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-gcm@openssh.com,aes256-gcm@openssh.com
</code></pre>

<p>ぐらいでいいのではないかと思いました。(セキュリティを優先するならビット数が多い方を前に持ってくると良いと思います。)</p>

<h2>ControlMaster, ControlPath, ControlPersist</h2>

<p>デフォルトの <code>ControlMaster no</code> のまま、使いたい Host だけ <code>ControlMaster auto</code> を設定する方法と、末尾の <code>Host *</code> でデフォルトを <code>ControlMaster auto</code> にしてしまって不要な Host や設定していると問題が起きる Host だけ <code>ControlMaster no</code> を設定する方法があると思います。</p>

<p><code>ControlPath</code> は XDG Base Directory Specification の <code>XDG_CACHE_HOME</code> を参考にして <code>$HOME/.cache</code> を使って <code>ControlPath ~/.cache/ssh,%r,%h,%p,sock</code> にしています。(区切りはどの OS でも問題が起きにくそうなのとホスト名の中の <code>.</code> と区別できるように、ということで <code>,</code> にしています。)</p>

<p><code>ControlPersist</code>は OpenSSH 5.6 で、存在を知った当時はまだ対応していない OS の方が多かったので、使っていませんでしたが、せっかくなので <code>ControlPersist 10</code> に設定してみました。</p>

<h2>DynamicForward</h2>

<p>SOCKS proxy 機能です。</p>

<p>ブラウザーの接続元 IP アドレスを変えてテストしたい時に使うことがあったので、</p>

<pre><code>Host hoge hoge-proxy
HostName FQDNかIPアドレス
# ...その他の設定...

Host hoge-proxy
DynamicForward 1088
</code></pre>

<p>のように、<code>ssh hoge-proxy</code> で有効になるように設定していることもありましたが、滅多に使わないので、コマンドラインで <code>-D 1080</code> のように明示的に指定して使うことの方が多くなりました。</p>

<h2>ExitOnForwardFailure</h2>

<p>ポートフォワーディングを設定しているのにポートフォワーディングされていないことの方が、ポートフォワーディングを設定している先に多重に接続できなくて困ることより多かったので、 <code>ExitOnForwardFailure yes</code> で有効にしています。</p>

<h2>FingerprintHash</h2>

<p>サーバー側の OpenSSH が古い時に <code>ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub</code> などの結果が md5 固定なので、クライアントの OpenSSH が新しい時に <code>ssh -o FingerprintHash=md5</code> で md5 に変更して照合しています。</p>

<p>サーバー側が新しくて、クライアントが古い時に md5 の fingerprint を出すのは <code>ssh-keygen -l -E md5 -f /etc/ssh/ssh_host_ecdsa_key.pub</code> などのようです。</p>

<p>おまけの情報として、簡単に fingerprint の照合をするのに、適当なエディターにコピペして検索して全体がハイライトされるのを確認するという方法があります。
ダウンロードしたファイルのハッシュの確認にも同じ方法を使っています。</p>

<h2>ForwardAgent, ForwardX11</h2>

<p>セキュリティリスクがあるので、必要な時はコマンドラインで明示的に <code>-A</code> や <code>-X</code> で使うようにしています。</p>

<h2>HashKnownHosts</h2>

<p>不便さの方が大きい (IP アドレスも追加されているかどうか確認しにくいなど) と感じているので、 <code>HashKnownHosts no</code> で無効にしています。</p>

<h2>HostKeyAlias</h2>

<p>多段 SSH の時などに使っています。</p>

<h2>HostName</h2>

<pre><code>Host hoge hoge.example.com
HostName hoge.example.com
</code></pre>

<p>のようにして、 FQDN の代わりに短いホスト名で接続できるようにしたり、 <code>HostName IPアドレス</code> で IP アドレスを直接指定したり、よく使っています。</p>

<h2>IdentitiesOnly, IdentityFile</h2>

<p><code>IdentitiesOnly yes</code> と <code>IdentityFile</code> をセットで使って特定の鍵を使うように指定できます。
<code>IdentityFile</code> のみだと <code>ssh-agent</code> に登録されている全ての鍵を試してしまうので、普通は <code>IdentitiesOnly yes</code> とセットにして使うと思います。</p>

<p>GitHub や Heroku などのように鍵でユーザーが区別されるサービスで複数ユーザーを使い分ける時には必須だと思います。</p>

<h2>LocalCommand, PermitLocalCommand</h2>

<p>あまり使うことはなさそうですが、不用意に出力を伴うコマンドを設定していると、内部的に ssh を使うコマンドが謎の失敗をする原因になることがあります。</p>

<h2>LocalForward</h2>

<p>IRC bouncer に接続するのに</p>

<pre><code>LocalForward 6665 127.0.0.1:6665
LocalForward 6666 127.0.0.1:6666
LocalForward 6667 127.0.0.1:6667
</code></pre>

<p>という感じで使っていましたが、 TCP over TCP はあまりよくないということで、今は OpenVPN を使うようになったので、使っていません。</p>

<h2>NoHostAuthenticationForLocalhost</h2>

<p>仮想環境への接続で問題が起きたことがあるので <code>NoHostAuthenticationForLocalhost yes</code> にしています。</p>

<h2>Port</h2>

<p>ポート番号を変更している Host の設定によく使います。
明示的に <code>Port 22</code> を書いていることもあります。</p>

<h2>ProxyCommand, ProxyJump</h2>

<p>gateway を経由して target に接続するのに</p>

<pre><code>Host target
HostKeyAlias target.example.com
Hostname target.example.com
ProxyCommand ssh gateway.example.com nc -w 330 target.example.com 22
</code></pre>

<p>のように使っていました。</p>

<p>このような場合に OpenSSH 7.3 以降だと <code>ProxyJump</code> という設定が使えそうです。</p>

<p>今はそういう接続が必要な Host がないので使っていません。</p>

<h2>RequestTTY</h2>

<p><a href="http://dokku.viewdocs.io/dokku/" title="Dokku">Dokku</a> のように常に有効にしていた方が便利な Host に <code>RequestTTY yes</code> を指定しています。</p>

<p>たとえば dokku の vagrant 環境用の設定全体は以下のようにしています。</p>

<pre><code> Host dokku dokku.me
 User dokku
 HostName 10.0.0.2
 Port 22
 UserKnownHostsFile /dev/null
 StrictHostKeyChecking no
 PasswordAuthentication no
 #IdentityFile ~/.vagrant.d/insecure_private_key
 IdentityFile ~/.ssh/id_rsa
 IdentitiesOnly yes
 LogLevel FATAL
 RequestTTY yes
</code></pre>

<h2>ServerAliveInterval</h2>

<p>接続が切れた時にタイムアウトしてくれる設定です。
昔 Debian には <code>ProtocolKeepAlives</code> という設定がありましたが、今は <code>ServerAliveInterval</code> がどの OS でも使えます。
<code>ServerAliveInterval 300</code> や <code>ServerAliveInterval 30</code> を設定しています。</p>

<h2>StrictHostKeyChecking</h2>

<p>vagrant 環境など、ローカルの接続でホスト鍵も変わる可能性のある Host で <code>StrictHostKeyChecking no</code> にしています。</p>

<h2>Tunnel, TunnelDevice</h2>

<p>ssh のプロセスに与える権限が大きくなりすぎてしまうので使いにくいと思って使っていません。
代わりにトンネルには OpenVPN を使っています。</p>

<h2>UpdateHostKeys</h2>

<p>OpenSSH 6.8 以降のサーバーとクライアントだと複数のホスト鍵を受け取れるようになるようなので <code>UpdateHostKeys ask</code> にしておくと良さそうです。</p>

<p>試してみると、たとえば <code>ecdsa-sha2-nistp256</code> のホスト鍵だけ <code>known_hosts</code> に登録されているホストに接続する時に</p>

<pre><code>% ssh localhost
vagrant@localhost's password:
Learned new hostkey: RSA SHA256:+sjb9SQChXBlm/pZDyl8ORJQb4wP16eeKDqUvDli5wU
Learned new hostkey: ED25519 SHA256:rvlZW3lRcN86oPu19ym032zhuzVLz37E88A3VX2fVHE
Accept updated hostkeys? (yes/no): yes
</code></pre>

<p>のように RSA のホスト鍵と ED25519 のホスト鍵も <code>known_hosts</code> に登録するかどうかきいてきました。
(試した範囲では DSA の鍵は追加されませんでした。)</p>

<p>サーバー側が古いバージョンでも特に何も悪影響はなさそうなので、クライアントが OpenSSH 6.8 以降ならデフォルトで有効にしても良さそうです。
(クライアントが古いとエラーになるので、バージョンが古いうちから書いておくことはできない。)</p>

<p><code>ssh_config</code> の説明に書いてあるように <code>ControlPersist</code> を有効にしていると <code>UpdateHostKeys</code> は無効になるようです。</p>

<h2>User</h2>

<p><code>ssh user@host</code> で指定する代わりに <code>~/.ssh/config</code> で <code>User</code> を設定することが多いです。</p>

<h2>UserKnownHostsFile</h2>

<p>ローカルの仮想環境は <code>UserKnownHostsFile /dev/null</code> で事実上無効にしたり、<code>UserKnownHostsFile ~/.ssh/known_hosts.d/hoge.known_hosts</code> のように個別ファイルにして調べる行数を減らして速くしたりしています。</p>

<h2>VerifyHostKeyDNS</h2>

<p><a href="https://devcenter.heroku.com/articles/git-repository-ssh-fingerprints#verifying-with-dns" title="Verifying with DNS">Verifying with DNS</a> に書いてあるように <code>heroku.com</code> は SSHFP リソースレコードが設定されているようなので、 <code>VerifyHostKeyDNS yes</code> にしています。</p>

<h2>まとめ</h2>

<p><code>ServerAliveInterval</code> のように以前設定を見直したときにどの環境でも使えるようになっていたものもありましたが、 <code>ControlPersist</code> のように以前は使えない環境もあったけど、今はどこでも使える設定があったり、 <code>UpdateHostKeys</code> のようにまだ使えない環境もある設定もあったりするので、たまに気が向いたときに設定の見直しをするのはお勧めだと思いました。</p>
]]></content>
  </entry>
  
</feed>
