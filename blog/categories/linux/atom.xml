<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2016-04-17T21:18:19+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[jessie で dovecot-imapd と postfix の設定をして Thunderbird 用の autoconfig ファイルを用意した]]></title>
    <link href="http://blog.n-z.jp/blog/2016-04-17-jessie-dovecot.html"/>
    <updated>2016-04-17T21:14:05+09:00</updated>
    <id>http://blog.n-z.jp/blog/jessie-dovecot</id>
    <content type="html"><![CDATA[<p><a href="http://gihyo.jp/admin/serial/01/ubuntu-recipe/0387?page=4">Ubuntu Weekly Recipe 第387回　UbuntuでSSLを利用したサービスを構築する</a> を参考にして、 Debian jessie で dovecot-imapd で IMAP サーバーの設定をしました。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Debian GNU/Linux 8.4 (jessie)</li>
<li>postfix 2.11.3-1</li>
<li>dovecot-imapd 1:2.2.13-12~deb8u1</li>
<li>Thunderbird 38.6.0</li>
</ul>


<h2>インストール</h2>

<p><code>sudo aptitude install dovecot-imapd</code> でインストールしました。</p>

<h2>認証設定</h2>

<p>クライアントによっては plain 認証は使えず login 認証が必要なので <code>sudoedit /etc/dovecot/conf.d/10-auth.conf</code> で <code>auth_mechanisms = plain login</code> に設定を変更しました。</p>

<h2>ssl 設定</h2>

<p><code>sudoedit /etc/dovecot/conf.d/10-ssl.conf</code> で以下の設定を変更しました。</p>

<ul>
<li><code>ssl = no</code> を <code>ssl = required</code> に</li>
<li><code>ssl_cert</code>, <code>ssl_key</code> を設定</li>
<li><code>#ssl_protocols = !SSLv2</code> を <code>ssl_protocols = !SSLv2 !SSLv3</code> に</li>
</ul>


<p><a href="http://wiki.dovecot.org/SSL/DovecotConfiguration">http://wiki.dovecot.org/SSL/DovecotConfiguration</a> によると <code>ssl</code> の設定については <code>ssl=no</code>, <code>ssl=yes and disable_plaintext_auth=yes</code>, <code>ssl=yes and disable_plaintext_auth=yes</code>, <code>ssl=required</code> という設定の組み合わせがあるようです。</p>

<h2>Maildir 設定</h2>

<p>postfix の設定で <code>Maildir</code> への配送を使っているので、 <code>sudoedit /etc/dovecot/conf.d/10-mail.conf</code> で <code>mail_location = mbox:~/mail:INBOX=/var/mail/%u</code> を <code>mail_location = maildir:~/Maildir</code> に設定を変更しました。</p>

<h2>postfix との認証連携</h2>

<p>まず <code>sudo ls -al /var/spool/postfix/private</code> で <code>auth</code> がないのを確認しました。</p>

<p><code>sudoedit /etc/dovecot/conf.d/10-master.conf</code> で</p>

<pre><code class="plain /etc/dovecot/conf.d/10-master.conf">  #unix_listener /var/spool/postfix/private/auth {
  #  mode = 0666
  #}
</code></pre>

<p>を</p>

<pre><code class="plain /etc/dovecot/conf.d/10-master.conf">  unix_listener /var/spool/postfix/private/auth {
    mode = 0660
    user = postfix
    group = postfix
  }
</code></pre>

<p>に変更しました。</p>

<p>設定反映後に <code>sudo ls -al /var/spool/postfix/private</code> で <code>auth</code> が owner も group も postfix でパーミッションが <code>srw-rw----</code> になっているのを確認します。</p>

<h2>設定反映</h2>

<p><code>sudo service dovecot restart</code> で設定を反映しました。</p>

<p><code>journalctl -u dovecot.service</code> や <code>sudo ss -lntp | grep dovecot</code> で問題なく起動していることを確認しました。</p>

<h2>ufw でポート開放</h2>

<p><code>ufw allow 993/tcp</code> と <code>ufw limit 993/tcp</code> でポートを開放して連続接続数制限をしました。</p>

<h2>postfix 設定</h2>

<h3>SSL 設定</h3>

<p><code>smtpd_tls_cert_file</code> と <code>smtpd_tls_key_file</code> を設定します。
<code>smtpd_tls_cert_file</code> は中間証明書も結合したファイルを指定します。</p>

<p>その他の設定は以下のように設定しました。</p>

<pre><code class="plain /etc/postfix/main.cf">smtpd_tls_mandatory_protocols = !SSLv2, !SSLv3
smtpd_tls_protocols = !SSLv2, !SSLv3
smtp_tls_mandatory_protocols = !SSLv2, !SSLv3
smtp_tls_protocols = !SSLv2, !SSLv3
</code></pre>

<p><code>smtpd_tls_security_level = may</code> は設定すると外部からのメール送信で問題が起きたことがあったので、メールの送信テストをしつつ、様子を見ながら設定するかどうか決めます。</p>

<h3>SASL 設定</h3>

<p><a href="http://gihyo.jp/admin/serial/01/ubuntu-recipe/0387?page=4">Ubuntu Weekly Recipe</a> では <code>smtpd_sasl_auth_enable</code> は <code>/etc/postfix/main.cf</code> でも <code>yes</code> にしていますが、 <code>/etc/postfix/master.cf</code> で <code>smtps</code> と <code>submission</code> で個別に <code>yes</code> に設定されているので、 <code>/etc/postfix/main.cf</code> では <code>no</code> のままにしておきます。</p>

<p>そうしておかないと 25 番ポートでも SMTP-Auth が有効になって、しかも <code>smtpd_tls_security_level = may</code> だとパスワードが平文で流れても良いということになるので、危険なことが起きる可能性があります。
最近は OBP25B という対策が普及しているので、一般のクライアントが間違って平文で送信してしまう可能性は低いと思いますが、余計な危険は避けておくのが良いと思います。</p>

<p>CRAM-MD5 が有効なら <code>smtpd_sasl_security_options = noanonymous,noplaintext</code> にして <code>master.cf</code> で <code>noanonymous</code> だけにしても良いかと思ったのですが、 plain 認証と login 認証しかない状態で <code>noplaintext</code> もつけてしまうと 25 番ポートで listen しているのに接続しても最初の <code>220 mail.example.org ESMTP Postfix (Debian/GNU)</code> が出てこなくてログに <code>fatal: no SASL authentication mechanisms</code> と記録されるという状態になってしまいました。
<code>/etc/passwd</code> (<code>/etc/shadow</code>) による認証だとパスワードをハッシュ化された状態でしか保存していないため、 CRAM-MD5 は使えないので、これ以上の検証はできませんでした。</p>

<p>以上を踏まえて以下のように設定しました。</p>

<pre><code class="plain /etc/postfix/main.cf">smtpd_sasl_auth_enable = no
smtpd_sasl_local_domain = $myhostname
smtpd_sasl_security_options = noanonymous
smtpd_sasl_type = dovecot
smtpd_sasl_path = private/auth
broken_sasl_auth_clients = yes
</code></pre>

<p><code>smtpd_sasl_local_domain</code> や <code>broken_sasl_auth_clients</code> は不要かもしれません。</p>

<h2>Thunderbird 用自動設定ファイル設置</h2>

<p><a href="https://developer.mozilla.org/ja/docs/Mozilla/Thunderbird/Autoconfiguration">Thunderbird のアカウント情報自動設定機能</a>のために <code>mail/config-v1.1.xml</code> を設置します。</p>

<p><code>@example.com</code> のメールアドレスに対して <code>http://autoconfig.example.com/mail/config-v1.1.xml</code> か <code>http://example.com/.well-known/autoconfig/mail/config-v1.1.xml</code> を用意します。</p>

<p>内容は以下のような感じになります。
<code>mozilla.org</code> の例との主な違いは <code>authentication</code> を <code>password-encrypted</code> ではなく <code>password-cleartext</code> にしているところと、 <code>username</code> を <code>%EMAILADDRESS%</code> ではなく <code>%EMAILLOCALPART%</code> にしているところです。</p>

<pre><code class="xml mail/config-v1.1.xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;clientConfig version="1.1"&gt;
  &lt;emailProvider id="example.com"&gt;
    &lt;domain&gt;example.com&lt;/domain&gt;
    &lt;displayName&gt;Example.com Mail&lt;/displayName&gt;
    &lt;displayShortName&gt;example.com&lt;/displayShortName&gt;
    &lt;incomingServer type="imap"&gt;
      &lt;hostname&gt;mail.example.com&lt;/hostname&gt;
      &lt;port&gt;993&lt;/port&gt;
      &lt;socketType&gt;SSL&lt;/socketType&gt;
      &lt;authentication&gt;password-cleartext&lt;/authentication&gt;
      &lt;username&gt;%EMAILLOCALPART%&lt;/username&gt;
    &lt;/incomingServer&gt;
    &lt;outgoingServer type="smtp"&gt;
      &lt;hostname&gt;mail.example.com&lt;/hostname&gt;
      &lt;port&gt;587&lt;/port&gt;
      &lt;socketType&gt;STARTTLS&lt;/socketType&gt;
      &lt;authentication&gt;password-cleartext&lt;/authentication&gt;
      &lt;username&gt;%EMAILLOCALPART%&lt;/username&gt;
    &lt;/outgoingServer&gt;
  &lt;/emailProvider&gt;
&lt;/clientConfig&gt;
</code></pre>

<h2>まとめ</h2>

<p><a href="http://gihyo.jp/admin/serial/01/ubuntu-recipe/0387?page=4">Ubuntu Weekly Recipe</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jessie に backports から letsencrypt を入れてみた]]></title>
    <link href="http://blog.n-z.jp/blog/2016-04-08-jessie-letsencrypt.html"/>
    <updated>2016-04-08T14:30:02+09:00</updated>
    <id>http://blog.n-z.jp/blog/jessie-letsencrypt</id>
    <content type="html"><![CDATA[<p>現在リリースされている Ubuntu と違って Debian jessie には backports に letsencrypt パッケージがあるので、ちょっと古いですがパッケージ版の letsencrypt を使ってみることにしました。</p>

<p>Ubuntu も今月リリースされる 16.04 (xenial) には universe ですが letsencrypt パッケージが含まれるので、それが使えると思います。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Debian GNU/Linux 8.4 (jessie) (amd64)</li>
<li>letsencrypt 0.4.1-1~bpo8+1</li>
<li>apache2 2.4.10-10+deb8u4</li>
</ul>


<h2>インストール</h2>

<p><code>/etc/apt/sources.list</code> で <code>deb http://ftp.jp.debian.org/debian jessie-backports main contrib non-free</code> のように backports を有効にしておきます。</p>

<p>依存パッケージも backports のものが必要なので <code>-t jessie-backports</code> 付きでインストールする必要がありました。</p>

<p><code>webroot</code> を使う予定だったので、 <code>python-letsencrypt-apache</code> はインストールしませんでした。</p>

<p>stable にあるパッケージのうち、いくつかのパッケージも backports のものに上がってしまうので、そのリスクが許容できない場合は <code>letsencrypt-auto</code> など、他のインストール方法を検討した方が良さそうです。</p>

<pre><code>%  sudo apt install letsencrypt
パッケージリストを読み込んでいます... 完了
依存関係ツリーを作成しています
状態情報を読み取っています... 完了
インストールすることができないパッケージがありました。おそらく、あり得
ない状況を要求したか、(不安定版ディストリビューションを使用しているの
であれば) 必要なパッケージがまだ作成されていなかったり Incoming から移
動されていないことが考えられます。
以下の情報がこの問題を解決するために役立つかもしれません:

以下のパッケージには満たせない依存関係があります:
 letsencrypt : 依存: python-letsencrypt (= 0.4.1-1~bpo8+1) しかし、インストールされようとしていませ ん
E: 問題を解決することができません。壊れた変更禁止パッケージがあります。
zsh: exit 100   sudo apt install letsencrypt
%  sudo apt install -t jessie-backports letsencrypt
パッケージリストを読み込んでいます... 完了
依存関係ツリーを作成しています
状態情報を読み取っています... 完了
以下のパッケージが自動でインストールされましたが、もう必要とされていません:
  python-cffi python-ply python-pycparser
これを削除するには 'apt-get autoremove' を利用してください。
以下の追加パッケージがインストールされます:
  dialog python-acme python-cffi python-cffi-backend python-configargparse python-configobj
  python-cryptography python-dialog python-enum34 python-funcsigs python-idna python-ipaddress
  python-letsencrypt python-mock python-ndg-httpsclient python-openssl python-parsedatetime
  python-pbr python-psutil python-pyasn1 python-pyicu python-requests python-rfc3339 python-six
  python-urllib3 python-zope.component python-zope.event python-zope.interface
提案パッケージ:
  python-letsencrypt-apache python-letsencrypt-doc python-configobj-doc python-cryptography-doc
  python-cryptography-vectors python-enum34-doc python-funcsigs-doc python-mock-doc
  python-openssl-doc python-openssl-dbg doc-base python-ntlm
以下のパッケージが新たにインストールされます:
  dialog letsencrypt python-acme python-cffi-backend python-configargparse python-configobj
  python-dialog python-enum34 python-funcsigs python-idna python-ipaddress python-letsencrypt
  python-mock python-ndg-httpsclient python-parsedatetime python-pbr python-psutil python-pyasn1
  python-pyicu python-requests python-rfc3339 python-urllib3 python-zope.component
  python-zope.event python-zope.interface
以下のパッケージはアップグレードされます:
  python-cffi python-cryptography python-openssl python-six
アップグレード: 4 個、新規インストール: 25 個、削除: 0 個、保留: 24 個。
1,906 kB のアーカイブを取得する必要があります。
この操作後に追加で 8,772 kB のディスク容量が消費されます。
続行しますか? [Y/n]
</code></pre>

<h2>letsencrypt コマンド実行</h2>

<p>一般ユーザー権限で実行するとエラーになり、カレントディレクトリに <code>letsencrypt.log</code> が作成されていました。
<code>--help</code> 付きでの実行は特にエラーもなく、 <code>letsencrypt.log</code> も作成されることなくヘルプが表示されました。</p>

<pre><code>%  letsencrypt
An unexpected error occurred:
OSError: [Errno 13] Permission denied: '/etc/letsencrypt'
Please see the logfile 'letsencrypt.log' for more details.
%  rm letsencrypt.log
%  letsencrypt --help

  letsencrypt [SUBCOMMAND] [options] [-d domain] [-d domain] ...

The Let's Encrypt agent can obtain and install HTTPS/TLS/SSL certificates.  By
default, it will attempt to use a webserver both for obtaining and installing
the cert. Major SUBCOMMANDS are:

  (default) run        Obtain &amp; install a cert in your current webserver
  certonly             Obtain cert, but do not install it (aka "auth")
  install              Install a previously obtained cert in a server
  renew                Renew previously obtained certs that are near expiry
  revoke               Revoke a previously obtained certificate
  rollback             Rollback server configuration changes made during install
  config_changes       Show changes made to server config during installation
  plugins              Display information about installed plugins

Choice of server plugins for obtaining and installing cert:

  (the apache plugin is not installed)
  --standalone      Run a standalone webserver for authentication
  (nginx support is experimental, buggy, and not installed by default)
  --webroot         Place files in a server's webroot folder for authentication

OR use different plugins to obtain (authenticate) the cert and then install it:

  --authenticator standalone --installer apache

More detailed help:

  -h, --help [topic]    print this message, or detailed help on a topic;
                        the available topics are:

   all, automation, paths, security, testing, or any of the subcommands or
   plugins (certonly, install, nginx, apache, standalone, webroot, etc)
</code></pre>

<h2>本番実行</h2>

<p><code>letsencrypt certonly</code> で証明書発行します。</p>

<pre><code>%  sudo letsencrypt certonly --webroot -w /srv/www/www.example.org/htdocs -d www.example.org
</code></pre>

<p>まず、アカウントの作成があるので、アカウントの作成はメールアドレス入力しました。
アカウントのリカバリや緊急時の連絡などに使われるだけのようで、今の所ここで入力したメールアドレスに letsencrypt からメールが来たことはありません。</p>

<pre><code>         ┌──────────────────────────────────────────────────────────────────────┐
         │ Enter email address (used for urgent notices and lost key recovery)  │
         │ ┌──────────────────────────────────────────────────────────────────┐ │
         │ │                                                                  │ │
         │ └──────────────────────────────────────────────────────────────────┘ │
         ├──────────────────────────────────────────────────────────────────────┤
         │                     &lt; 了解 &gt;           &lt; 取消 &gt;                      │
         └──────────────────────────────────────────────────────────────────────┘
</code></pre>

<p>Terms of Service は前回みた時から変わっていないので、今度も Agree しました。</p>

<pre><code>         ┌──────────────────────────────────────────────────────────────────────┐
         │ Please read the Terms of Service at                                  │
         │ https://letsencrypt.org/documents/LE-SA-v1.0.1-July-27-2015.pdf. You │
         │ must agree in order to register with the ACME server at              │
         │ https://acme-v01.api.letsencrypt.org/directory                       │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         │                                                                      │
         ├──────────────────────────────────────────────────────────────────────┤
         │                     &lt;Agree &gt;           &lt;Cancel&gt;                      │
         └──────────────────────────────────────────────────────────────────────┘
</code></pre>

<p>以下のような作成完了のメッセージが出ました。</p>

<pre><code>IMPORTANT NOTES:
 - If you lose your account credentials, you can recover through
   e-mails sent to z@n-z.jp.
 - Congratulations! Your certificate and chain have been saved at
   /etc/letsencrypt/live/www.example.org/fullchain.pem. Your cert will
   expire on 2016-07-07. To obtain a new version of the certificate in
   the future, simply run Let's Encrypt again.
 - Your account credentials have been saved in your Let's Encrypt
   configuration directory at /etc/letsencrypt. You should make a
   secure backup of this folder now. This configuration directory will
   also contain certificates and private keys obtained by Let's
   Encrypt so making regular backups of this folder is ideal.
 - If you like Let's Encrypt, please consider supporting our work by:

   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le
</code></pre>

<p>問題があれば <code>/var/log/letsencrypt/letsencrypt.log</code> でログを確認します。</p>

<h2>apache2 の設定変更</h2>

<p>apache2 の設定を変更して、 <code>sudo service apache2 reload</code> で反映します。
ブラウザーで Let&rsquo;s Encrypt Authority X3 の証明書になっていることが確認できたら設定完了です。</p>

<pre><code>SSLCertificateKeyFile /etc/letsencrypt/live/www.example.org/privkey.pem
SSLCertificateFile /etc/letsencrypt/live/www.example.org/fullchain.pem
</code></pre>

<h2>自動更新設定</h2>

<p>パッケージの <code>letsencrypt</code> でインストールされたものではないということを明示するために <code>local</code> をつけて <code>/etc/cron.daily/local-letsencrypt</code> に自動更新の設定をしました。</p>

<p>試しに実行してみてちゃんと動いていれば設定完了です。</p>

<pre><code>% sudoedit /etc/cron.daily/local-letsencrypt
% sudo chmod +x /etc/cron.daily/local-letsencrypt
% sudo /etc/cron.daily/local-letsencrypt
% sudo cat /var/log/letsencrypt/renew.log
Processing /etc/letsencrypt/renewal/www.example.org.conf

The following certs are not due for renewal yet:
  /etc/letsencrypt/live/www.example.org/fullchain.pem (skipped)
No renewals were attempted.
</code></pre>

<p><a href="http://blog.n-z.jp/blog/2016-04-07-letsencrypt.html">前回の記事</a> のように <a href="http://packages.debian.org/debianutils">debianutils</a> の <code>savelog</code> でログをローテートして、証明書の有効期限の 90 日分残すようにしています。</p>

<pre><code class="bash /etc/cron.daily/local-letsencrypt">#!/bin/sh
LOGFILE=/var/log/letsencrypt/renew.log
if [ -f "$LOGFILE" ]; then
    savelog -c 90 -q "$LOGFILE"
fi
if ! letsencrypt renew &gt; "$LOGFILE" 2&gt;&amp;1 ; then
    echo Automated renewal failed:
    cat "$LOGFILE"
    exit 1
fi
apachectl graceful
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[letsencrypt-auto の自動アップグレードを止めて手動でアップグレード]]></title>
    <link href="http://blog.n-z.jp/blog/2016-04-07-letsencrypt.html"/>
    <updated>2016-04-07T23:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/letsencrypt</id>
    <content type="html"><![CDATA[<p><code>/etc/cron.daily/letsencrypt</code> は <code>root</code> 権限で実行されるため、そこで自動アップグレードがかかるとファイルのオーナーが <code>root</code> になってしまうかもしれないと思ったので、自動更新を止めて手動でアップグレードするようにしました。</p>

<!--more-->


<h2>自動アップグレードを止めた <code>/etc/cron.daily/local-letsencrypt</code></h2>

<p><a href="http://blog.n-z.jp/blog/2016-03-06-letsencrypt.html">前回の記事</a> からの差分としては <a href="http://packages.debian.org/debianutils">debianutils</a> の <code>savelog</code> でログをローテートして、証明書の有効期限の 90 日分残すようにしたのと、 <code>--no-self-upgrade</code> をつけて自動アップグレードを止めたことです。
それから、パッケージで入れたものではないということを明示するために <code>local</code> という文字列を入れたファイル名に変更しました。</p>

<pre><code class="bash /etc/cron.daily/local-letsencrypt">#!/bin/sh
LOGFILE=/var/log/letsencrypt/renew.log
if [ -f "$LOGFILE" ]; then
    /usr/bin/savelog -c 90 -q "$LOGFILE"
fi
if ! /home/hoge/letsencrypt/letsencrypt-auto renew --no-self-upgrade &gt; "$LOGFILE" 2&gt;&amp;1 ; then
    echo Automated renewal failed:
    cat "$LOGFILE"
    exit 1
fi
apachectl graceful
service postfix reload &gt;/dev/null
service dovecot reload
</code></pre>

<h2>手動アップグレードしたログ</h2>

<p>手動実行したところ、ちょうど 0.4.2 から 0.5.0 へのアップグレードが実行されました。</p>

<pre><code>% ~/letsencrypt/letsencrypt-auto --help
Checking for new version...
Upgrading letsencrypt-auto 0.4.2 to 0.5.0...
Replacing letsencrypt-auto...
   sudo cp -p /home/hoge/letsencrypt/letsencrypt-auto /tmp/user/1000/tmp.MclJH3TO68/letsencrypt-auto.permission-clone
   sudo cp /tmp/user/1000/tmp.MclJH3TO68/letsencrypt-auto /tmp/user/1000/tmp.MclJH3TO68/letsencrypt-auto.permission-clone
   sudo mv -f /tmp/user/1000/tmp.MclJH3TO68/letsencrypt-auto.permission-clone /home/hoge/letsencrypt/letsencrypt-auto
Creating virtual environment...
Installing Python packages...
Installation succeeded.
Requesting root privileges to run letsencrypt...
   sudo /home/hoge/.local/share/letsencrypt/bin/letsencrypt --help

  letsencrypt-auto [SUBCOMMAND] [options] [-d domain] [-d domain] ...

The Let's Encrypt agent can obtain and install HTTPS/TLS/SSL certificates.  By
default, it will attempt to use a webserver both for obtaining and installing
the cert. Major SUBCOMMANDS are:

  (default) run        Obtain &amp; install a cert in your current webserver
  certonly             Obtain cert, but do not install it (aka "auth")
  install              Install a previously obtained cert in a server
  renew                Renew previously obtained certs that are near expiry
  revoke               Revoke a previously obtained certificate
  rollback             Rollback server configuration changes made during install
  config_changes       Show changes made to server config during installation
  plugins              Display information about installed plugins

Choice of server plugins for obtaining and installing cert:

  --apache          Use the Apache plugin for authentication &amp; installation
  --standalone      Run a standalone webserver for authentication
  (nginx support is experimental, buggy, and not installed by default)
  --webroot         Place files in a server's webroot folder for authentication

OR use different plugins to obtain (authenticate) the cert and then install it:

  --authenticator standalone --installer apache

More detailed help:

  -h, --help [topic]    print this message, or detailed help on a topic;
                        the available topics are:

   all, automation, paths, security, testing, or any of the subcommands or
   plugins (certonly, install, nginx, apache, standalone, webroot, etc)
</code></pre>

<h2>アップグレードがないときのログ</h2>

<pre><code>% ~/letsencrypt/letsencrypt-auto --help
Checking for new version...
Requesting root privileges to run letsencrypt...
   sudo /home/hoge/.local/share/letsencrypt/bin/letsencrypt --help

  letsencrypt-auto [SUBCOMMAND] [options] [-d domain] [-d domain] ...

The Let's Encrypt agent can obtain and install HTTPS/TLS/SSL certificates.  By
default, it will attempt to use a webserver both for obtaining and installing
the cert. Major SUBCOMMANDS are:

  (default) run        Obtain &amp; install a cert in your current webserver
  certonly             Obtain cert, but do not install it (aka "auth")
  install              Install a previously obtained cert in a server
  renew                Renew previously obtained certs that are near expiry
  revoke               Revoke a previously obtained certificate
  rollback             Rollback server configuration changes made during install
  config_changes       Show changes made to server config during installation
  plugins              Display information about installed plugins

Choice of server plugins for obtaining and installing cert:

  --apache          Use the Apache plugin for authentication &amp; installation
  --standalone      Run a standalone webserver for authentication
  (nginx support is experimental, buggy, and not installed by default)
  --webroot         Place files in a server's webroot folder for authentication

OR use different plugins to obtain (authenticate) the cert and then install it:

  --authenticator standalone --installer apache

More detailed help:

  -h, --help [topic]    print this message, or detailed help on a topic;
                        the available topics are:

   all, automation, paths, security, testing, or any of the subcommands or
   plugins (certonly, install, nginx, apache, standalone, webroot, etc)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dokku-letsencrypt を使ってみた]]></title>
    <link href="http://blog.n-z.jp/blog/2016-04-06-dokku-letsencrypt.html"/>
    <updated>2016-04-06T23:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/dokku-letsencrypt</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/dokku/dokku-letsencrypt">dokku-letsencrypt</a> を試してみたのでそのメモです。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>Ubuntu 14.04.4 LTS</li>
<li>Docker 1.10.3</li>
<li>Dokku 0.5.3</li>
<li>dokku-letsencrypt v0.7.0-7-gb4950b8</li>
</ul>


<h2>インストール</h2>

<p>README.md に書いてある手順の通りインストールして、 <code>git describe --tags</code> でバージョンを確認しておきました。</p>

<pre><code>$ sudo dokku plugin:install https://github.com/dokku/dokku-letsencrypt.git
-----&gt; Cloning plugin repo https://github.com/dokku/dokku-letsencrypt.git to /var/lib/dokku/plugins/available/letsencrypt
Cloning into 'letsencrypt'...
remote: Counting objects: 233, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 233 (delta 0), reused 0 (delta 0), pack-reused 229
Receiving objects: 100% (233/233), 48.62 KiB | 0 bytes/s, done.
Resolving deltas: 100% (136/136), done.
Checking connectivity... done.
-----&gt; Plugin letsencrypt enabled
-----&gt; Migrating zero downtime env variables. The following variables have been deprecated
=====&gt; DOKKU_SKIP_ALL_CHECKS DOKKU_SKIP_DEFAULT_CHECKS
=====&gt; Please use dokku checks:[disable|enable] &lt;app&gt; to control zero downtime functionality
=====&gt; Migration complete
=====&gt;
=====&gt; Migration complete
=====&gt;
=====&gt; Migration complete
=====&gt;
=====&gt; Migration complete
=====&gt;
=====&gt; Migration complete
=====&gt;
Adding user dokku to group adm
$ cd /var/lib/dokku/plugins/available/letsencrypt/
$ git describe --tags
v0.7.0-7-gb4950b8
$ cd
</code></pre>

<h2>アップグレード</h2>

<p>README.md にアップグレードの手順も書いてあったので、試しておきました。</p>

<pre><code>$ sudo dokku plugin:update letsencrypt
Plugin (letsencrypt) updated
</code></pre>

<h2>対象アプリの確認</h2>

<p><code>dokku apps</code> でアプリケーション一覧を表示して、対象とするアプリケーションの名前を確認しておきました。</p>

<ul>
<li><code>dokku help</code></li>
<li><code>dokku apps:help</code></li>
<li><code>dokku apps</code></li>
</ul>


<h2>メールアドレス設定</h2>

<p>Let&rsquo;s Encrypt に登録するメールアドレスを設定しておきます。
<a href="https://letsencrypt.jp/usage/" title="Let's Encrypt の使い方">Let&rsquo;s Encrypt の使い方</a>の説明によると「ここで入力したメールアドレスは、緊急の通知や鍵を紛失したときの復旧に使われます。」</p>

<p>dokku-letsencrypt プラグインでは「利用規約への同意」に相当する手順がありませんが、念のため利用規約 (現在のバージョンは <a href="https://letsencrypt.org/documents/LE-SA-v1.0.1-July-27-2015.pdf">https://letsencrypt.org/documents/LE-SA-v1.0.1-July-27-2015.pdf</a> ) に目を通しておくと良いと思います。</p>

<p>ちなみに今のところ letsencrypt に登録したメールアドレスに letsencrypt からメールが来たことはありません。</p>

<pre><code>$ dokku config:set --no-restart staging.example.co.jp DOKKU_LETSENCRYPT_EMAIL=root@example.co.jp
-----&gt; Setting config vars
       DOKKU_LETSENCRYPT_EMAIL: root@example.co.jp
</code></pre>

<h2>メールアドレスをグローバルに設定するかアプリケーションごとに設定するか</h2>

<p>グローバルに設定することも可能だと思いますが、メールアドレスを設定していなければ <code>dokku letsencrypt APP</code> の最初のチェックで止まって、既存の TLS 設定を上書きされる心配がないので、すべてのアプリケーションで letsencrypt を使うのでなければ、アプリケーションごとに設定することをおすすめします。</p>

<p>メールアドレスを設定していなければ、以下のように失敗して止まってくれます。</p>

<pre><code>$ dokku letsencrypt node-js-app
=====&gt; Let's Encrypt node-js-app...
 !     ERROR: Cannot request a certificate without an e-mail address!
 !       please provide your e-mail address using
 !       dokku config:set --no-restart node-js-app DOKKU_LETSENCRYPT_EMAIL=&lt;e-mail&gt;
</code></pre>

<h2>証明書発行と設定</h2>

<p><code>dokku letsencrypt APP</code> で証明書発行から設定まで自動で実行されます。</p>

<p>すでに <code>tls/server.{crt,key}</code> が存在していても強制的にシンボリックリンクで上書きされるので、他で発行された証明書を使っている場合は注意が必要です。</p>

<pre><code>$ dokku letsencrypt staging.example.co.jp
=====&gt; Let's Encrypt staging.example.co.jp...
-----&gt; Updating letsencrypt docker image...
latest: Pulling from m3adow/letsencrypt-simp_le
420890c9e918: Pull complete
acbaf1e6012f: Pull complete
5f71a1a2d3dc: Pull complete
Digest: sha256:be1d7aca214d5277af18d7bf75a2bc78afa5a1eabf98aaa8a606c4ca2a7fdeb5
Status: Downloaded newer image for m3adow/letsencrypt-simp_le:latest
       done
-----&gt; Enabling ACME proxy for staging.example.co.jp...
-----&gt; Getting letsencrypt certificate for staging.example.co.jp...
        - Domain 'staging.example.co.jp'
darkhttpd/1.11, copyright (c) 2003-2015 Emil Mikulic.
listening on: http://0.0.0.0:80/
2016-04-04 03:26:42,946:INFO:__main__:1202: Generating new account key
2016-04-04 03:26:43,831:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:44,110:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:44,302:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:44,841:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): letsencrypt.org
2016-04-04 03:26:45,410:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:45,664:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:45,940:INFO:requests.packages.urllib3.connectionpool:207: Starting new HTTP connection (1): staging.example.co.jp
2016-04-04 03:26:45,946:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): staging.example.co.jp
2016-04-04 03:26:45,995:INFO:__main__:1294: staging.example.co.jp was successfully self-verified
2016-04-04 03:26:46,022:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:46,272:INFO:__main__:1302: Generating new certificate private key
2016-04-04 03:26:47,528:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:47,723:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:47,987:INFO:requests.packages.urllib3.connectionpool:758: Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
2016-04-04 03:26:48,215:INFO:__main__:385: Saving account_key.json
2016-04-04 03:26:48,216:INFO:__main__:385: Saving fullchain.pem
2016-04-04 03:26:48,216:INFO:__main__:385: Saving chain.pem
2016-04-04 03:26:48,216:INFO:__main__:385: Saving cert.pem
2016-04-04 03:26:48,216:INFO:__main__:385: Saving key.pem
-----&gt; Certificate retrieved successfully.
-----&gt; Symlinking let's encrypt certificates
-----&gt; Configuring staging.example.co.jp...(using built-in template)
-----&gt; Creating https nginx.conf
-----&gt; Running nginx-pre-reload
       Reloading nginx
-----&gt; Disabling ACME proxy for staging.example.co.jp...
       done
</code></pre>

<h2>有効になっているアプリケーション一覧確認</h2>

<p><code>dokku letsencrypt:ls</code> で有効になっているアプリケーションとその有効期限を確認します。</p>

<pre><code>$ dokku letsencrypt:ls
-----&gt; App name           Certificate Expiry        Time before expiry        Time before renewal
staging.example.co.jp 2016-07-03 11:27:00       89d, 22h, 56m, 55s        59d, 22h, 56m, 55s
</code></pre>

<h2>自動更新</h2>

<p>有効期限が 30 日 (<code>DOKKU_LETSENCRYPT_GRACEPERIOD</code> で変更可能) を切ると自動更新してくれる <code>dokku letsencrypt:auto-renew</code> も試しておきます。</p>

<pre><code>$ dokku letsencrypt:auto-renew
=====&gt; Auto-renewing all apps...
       staging.example.co.jp still has 59d, 22h, 48m, 36s days left before renewal
=====&gt; Finished auto-renewal
</code></pre>

<p>問題なさそうなので、<code>dokku</code> ユーザーの <code>crontab</code> で設定して自動実行するようにしておきます。
リモートからのトリガーで実行されるように ssh で入れるユーザーの <code>crontab</code> で <code>ssh dokku letsencrypt:auto-renew</code> を設定しておくのでも良いと思います。</p>

<h2>セキュリティ上の問題点</h2>

<p><code>dokku-letsencrypt</code> が使用している <a href="https://github.com/kuba/simp_le" title="Simple Let's Encrypt Client">Simple Let&rsquo;s Encrypt Client</a> の issue の <a href="https://github.com/kuba/simp_le/issues/29" title="private key permissions">private key permissions</a> で指摘されているように、 <code>ls -al /home/dokku/staging.example.co.jp/letsencrypt/certs/current/</code> で確認してみると、他のユーザーからは読めなくするべき <code>account_key.json</code> や <code>key.pem</code> も誰でも読めるパーミッションになってしまっているので、 <code>sudo chmod 700 /home/dokku/staging.example.co.jp/letsencrypt</code> などでパーミッションを落としておく方が良さそうです。</p>

<p>ファイル自体のパーミッションを落としても良さそうですが、更新された後のことも考えると <code>/home/dokku/APP/letsencrypt</code> ディレクトリ自体のパーミッションを落としておくのが良さそうです。</p>

<h2>Rate Limit</h2>

<p><a href="https://letsencrypt.jp/faq/#RateLimiting" title="Let's Encrypt の証明書に取得数制限はありますか？">Let&rsquo;s Encrypt の証明書に取得数制限はありますか？</a> のリンク先に書いてあるように、この記事執筆時点では「アカウント登録/IP アドレスごと」(3 時間で 10 個) と「証明書発行/ドメインごと」(1 週間で 5 個) の制限があるので、注意が必要です。</p>

<p>特に dokku-letsencrypt では<a href="https://github.com/letsencrypt/letsencrypt">公式のクライアント</a>が <code>/etc/letsencrypt/accounts</code> でアカウントを共有するのと違って、 <code>account_key.json</code> をアプリケーションごとに作成しているので、注意が必要そうです。</p>

<p>ただし、現状の制限だと証明書発行数の制限の方が引っかかりやすいので、アカウント登録の制限は問題にならないようにも思います。</p>

<p>証明書発行数の制限については <code>dokku domains:add</code> や <code>dokku domains:remove</code> で適切にドメインの追加や削除をしてから <code>dokku letsencrypt</code> を実行するように README.md の <a href="https://github.com/dokku/dokku-letsencrypt/tree/b4950b8254f683e4af775bad44e390763a699de1#dealing-with-rate-limit" title="Dealing with rate limit">Dealing with rate limit</a> に書いてあります。</p>

<h2>証明書の情報表示</h2>

<p><code>dokku certs:info</code> で letsencrypt のものに限らず、証明書の情報を表示できます。</p>

<pre><code>adminuser@tk2-213-16013:~$ dokku certs:info staging.example.co.jp
-----&gt; Fetching SSL Endpoint info for staging.example.co.jp...
-----&gt; Certificate details:
=====&gt; Common Name(s):
=====&gt;    staging.example.co.jp
=====&gt;    staging.example.co.jp
=====&gt; Expires At: Jul  3 02:27:00 2016 GMT
=====&gt; Issuer: C=US, O=Lets Encrypt, CN=Lets Encrypt Authority X3
=====&gt; Starts At: Apr  4 02:27:00 2016 GMT
=====&gt; Subject: CN=staging.example.co.jp
=====&gt; SSL certificate is self signed.
adminuser@tk2-213-16013:~$ dokku certs:info production.example.co.jp
-----&gt; Fetching SSL Endpoint info for production.example.co.jp...
-----&gt; Certificate details:
=====&gt; Common Name(s):
=====&gt;    production.example.co.jp
=====&gt;    production.example.co.jp
=====&gt;    example.co.jp
=====&gt; Expires At: Aug  4 00:05:31 2016 GMT
=====&gt; Issuer: C=IL, O=StartCom Ltd., OU=Secure Digital Certificate Signing, CN=StartCom Class 1 Primary Intermediate Server CA
=====&gt; Starts At: Aug  3 18:20:22 2015 GMT
=====&gt; Subject: C=JP; CN=production.example.co.jp; emailAddress=hostmaster@example.co.jp
=====&gt; SSL certificate is self signed.
adminuser@tk2-213-16013:~$ dokku certs:info another.example.co.jp
-----&gt; Fetching SSL Endpoint info for another.example.co.jp...
-----&gt; Certificate details:
=====&gt; Common Name(s):
=====&gt;    another.example.co.jp
=====&gt;    another.example.co.jp
=====&gt;    example.co.jp
=====&gt; Expires At: Apr 23 04:56:14 2016 GMT
=====&gt; Issuer: C=IL, O=StartCom Ltd., OU=Secure Digital Certificate Signing, CN=StartCom Class 1 Primary Intermediate Server CA
=====&gt; Starts At: Apr 22 23:55:13 2015 GMT
=====&gt; Subject: C=JP; CN=another.example.co.jp; emailAddress=hostmaster@example.co.jp
=====&gt; SSL certificate is self signed.
adminuser@tk2-213-16013:~$
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ccollect によるバックアップの設定]]></title>
    <link href="http://blog.n-z.jp/blog/2016-04-04-ccollect.html"/>
    <updated>2016-04-04T22:51:06+09:00</updated>
    <id>http://blog.n-z.jp/blog/ccollect</id>
    <content type="html"><![CDATA[<p><code>ccollect</code> という <code>rsync</code> の <code>--link-dest</code> オプションによるハードリンクをうまく使って差分バックアップをしてくれるツールでバックアップ設定をしました。</p>

<!--more-->


<h2>インストール</h2>

<p>deb パッケージは存在しないので、まず <code>git clone https://github.com/ungleich/ccollect ~/src/github.com/ungleich/ccollect</code> などで最新 (現時点で 1.0) の ccollect を github のミラーから取得します。</p>

<p><a href="http://www.nico.schottelius.org/software/ccollect/">本家</a> の download ページにある tarball は 0.8 まででちょっと古いです。</p>

<h2>共通設定</h2>

<p>設定は <code>CCOLLECT_CONF</code> (デフォルトは <code>/etc/ccollect</code>) の中に置いていきます。</p>

<p>共通設定は <code>defaults</code> の中に、バックアップごとの設定は <code>sources</code> の中に置いていきます。</p>

<h3>バックアップ保存回数の設定</h3>

<p><code>defaults/intervals</code> の中に適当なファイル名でバックアップの保存回数を設定していきます。</p>

<p><code>daily</code> などの名前をつけることが多いようですが、 <code>ccollect</code> 自体に毎日自動実行する機能があるわけではないので、自前で <code>cron</code> などを使って実行する必要が有ります。</p>

<ul>
<li><code>sudo mkdir -p /etc/ccollect/defaults/intervals</code></li>
<li><code>echo 10 | sudo tee /etc/ccollect/defaults/intervals/daily</code></li>
<li><code>echo 24 | sudo tee /etc/ccollect/defaults/intervals/monthly</code></li>
<li><code>echo 10 | sudo tee /etc/ccollect/defaults/intervals/weekly</code></li>
</ul>


<p>ここでは日時バックアップと週次バックアップは 10 回分、月次バックアップは 2 年分保存するようにしてみました。</p>

<h3>不完全なバックアップの削除</h3>

<p><code>ccollect</code> では構造化された設定ファイルをパースするのではなく、簡単な内容のファイルの中身が設定値になっていたり、ファイルの存在がフラグとなっていたりするようになっています。</p>

<p>ここでは <code>rsync</code> の途中で <code>ssh</code> が切れたなどの理由で不完全なバックアップができてしまった時に削除するフラグを設定します。</p>

<ul>
<li><code>sudo touch /etc/ccollect/defaults/delete_incomplete</code></li>
</ul>


<h2>ローカルのバックアップ設定の追加</h2>

<p>まず動作確認も兼ねて、ローカルのバックアップを取る設定を追加してみます。</p>

<ul>
<li><code>sudo mkdir -p /etc/ccollect/sources/$(hostname)-home</code></li>
<li><code>echo '/home' | sudo tee /etc/ccollect/sources/$(hostname)-home/source</code></li>
<li><code>echo "/srv/backup/$(hostname)-home" | sudo tee /etc/ccollect/sources/$(hostname)-home/destination</code></li>
</ul>


<p>バックアップから除外するファイルも設定してみます。
除外指定ということを明示するために <code>-</code> をつけていますが、つけずにパターンだけでもこの場合は同じです。
<code>exclude</code> ファイルの書式の詳細は <code>rsync "--exclude-from"</code> で検索して調べてください。</p>

<ul>
<li><code>echo '- *.swp' | sudo tee /etc/ccollect/sources/$(hostname)-home/exclude</code></li>
<li><code>echo '- *~' | sudo tee -a /etc/ccollect/sources/$(hostname)-home/exclude</code></li>
</ul>


<p>今回は関係ないかもしれませんが、 <code>/</code> パーティションなどをバックアップする時にはつけた方が良い <code>--one-file-system</code> オプションも追加しておきます。</p>

<ul>
<li><code>echo '--one-file-system' | sudo tee /etc/ccollect/sources/$(hostname)-home/rsync_options</code></li>
</ul>


<p>サマリー表示を有効にしておきます。
初回実行なので詳細表示も有効にしてみます。</p>

<ul>
<li><code>sudo touch /etc/ccollect/sources/$(hostname)-home/summary</code></li>
<li><code>sudo touch /etc/ccollect/sources/$(hostname)-home/verbose</code></li>
</ul>


<h3>初回バックアップ実行</h3>

<p><code>destination</code> ファイルで指定したバックアップ先ディレクトリは自動作成されないので、手動で作成してバックアップを実行します。
2 回実行してちゃんと差分バックアップになっているのを確認します。</p>

<ul>
<li><code>sudo mkdir -pv $(cat /etc/ccollect/sources/*/destination)</code></li>
<li><code>sudo ~/src/github.com/ungleich/ccollect/ccollect daily $(hostname)-home</code></li>
<li><code>sudo ~/src/github.com/ungleich/ccollect/ccollect daily $(hostname)-home</code></li>
</ul>


<p>容量も 2 倍になっていないのを確認します。</p>

<ul>
<li><code>sudo du -s /srv/backup/$(hostname)-home /home</code></li>
</ul>


<p>動作確認ができたので、詳細表示オプションを削除しておきます。</p>

<ul>
<li><code>sudo rm /etc/ccollect/sources/$(hostname)-home/verbose</code></li>
</ul>


<h2>リモートからのバックアップ設定の追加</h2>

<p><code>source</code> にリモートホストを設定する以外はローカルの設定と同様に設定していきます。</p>

<ul>
<li><code>sudo mkdir /etc/ccollect/sources/vps-etc</code></li>
<li><code>echo /srv/backup/vps-etc | sudo tee /etc/ccollect/sources/vps-etc/destination</code></li>
<li><code>echo root@vps.example.jp:/etc | sudo tee /etc/ccollect/sources/vps-etc/source</code></li>
<li><code>echo '- *.swp' | sudo tee -a /etc/ccollect/sources/vps-etc/exclude</code></li>
<li><code>echo '- *~' | sudo tee -a /etc/ccollect/sources/vps-etc/exclude</code></li>
<li><code>sudo touch /etc/ccollect/sources/vps-etc/summary</code></li>
</ul>


<p>ネットワーク的につながらない時はバックアップが失敗するので、事前チェックするようにします。</p>

<ul>
<li><code>sudoedit /etc/ccollect/sources/vps-etc/pre_exec</code></li>
<li><code>sudo chmod +x /etc/ccollect/sources/vps-etc/pre_exec</code></li>
</ul>


<p><code>pre_exec</code> の内容は以下の通りです。
<a href="https://github.com/ungleich/ccollect/blob/5356370233e0883b5c6cc62b12c84ef058f8c239/doc/ccollect.text#L872-L884">ccollect のドキュメントの Testing for host reachabilty</a> を参考にしています。</p>

<pre><code class="bash">#!/bin/sh
set -e
cur_conf_dir="${CCOLLECT_CONF:-/etc/ccollect}/sources/$name"
SRC_HOST=`cat "$cur_conf_dir/source" | cut -d"@" -f2 | cut -d":" -f1`
ping -c1 -q "$SRC_HOST" || exit $?
</code></pre>

<h3>ssh 設定</h3>

<p>セキュリティ的にはあまり好ましくないのですが、バックアップ用に root から root に ssh で接続できるようにします。</p>

<p>まず、バックアップ先のローカルのマシンで root の ssh 用の鍵を作成します。</p>

<ul>
<li><code>sudo ls -al /root/.ssh</code> で root に ssh の鍵がないのを確認したら <code>sudo ssh-keygen</code> で生成します。存在する場合は別のファイル名で生成して <code>sudoedit /root/.ssh/config</code> で <code>IdentityFile</code> を設定しておきます。自動実行で使用するので、パスフレーズは空にしておきます。</li>
<li>ssh のポート番号を変更しているなど、別途設定が必要な場合は <code>sudoedit /root/.ssh/config</code> で設定しておくのを忘れないように注意が必要です。</li>
<li><code>sudo cat /root/.ssh/id_rsa.pub</code> で公開鍵を表示してコピーしておきます。</li>
</ul>


<p>続いて、バックアップ対象の VPS (バックアップ元) の方で ssh を許可する設定をします。</p>

<ul>
<li><code>sudo install -m700 -d /root/.ssh</code> で <code>/root/.ssh</code> がなければ作成します。</li>
<li><code>sudoedit /root/.ssh/authorized_keys</code> で接続を許可する鍵として、先ほどコピーした公開鍵を貼り付けます。</li>
<li>必要に応じて <code>from="pattern-list"</code> や <code>no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding</code> などの制限も追加しておきます。</li>
<li><code>sudoedit /etc/ssh/sshd_config</code> で <code>PermitRootLogin</code> を <code>no</code> 以外にします。例えば <code>without-password</code> にしておきます。</li>
<li><code>sudoedit /etc/ssh/sshd_config</code> で <code>AllowUsers</code> による制限をしている時は <code>AllowUsers root@接続元IPアドレス</code> を追加しておきます。接続元 IP アドレスが固定ではない場合は、セキュリティ的に弱くなりますが <code>AllowUsers root</code> で許可します。</li>
<li><code>/etc/ssh/sshd_config</code> の設定を変更した場合は <code>sudo service ssh restart</code> で反映させておきます。</li>
</ul>


<p>設定ができたら、接続元 (バックアップ先のローカルのマシン) から ssh の接続確認をします。</p>

<ul>
<li><code>sudo ssh root@vps.example.jp hostname</code> などで ssh 接続ができることの確認とホスト鍵の確認を済ませておきます。</li>
</ul>


<h3>初回バックアップ実行</h3>

<p>ローカルでのバックアップと同様にバックアップ先ディレクトリを作成してからバックアップを実行します。</p>

<ul>
<li><code>sudo mkdir -pv $(cat /etc/ccollect/sources/*/destination)</code></li>
<li><code>sudo ~/src/github.com/ungleich/ccollect/ccollect daily vps-etc</code></li>
<li><code>sudo ~/src/github.com/ungleich/ccollect/ccollect daily vps-etc</code></li>
</ul>


<h2>リモートからの一般ユーザー権限でのバックアップ設定の追加</h2>

<p>dokku で persistent storage としてボリュームマウントを使っているとファイルの所有者とグループがアプリケーションのデプロイのたびに変わってしまって、差分バックアップに支障が出そうだったので、一般ユーザーでのバックアップも設定しました。</p>

<p><a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html" title="XDG Base Directory Specification">XDG Base Directory Specification</a> の <code>XDG_CONFIG_HOME</code> を参考にして <code>~/.config</code> 以下に <code>/etc</code> 以下と同じ構造で設定を作成することにしました。</p>

<ul>
<li><code>mkdir -p ~/.config/ccollect/defaults/intervals</code></li>
<li><code>echo 10 &gt; ~/.config/ccollect/defaults/intervals/daily</code></li>
<li><code>echo 24 &gt; ~/.config/ccollect/defaults/intervals/monthly</code></li>
<li><code>echo 10 &gt; ~/.config/ccollect/defaults/intervals/weekly</code></li>
<li><code>mkdir -p ~/.config/ccollect/sources/vps-srv</code></li>
<li><code>echo /srv/backup/vps-srv &gt; ~/.config/ccollect/sources/vps-srv/destination</code></li>
<li><code>echo vpsuser@vps.example.jp:/srv &gt; ~/.config/ccollect/sources/vps-srv/source</code></li>
<li><code>echo '- *.swp' &gt; ~/.config/ccollect/sources/vps-srv/exclude</code></li>
<li><code>echo '- *~' &gt;&gt; ~/.config/ccollect/sources/vps-srv/exclude</code></li>
<li><code>touch ~/.config/ccollect/sources/vps-srv/summary</code></li>
</ul>


<p>ネットワーク的につながらない時はバックアップが失敗するので、事前チェックするようにします。</p>

<ul>
<li><code>editor ~/.config/ccollect/sources/vps-srv/pre_exec</code></li>
<li><code>chmod +x ~/.config/ccollect/sources/vps-srv/pre_exec</code></li>
</ul>


<p><code>pre_exec</code> の内容は以下の通りです。
「リモートからのバックアップ設定の追加」で作成したものと全く同じ内容です。</p>

<pre><code class="bash">#!/bin/sh
set -e
cur_conf_dir="${CCOLLECT_CONF:-/etc/ccollect}/sources/$name"
SRC_HOST=`cat "$cur_conf_dir/source" | cut -d"@" -f2 | cut -d":" -f1`
ping -c1 -q "$SRC_HOST" || exit $?
</code></pre>

<h3>初回バックアップ実行</h3>

<p>一般ユーザー権限でバックアップするので、バックアップ先ディレクトリを <code>chown</code> しておきます。</p>

<p><code>ssh vpsuser@vps.example.jp</code> で一度接続してホスト鍵の確認なども終わらせておきます。</p>

<p>設定ファイルの場所が違うので、環境変数 <code>CCOLLECT_CONF</code> を設定しつつ実行します。</p>

<ul>
<li><code>sudo mkdir -pv $(cat ~/.config/ccollect/sources/*/destination)</code></li>
<li><code>sudo chown $(id -u) /srv/backup/vps-srv</code></li>
<li><code>env CCOLLECT_CONF=$HOME/.config/ccollect ~/src/github.com/ungleich/ccollect/ccollect daily vps-srv</code></li>
<li><code>env CCOLLECT_CONF=$HOME/.config/ccollect ~/src/github.com/ungleich/ccollect/ccollect daily vps-srv</code></li>
</ul>


<h2>バックアップ自動実行設定</h2>

<p>cron で毎日自動バックアップが動くように設定します。
時間がかかるので、 <code>cron.daily</code> のファイルの中でも最後に実行されるように <code>zz-</code> で始まる名前にしています。
そして、パッケージで入れたファイルと区別できるように <code>local</code> という文字列を名前に入れています。</p>

<p>その際、保存回数が一番多くて保存期間が長い <code>monthly</code> を優先するようにしてみました。</p>

<p>ログ保存用のディレクトリは一般的な debian の流儀に合わせて adm グループのみ読めるようにしています。
<code>install</code> コマンドについては <a href="http://blog.n-z.jp/blog/2014-02-14-install.html" title="installコマンドでコマンド数を減らす">installコマンドでコマンド数を減らす</a> を参考にしてください。</p>

<p>ログは rotate などはせずに全部残して、 <code>tools/ccollect_analyse_logs</code> でエラーや警告があれば cron からのメールとして飛ぶようにしました。
その際、 <code>tools/ccollect_analyse_logs</code> の exit status が <code>grep</code> の exit status そのままなので、エラーの有無と逆の意味に感じられてしまうので、反転するようにしました。</p>

<ul>
<li><code>sudoedit /etc/cron.daily/zz-local-ccollect</code></li>
<li><code>sudo chmod +x /etc/cron.daily/zz-local-ccollect</code></li>
</ul>


<pre><code class="bash /etc/cron.daily/zz-local-ccollect">#!/bin/sh
INTERVAL=daily
if [ 7 = "$(date +%u)" ]; then
  INTERVAL=weekly
fi
if [ 01 = "$(date +%d)" ]; then
  INTERVAL=monthly
fi
mkdir -p /var/log/ccollect
LOGDIR="/var/log/ccollect"
LOGFILE="$LOGDIR/$(date +%Y%m%d-%H%M).log"
LOCALUSER="localuser"
CCOLLECT_DIR="/home/$LOCALUSER/src/github.com/ungleich/ccollect"
install -m750 -oroot -gadm -d "$LOGDIR"
{
  su - "$LOCALUSER" -c 'env CCOLLECT_CONF=$HOME/.config/ccollect '"$CCOLLECT_DIR"'/ccollect -a '"$INTERVAL"
  "$CCOLLECT_DIR/ccollect" -a "$INTERVAL"
} &gt;"$LOGFILE" 2&gt;&amp;1
if /bin/sh "$CCOLLECT_DIR/tools/ccollect_analyse_logs" "we" &lt; "$LOGFILE"; then
  # found
  exit 1
else
  # not found
  exit 0
fi
</code></pre>

<h2>リモートの dokku の home のバックアップ設定</h2>

<p>他の設定例として、リモートの dokku の home のバックアップ設定もしてみました。
設定が似ている <code>vps-etc</code> を雛形としてコピーして <code>destination</code> と <code>source</code> などを書き換える形で設定しました。</p>

<ul>
<li><code>cd /etc/ccollect/sources</code></li>
<li><code>sudo cp -a vps-etc vps-home</code></li>
<li><code>sudoedit vps-home/destination</code> で <code>/srv/backup/vps-home</code> に変更</li>
<li><code>sudoedit vps-home/source</code> で <code>root@vps.example.jp:/home</code> に変更</li>
<li><code>sudoedit vps-home/exclude</code> で <code>- cache</code> を追加 (<code>/home/dokku/$APP/cache/</code> は buildpack での build 時などのキャッシュに使われるのと、ファイルの所有者とグループがどんどん変わるので、バックアップからは除外)</li>
</ul>


<h3>初回バックアップ実行</h3>

<p><code>vps-etc</code> のバックアップと同様にバックアップ先ディレクトリを作成してからバックアップを実行します。</p>

<ul>
<li><code>sudo mkdir -pv $(cat /etc/ccollect/sources/*/destination)</code></li>
<li><code>sudo ~/src/github.com/ungleich/ccollect/ccollect daily vps-home</code></li>
<li><code>sudo ~/src/github.com/ungleich/ccollect/ccollect daily vps-home</code></li>
</ul>


<h2>uid, gid 問題</h2>

<p>LDAP などでアカウントを共通化していれば問題ないのですが、 <code>rsync</code> では uid や gid を数値のまま保存してコピーするので、バックアップ元とバックアップ先で同じ uid に対して別のユーザーが存在すると、意図しないユーザーが読めるバックアップができてしまうので、注意が必要です。</p>

<p>この記事の例だと <code>/srv/backup/vps-home</code> のパーミッションを変更する (<code>sudo chmod 700 /srv/backup/vps-home</code>) などの対処をしておくと良いと思います。</p>

<h2>バックアップの差分の確認</h2>

<p><a href="https://github.com/ungleich/ccollect/blob/5356370233e0883b5c6cc62b12c84ef058f8c239/doc/ccollect.text#L858-L869" title="ccollect.text の Comparing backups">ccollect.text の Comparing backups</a> によると <code>rsync -n -a --delete --stats --progress daily.20080324-0313.17841/ daily.20080325-0313.31148/</code> のように <code>-n</code> オプション付きで <code>rsync</code> を実行することによってバックアップの差分を確認できるようです。</p>

<h2>まとめ</h2>

<p><code>ccollect</code> で差分バックアップを作成するようにしました。</p>

<p><code>rsync</code> によるバックアップなので、圧縮などもするバックアップツールと違い、バックアップの内容も元のディレクトリ構造そのままでわかりやすいので、一部だけ復元するなどの操作も素直に実行しやすくなっています。</p>

<p>ハードリンクなので i-node は消費しますが、変化がないファイルについては容量を消費しないので、バックアップサイズも抑えられます。</p>
]]></content>
  </entry>
  
</feed>
