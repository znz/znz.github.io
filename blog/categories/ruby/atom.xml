<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2013-12-14T10:59:42+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[upstart-socket-bridgeとrubyを組み合わせる]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-14-upstart-socket-bridge-with-ruby.html"/>
    <updated>2013-12-14T00:45:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/upstart-socket-bridge-with-ruby</id>
    <content type="html"><![CDATA[<p><a href="http://gihyo.jp/admin/clip/01/ubuntu-topics/201312/06">Ubuntu Weekly Topics 2013年12月6日号</a>
の「その他のニュース」で紹介されていた
「upstart-socket-bridgeをxinetdライクなソケット待ち受け管理機構として扱う
<a href="http://cheesehead-techblog.blogspot.jp/2013/12/upstart-socket-bridge.html">アプリケーションの作り方</a>
。」
が python3 で書かれていて、
同じことが ruby で実装できるのか気になったので、
IRC でちょっと助言を受けつつ移植してみました。</p>

<!--more-->


<h2>試した環境</h2>

<ul>
<li>amd64 の Ubuntu 13.10 (saucy)</li>
<li><code>/usr/bin/ruby</code> は <code>ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]</code></li>
</ul>


<h2>ruby で試す</h2>

<p>必須なのはソケット周りだけですが、
デバッグ用のメッセージをファイルに残すようにして
動作確認していたので、
その部分も残しています。</p>

<p>```ruby /tmp/test-service.rb
 #!/usr/bin/ruby
 require &lsquo;socket&rsquo;
 open(&ldquo;/tmp/test.log&rdquo;, &ldquo;w&rdquo;) do |f|
   ENV.each do |key, value|</p>

<pre><code> f.puts "#{key}=#{value}"
</code></pre>

<p>   end
   begin</p>

<pre><code> serv_socket = Socket.for_fd(ENV["UPSTART_FDS"].to_i)
 client_socket, client_addrinfo = serv_socket.accept
 message = client_socket.recv(1024)
 f.puts message
 client_socket.send("I got your message: #{message}", 0)
 client_socket.close
</code></pre>

<p>   rescue Exception => e</p>

<pre><code> f.puts e.inspect
 f.puts e.backtrace
</code></pre>

<p>   end
   f.puts &ldquo;finished&rdquo;
 end
```</p>

<p>バグとしては
<code>for_fd</code> の引数の <code>to_i</code> を忘れていたり、
<code>send</code> の引数が足りなかったりしました。</p>

<p><code>text /etc/init/socket-test.conf
 description "upstart-socket-bridge test"
 start on socket PROTO=inet PORT=34567 ADDR=127.0.0.1  # 34567 番ポートで待ち受け
 setuid exampleuser                                    # root ではなく exampleuser で動作
 exec /usr/bin/ruby /tmp/test-service.rb               # サービス起動
</code></p>

<p><code>nc</code> コマンドで接続して動作確認します。</p>

<p><code>console
 $ nc localhost 34567
 Hello Ruby
 I got your message: Hello Ruby
</code></p>

<p>最後にテストで作成したファイルを削除しておきます。</p>

<p><code>console
 $ sudo rm /etc/init/socket-test.conf  # ブリッジとの接続解除
 $ rm /tmp/test-service.rb             # テストサービス削除
 $ rm /tmp/test.log                    # ログファイル削除
</code></p>

<h2>まとめ</h2>

<p>python3 の <code>socket.fromfd</code> に相当するのは
ruby だと <code>BasicSocket.for_fd</code> で、
<code>BasicSocket</code> クラスには <code>accept</code> がないので、
<code>BasicSocket</code> クラスを継承している <code>Socket</code> クラスの
<code>Socket#for_fd</code> を使いました。</p>

<p><code>inetd</code> や <code>xinetd</code> だと標準入出力にソケットをつないでくれて、
サービスは簡単にかけるのに、
<code>upstart</code> だと <code>accept</code> して <code>accept</code> から返ってきたソケットを
<code>close</code> するまでがサービス側でやらないといけないようになっていて、
ちょっと面倒に感じました。</p>

<p>たまたま目についたプログラムを移植してみただけで、
深追いはしていないのですが、
どういう利点があるものなのか、
調べてみるのも良いのかもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rail 3.2でcache_digestsを使ってみた]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-08-cache-digests.html"/>
    <updated>2013-12-08T00:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/cache-digests</id>
    <content type="html"><![CDATA[<p>まだ Rails 3.2.16 のままのアプリで <code>cache_digests</code> gem を使って
fragment cache を導入してみました。</p>

<p>Rails 4.0 では標準になっているはずなので、
使い方は同じだと思います。</p>

<p>この投稿は
<a href="http://qiita.com/advent-calendar/2013/ruby-on-rails">Ruby on Rails Advent Calendar 2013</a>
の8日目の記事です。</p>

<!--more-->


<h2>インストール</h2>

<p>まず <code>Gemfile</code> に以下の gem の指定を追加してインストールしました。</p>

<p><code>ruby Gemfile
gem 'cache_digests'
gem 'dalli', group: :production
</code></p>

<h2>環境設定</h2>

<p>キャッシュの影響の確認などのデバッグ用に <code>development</code> 環境でも
キャッシュを有効にしました。
ちゃんとキャッシュで来ているかどうかの確認や削除がしやすいように
保存先はデフォルトの <code>:file_store</code> のままにしています。</p>

<p><code>ruby config/environments/development.rb
  config.action_controller.perform_caching = true
</code></p>

<p><code>production</code> 環境では <code>dalli</code> を使って <code>memcached</code> に保存するようにしました。
<code>dalli</code> の設定はこの記事の本題ではないので、
<code>memcached</code> の設定などは他のサイトを参考にしてください。</p>

<p><code>ruby config/environments/production.rb
  config.cache_store = :dalli_store
</code></p>

<p><code>staging</code> 環境もあったので <code>config/environments/staging.rb</code> にも同様の設定をしました。</p>

<h2>fragment cache</h2>

<p>すでに
<code>app/views/comments/_comment.html.haml</code> や
<code>app/views/posts/_post.html.haml</code> のような view を使って
<code>render @comments</code> や <code>render @posts</code> のように使っていたので、</p>

<p><code>text app/views/comments/_comment.html.haml
- cache comment do
  -# 今までの内容
</code></p>

<p>のように <code>cache comment do ... end</code> で今までの内容をくくるだけでした。
<code>cache</code> メソッド自体の返り値は <code>=</code> で埋め込んだりせずにそのまま呼ぶだけで大丈夫でした。</p>

<h2>動作確認</h2>

<p><code>log/developement.log</code> などを <code>fragment</code> で検索してみると</p>

<p><code>text log/developement.log
Write fragment views/comments/29-20130905083500/96f0ec0ce36af8132826f3bfbe0079db 0.5ms
Read fragment views/comments/30-20130905083518/96f0ec0ce36af8132826f3bfbe0079db 0.4ms
</code></p>

<p>などと記録されていて、キャッシュが使われていることが確認できました。</p>

<p><code>development</code> 環境では実際のキャッシュファイルは <code>tmp/cache/</code> 以下にありました。</p>

<h2>キャッシュの無効化 (invalidate)</h2>

<p>キャッシュが古くなってもう有効ではないという状態にすることを invalidate というと思いますが、
内容が更新された時に古いキャッシュが使われると問題があるので、
その対処をする必要があります。</p>

<p><code>cache</code> メソッドの引数に <code>ActiveRecord</code> のオブジェクトを渡した時の
キャッシュのキーは先ほどの例だと
<code>views/comments/:id-:updated_at/:md5</code>
という感じで <code>comment</code> オブジェクトの <code>id</code> と <code>updated_at</code> と
<code>app/views/comments/_comment.html.haml</code> の MD5 が使われていて、
view のファイルが変更したり、
<code>comment</code> ファイルの <code>updated_at</code> を更新したりした時に
自動で無効になるようです。</p>

<p>つまり、この view の中で別の partial render を使っていると
反映されないということなので、
内側の方でも <code>cache</code> を使うなどの対処が必要そうです。
実際に <code>_post.html.haml</code> の中で <code>render post.comments</code> のようなことをしました。</p>

<p>さらに以下のように <code>belongs_to</code> に <code>touch: true</code> を付けて、
コメントが付いた時に <code>post</code> の <code>updated_at</code> も更新されるようにしました。</p>

<p><code>ruby app/models/comment.rb
  belongs_to :commentable, polymorphic: true, touch: true
</code></p>

<h2>キャッシュの完全削除</h2>

<p><code>rails console</code> で <code>Rails.cache.clear</code> を実行すれば削除できました。
他の sass などのキャッシュも <code>tmp/cache/</code> の中にあるので
一緒に削除されてしまうようです。</p>

<h2>まとめ</h2>

<p>とりあえず使い始めるための最低限の知識をまとめてみました。</p>

<p>後は
<a href="http://ja.asciicasts.com/episodes/387-cache-digests">ASCIIcasts &ndash; “Episode 387 &ndash; Cache Digests”</a>
で説明されている
<code>rake cache_digests:nested_dependencies</code>
などを知っておけば良さそうです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 4.0.2のi18nで出るようになったdeprecated警告の対策方法]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-04-rails-i18n-deprecated-warning.html"/>
    <updated>2013-12-04T10:59:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/rails-i18n-deprecated-warning</id>
    <content type="html"><![CDATA[<p>Ruby on Rails のセキュリティアップデートがあって、
4.0.2 にあげたら i18n gem も 0.6.5 から 0.6.9 にあがって
<code>locale</code> の設定変更をしているところで
<code>[deprecated] I18n.enforce_available_locales will default to true in the future. If you really want to skip validation of your locale you can set I18n.enforce_available_locales = false to avoid this message.</code>
という警告が出るようになりました。</p>

<!--more-->


<h2>警告の出るタイミング</h2>

<p><a href="http://stackoverflow.com/questions/20361428/rails-4-0-2-i18n-validation-deprecation-warning">deprecated &ndash; Rails 4.0.2 I18n validation deprecation warning &ndash; Stack Overflow</a>
経由で
<a href="https://github.com/svenfuchs/i18n/commit/3b6e56e06fd70f6e4507996b017238505e66608c9">Add I18n.locale_available? and enforce available locales</a>
のコミットから入った変更ということで、
コミットログをみてみると、</p>

<ul>
<li><code>I18n.config.default_locale=</code></li>
<li><code>I18n.config.locale=</code></li>
<li><code>I18n.translate</code></li>
<li><code>I18n.localize</code></li>
<li><code>I18n.transliterate</code></li>
</ul>


<p>を呼んだときに影響するようです。
つまり <code>rails new</code> で作っただけだと <code>config/application.rb</code> の
<code>config.i18n.default_locale = :de</code> がコメントアウトされていて、
警告は出ません。</p>

<h2>日本語のみで使う場合</h2>

<p>日本語のみで使うのなら、
将来のデフォルトの
<code>I18n.enforce_available_locales = true</code>
にしてしまってから、
普通に日本語をデフォルトにする
<code>config.i18n.default_locale = :ja</code>
を呼べば良いと思います。</p>

<p>```ruby config/application.rb</p>

<pre><code>I18n.enforce_available_locales = true
config.i18n.default_locale = :ja
</code></pre>

<p>```</p>

<p>ただし、先にちゃんと日本語の locale ファイルを作っておかないと
<code>I18n::InvalidLocale</code>
という例外が発生して、
<code>rake</code> などで
<code>:ja is not a valid locale</code>
と言われてしまいます。</p>

<h2>今まで通りの挙動にする場合</h2>

<p><code>I18n.enforce_available_locales = false</code>
にすれば今まで通りの挙動になり、
存在しない <code>locale</code> を設定しても例外は発生しません。</p>

<h2>今のデフォルト</h2>

<p>今は
<code>I18n.enforce_available_locales = nil</code>
がデフォルトになっていて、
<code>nil</code> だと警告がでる、
ということのようです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.1.0の新機能のException#cause]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-03-ruby-exception-cause.html"/>
    <updated>2013-12-03T00:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/ruby-exception-cause</id>
    <content type="html"><![CDATA[<p><a href="https://www.ruby-lang.org/ja/news/2013/11/22/ruby-2-1-0-preview2-is-released/">Ruby 2.1.0-preview2 リリース</a>
では
<a href="http://d.hatena.ne.jp/nagachika/20131110/ruby_trunk_changes_43615_43636">2013-11-10 の大きめの変更</a>
が気になっていて、
ここでは
<code>Exception#cause</code>
というメソッドを紹介します。</p>

<p><code>"literal"f</code> のように書く freeze された文字列リテラル機能が
2.1.0-preview1 には入っていたのですが、それが削除されて
<code>"literal".freeze</code> がコンパイル時に特別扱いされるようになった、
というのも気になっています。</p>

<p>この投稿は
<a href="http://qiita.com/advent-calendar/2013/ruby">Ruby Advent Calendar 2013</a>
の3日目の記事です。</p>

<!--more-->


<h2>Exception#cause の例</h2>

<p>Ruby 2.0.0 までは <code>rescue</code> や <code>ensure</code> の中で別の例外が発生すると、
別途保存しておかない限り、
以前に発生した例外がわからなくなってしまっていましたが、
Ruby 2.1.0(-preview2) からは別の例外を <code>raise</code> した時に
以前の例外が自動で保存されて
<code>Exception#cause</code> でたどれるようになりました。
<code>cause</code> は <code>raise</code> のタイミングで設定されるので、
例外オブジェクト自体は <code>rescue</code> や <code>ensure</code>
の外で生成していても良いようです。</p>

<p>```ruby</p>

<h1>!/usr/bin/env ruby</h1>

<p>def foo
  raise &ldquo;foo&rdquo;
end</p>

<p>def bar
  e = Exception.new(&ldquo;bar&rdquo;)
  foo
rescue
  raise e
end</p>

<p>def baz
  bar
ensure
  raise &ldquo;baz&rdquo;
end</p>

<p>begin
  baz
rescue
  p $!                   #=> #&lt;RuntimeError: baz>
  p $!.cause             #=> #&lt;Exception: bar>
  p $!.cause.cause       #=> #&lt;RuntimeError: foo>
  p $!.cause.cause.cause #=> nil
end
```</p>

<h2>終了時のバックトレース</h2>

<p>ちなみに、例外が保存されていても
<code>rescue</code> せずにプログラムが終了した時のバックトレースは
今まで通り最後の例外だけ表示されるようです。</p>

<p>```console
% cat t.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>def foo
  raise &ldquo;foo&rdquo;
end</p>

<p>def bar
  foo
rescue
  raise &ldquo;bar&rdquo;
end</p>

<p>bar
% ruby t.rb
t.rb:9:in `rescue in bar': bar (RuntimeError)</p>

<pre><code>from t.rb:7:in `bar'
from t.rb:12:in `&lt;main&gt;'
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nadokaさんの0.8.6をリリースした関連の話]]></title>
    <link href="http://blog.n-z.jp/blog/2013-11-29-nadoka-086-released.html"/>
    <updated>2013-11-29T23:30:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/nadoka-086-released</id>
    <content type="html"><![CDATA[<p><a href="http://mla.n-z.jp/?ruby-list:49704">nadoka さんの 0.8.6 をリリース</a>
したので、
その関連の話を書いてみようと思います。</p>

<!--more-->


<h2>なぜ続けているか</h2>

<p>短い答えとしては、自分が使っているからというのが一番大きな理由です。</p>

<p>bot というか plugin もいくつか作って、
サーバーの管理などにも便利に使っていて、
わざわざ他の IRC proxy 的なソフトに乗り換えて
プラグインを書き直すよりは、
一応動いているものをメンテナンスし続けた方が楽というのが
理由になっています。</p>

<h2>subversion repository について</h2>

<p>最初は
<a href="http://www.atdot.net/nadoka/nadoka.ja.html">atdot.net の nadoka さん</a>
のところに書いてある
<code>http://www.atdot.net/svn/nadoka/trunk</code>
にあったものが、
ささださんのサーバー管理の都合なのか、
rubyforge に移行して今に至ります。</p>

<p>途中から
(<a href="https://github.com/nadoka/nadoka/wiki/HowToRelease">HowToRelease</a>
の記録によると 0.7.7 から)
は github メインに移行しています。</p>

<p>その後、しばらく放置していたかどうだったのか忘れましたが、
最近のリリースでは github での変更をリリースのタイミングで
rubyforge の svn にも git-svn を使ってマージしていました。</p>

<p>このマージも今回で最後になります。</p>

<p>その作業をするときに
<code>http://rubyforge.org/</code>
をみてみると
<code>RubyForge Could Not Connect to Database:</code>
というエラーになっていて、
<a href="https://twitter.com/hsbt/status/406423900432506881">hsbt さん</a>
に
<a href="https://twitter.com/evanphx/status/399552820380053505">RubyForgeは5月15日で終了予定</a>
という話を教えてもらいました。</p>

<p>古いサーバーで svn co して、
そのまま使っている場合でも使い続けられるように続けていましたが、
rubyforge 自体が終わるということで、
そういうサーバーでは、
そのまま最後の svn up をして使い続けるか、
git に移行する必要がありそうです。</p>

<h2>git repository について</h2>

<p>github が主流になっていたこともあり、
pull request とかしやすくなることを期待して
移行しました。</p>

<p>pull request が来た件数も 0 ではないので、
そのあたりは活発ではないプロジェクトとしては
うまくいっているのではないでしょうか。</p>

<p>github への移行方法として、
最初は
<a href="http://darcs.net/RelatedSoftware/Tailor">tailor</a>
を検討したのですが、
既にあまり使われていなくて、
ちょっと試した感じでもうまくいかなかったので、
git-svn で移行しました。</p>

<p>今となっては変換専用ソフトはほぼ使えるものはなく、
変換先のソフト (今回は git) のプラグイン的なものを使って
変換元のソフト (今回は svn) の repository から取り出す、
という方法しかないようです。</p>

<h2>CloudCore VPS</h2>

<p><a href="http://www.cloudcore.jp/vps/develop/">開発者支援制度 &ndash; CloudCore VPS</a>
でサーバーを借りてみて、
テスト用の IRC サーバーを動かしています。</p>

<p>接続用の設定は
<a href="https://github.com/nadoka/nadokarc-example">nadokarc-example</a>
にあるので、適当に試したい時に使えると思います。</p>

<p>途中の経路の問題 (モバイルでモバイルルーターの接続が切れたとか?)
で、サーバーから応答がなくなったときに
nadoka さんの再接続がうまくいかないのを調査するのに使いたいと
思っているのですが、
切れた状況を再現する部分の作り込みがまだ出来ていないです。</p>

<p>ircd の設定は
<a href="https://github.com/nadoka/ansible-ircd">ansible-ircd</a>
のように ansible でやってみました。
SSL の証明書の問題などがあるので、
すべての情報を公開できるわけじゃないというのが難しいところです。</p>

<h2>まとめ的なもの</h2>

<p>長い間続いているといろいろあるものです。</p>

<p>小規模なプロジェクトなので、
いつも場当たり的な対応でなんとかなっていますが、
そういうのも良いんじゃないでしょうか。</p>

<p>とりあえず自分が使っている限りはリリースも続くと思いますし、
新しいバージョンの ruby への対応も続けていけると思います。</p>
]]></content>
  </entry>
  
</feed>
