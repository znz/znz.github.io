<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2014-08-03T12:32:03+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ruby-buildをrbenvと組み合わせずに使う]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-27-ruby-build-without-rbenv.html"/>
    <updated>2014-07-27T17:08:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/ruby-build-without-rbenv</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/sstephenson/ruby-build" title="ruby-build">ruby-build</a>
は
<a href="https://github.com/sstephenson/rbenv" title="rbenv">rbenv</a>
と組み合わせて使われることが多いですが、
単独でも使えて、その情報が少ないので少し書いておきます。</p>

<!--more-->


<h2><code>/usr/local</code> にインストールする方法</h2>

<p><code>ruby-build</code> 自体もインストールしてしまう場合は
<code>install.sh</code> を使ってインストールします。</p>

<p><code>sh
git clone --depth 1 https://github.com/sstephenson/ruby-build
ruby-build/install.sh
rm -rf ruby-build
ruby-build 2.1.2 /usr/local
</code></p>

<p>もっと詳しい使い方は
<a href="http://qiita.com/takahashim/items/406421d515ef1d4f1189" title="[ReVIEW Tips] DockerでRe:VIEW">[ReVIEW Tips] DockerでRe:VIEW</a>
が参考になると思います。</p>

<h2>ruby だけインストールする方法</h2>

<p><code>bin/ruby-build</code> を直接実行すれば <code>ruby-build</code> をインストールせずに
<code>ruby</code> だけインストールすることもできます。</p>

<p><code>sh
git clone --depth 1 https://github.com/sstephenson/ruby-build
ruby-build/bin/ruby-build 2.1.2 /usr/local
rm -rf ruby-build
</code></p>

<p>ドキュメントの生成を止めたり、
インストール中のメッセージを出したりするために
以下のように実行するのも良いと思います。</p>

<p><code>sh
git clone --depth 1 https://github.com/sstephenson/ruby-build
export CONFIGURE_OPTS="--disable-install-doc"
ruby-build/bin/ruby-build --verbose 2.1.2 /usr/local
rm -rf ruby-build
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[62nd Ruby/Rails勉強会@関西に参加した]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-26-kansaiworkshop062.html"/>
    <updated>2014-07-26T13:27:09+09:00</updated>
    <id>http://blog.n-z.jp/blog/kansaiworkshop062</id>
    <content type="html"><![CDATA[<p><a href="http://rubykansai.doorkeeper.jp/events/13160" title="62nd Ruby/Rails勉強会@関西">62nd Ruby/Rails勉強会@関西</a>
に参加したので、そのメモです。</p>

<!--more-->


<h2>スクレイピングの話</h2>

<p>後で資料は公開してくれるということで、メモはとらずに話をきいていましたが、
実際にどういうことに使っている話も多くて面白かったです。</p>

<p>資料は
<a href="http://www.slideshare.net/takurosasaki/ruby-crawler" title="Rubyで作るクローラー Ruby crawler">Rubyで作るクローラー Ruby crawler</a>
で公開されています。</p>

<h2>Rails Girls Osaka の話</h2>

<p><a href="http://railsgirls.com/osaka" title="Osaka 6-7th June 2014">Rails Girls Osaka 6-7th June 2014</a>
の話でした。
写真が多いので資料の公開はないということでした。</p>

<p>今後の予定としては、
<a href="http://railsgirls.jp/events/" title="近日開催のイベント">近日開催のイベント</a>
にはないですが、
<a href="http://railsgirls.com/events" title="Upcoming Events">Upcoming Events</a>
には
<a href="http://rubyhiroba.org/2014/" title="RubyHiroba 2014">RubyHiroba 2014</a>
での
<a href="http://rubyhiroba.org/2014/rails-girls.html" title="Rails Girls Tokyo 4th">Rails Girls Tokyo 4th</a>
も書いていました。</p>

<h2>Gemfile.local の話</h2>

<p>redmine とかでも使っている方法で、
追記せずに何か良い方法はないのかという相談でした。</p>

<h2>るびま (Rubyist Magazine) の話</h2>

<ul>
<li><a href="http://magazine.rubyist.net/">http://magazine.rubyist.net/</a></li>
<li>誤植などの指摘は <a href="https://github.com/rubima/rubima-support">https://github.com/rubima/rubima-support</a> へ。</li>
<li><a href="http://goo.gl/KpASY9">Rubyist Magazine 十周年へのメッセージ</a> 募集中</li>
</ul>


<h2>GitLab の Git Flow の話</h2>

<div style="float:right">
<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=znz-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=477416366X" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
</div>


<ul>
<li><a href="https://gitlab.com/gitlab-org/cookbook-gitlab/blob/master/README.md" title="GitLab Cookbook">GitLab Cookbook</a> のベースを作った。</li>
<li><a href="http://www.amazon.co.jp/gp/product/477416366X/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=477416366X&amp;linkCode=as2&amp;tag=znz-22">GitHub実践入門 ~Pull Requestによる開発の変革 (WEB+DB PRESS plus)</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=znz-22&amp;l=as2&amp;o=9&amp;a=477416366X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> はおすすめと言っていました。</li>
<li><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.ja_JP.html" title="git-flow cheatsheet">git-flow cheatsheet</a></li>
<li><a href="https://guides.github.com/introduction/flow/index.html" title="Understanding the GitHub Flow · GitHub Guides">Understanding the GitHub Flow · GitHub Guides</a></li>
<li>GitLab Flow の提案</li>
<li>Git Flow について詳細に説明</li>
</ul>


<p>GitLab Flow は git flow を知っている人向けに大雑把に説明すると</p>

<ul>
<li>release ブランチは使わない。</li>
<li>develop ブランチの代わりに master ブランチを使う。</li>
<li>master ブランチの代わりに stable ブランチを作る。</li>
</ul>


<p>ということだと理解しました。</p>

<h2>Ruby 初級者向けレッスン 50回 ブロック</h2>

<p><code>block.call</code> の引数に複数渡すのがいいのか、配列でまとめて渡すのが良いのかという話はきいたことがなかったので、どういう話なのかちょっと気になりました。</p>

<p>多重代入について深入りすると大変そうなので、さらっと流したのはありだと思いました。</p>

<h2>@IT Rails4 入門記事をツッコもう</h2>

<ul>
<li><a href="http://www.atmarkit.co.jp/ait/articles/1402/28/news047_2.html" title="開発現場でちゃんと使えるRails 4入門（1）：簡単インストールから始める初心者のためのRuby on Railsチュートリアル (2/3) - ＠IT">開発現場でちゃんと使えるRails 4入門（1）：簡単インストールから始める初心者のためのRuby on Railsチュートリアル (2/3) &ndash; ＠IT</a></li>
<li>rbenv 対 RVM</li>
<li>エディタは Sublime Text, Vim, Emacs が多くて、その他 Atom, Eclipse</li>
<li><code>rails new</code> の時の <code>--skip-bundle</code> と <code>bundle install --path vendor/bundle</code> の話</li>
<li><code>bundle exec</code> の話</li>
<li><a href="http://www.atmarkit.co.jp/ait/articles/1405/16/news024.html" title="開発現場でちゃんと使えるRails 4入門（4）：現場で使えるか見極めたいRails 4.1の新機能8選 - ＠IT">開発現場でちゃんと使えるRails 4入門（4）：現場で使えるか見極めたいRails 4.1の新機能8選 &ndash; ＠IT</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 13 回 RubyMotion もくもく会 in Osaka に参加した]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-16-rubymotion-mokumoku-osaka.html"/>
    <updated>2014-07-16T19:33:35+09:00</updated>
    <id>http://blog.n-z.jp/blog/rubymotion-mokumoku-osaka</id>
    <content type="html"><![CDATA[<p>第 1 回から第 12 回にも参加した RubyMotion もくもく会 in Osaka の
<a href="http://rubymotionjp.connpass.com/event/7079/">第 13 回 RubyMotion もくもく会 in Osaka</a>
に参加してきました。
今日はほぼ途中の会話はなくて、みんなでもくもくしていました。
その代わり、最後の成果発表の時は盛り上がっていました。</p>

<p>次回の
<a href="http://rubymotionjp.connpass.com/event/7583/" title="第 14 回 RubyMotion もくもく会 in Osaka">第 14 回 RubyMotion もくもく会 in Osaka</a>
は 08/20(水) になりました。</p>

<!--more-->


<h2>メモ</h2>

<ul>
<li>AppCode</li>
<li>TapTheCircle</li>
<li>motion-osx-cli</li>
<li><a href="https://speakerdeck.com/iwazer/rubymotionfalseqi-chi-tiiitokoro" title="RubyMotionの気持ちいいところ // Speaker Deck">RubyMotionの気持ちいいところ // Speaker Deck</a></li>
<li>RubyMotion + IB で参考にしたもの

<ul>
<li><a href="http://tama.hatenablog.jp/entry/2014/05/02/231633" title="RubyMotion(MacOS)でIBの作成方法 - たまたんのぶろぐ">RubyMotion(MacOS)でIBの作成方法 &ndash; たまたんのぶろぐ</a></li>
<li><a href="http://d.hatena.ne.jp/laiso+iphone/20130510/1368201914" title="RubyMotionアプリでStoryboardとIBのアウトレット+アクションを使う話 - laiso+iphone">RubyMotionアプリでStoryboardとIBのアウトレット+アクションを使う話 &ndash; laiso+iphone</a></li>
</ul>
</li>
<li><a href="https://github.com/omoon/rm-test-test">https://github.com/omoon/rm-test-test</a>

<ul>
<li>travis-ci で RubyMotion のテストも動かせるという話</li>
<li><code>bundle exec rake spec osx=true</code> にすれば OSX も動く。</li>
<li>参考: <a href="https://github.com/rubymotion/BubbleWrap/blob/master/.travis.yml">https://github.com/rubymotion/BubbleWrap/blob/master/.travis.yml</a></li>
</ul>
</li>
<li><a href="https://github.com/mattsears/nyan-cat-formatter">https://github.com/mattsears/nyan-cat-formatter</a></li>
</ul>


<h2>今日の成果</h2>

<p>情報を探してみたら <code>rake ib</code> で Interface Builder を起動すれば stub を自動生成してくれて、
ボタンクリックとアクションのひも付けができるとわかったので、
ボタンをクリックした時にメソッド呼び出しはできるようになりました。</p>

<p>しかし、 <code>ib_outlet</code> で宣言したプロパティに outlet でひも付けしたインスタンス変数が <code>nil</code> のままで悩んでいたところ、
最後に <code>outlet</code> に変えると動くようになりました。
<code>ib_outlet</code> のままでも Interface Builder で出てくるので使えるのかと勘違いしていました。</p>

<p>家に帰ってから
<code>$(find /System/Library/Frameworks -name lsregister) -kill -r -domain local -domain user</code>
で既存の起動の関連付けを削除して、
ib 版で <code>Set Default Browser</code> をやり直したところ、
まだ問題があったので、それも直して以前のものと同様に使えるところまでは出来ました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[doorkeeper providerサンプルアプリに対応するOAuthクライアントをdeviseで作成した]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-15-doorkeeper-devise-client.html"/>
    <updated>2014-07-15T18:50:40+09:00</updated>
    <id>http://blog.n-z.jp/blog/doorkeeper-devise-client</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/znz/doorkeeper-provider-app">doorkeeper-provider-app</a>
を使って SSO (Single Sign On) のように使うクライアントアプリを作成しました。
<a href="https://github.com/znz/doorkeeper-devise-client-app">doorkeeper-devise-client-app</a>
で公開しています。</p>

<p>SSO は OAuth 2.0 の本来の使い方ではないので、不便な部分もありますが、
クライアント側の例として参考になると思います。</p>

<!--more-->


<h2>動作確認バージョン</h2>

<ul>
<li>ruby 2.1.2</li>
<li>rails 4.1.4</li>
<li>bootstrap 3.2.0</li>
<li>devise 3.2.4</li>
<li>omniauth 1.2.2</li>
<li>omniauth-oauth2 1.2.0</li>
<li>bootstrap-sass 3.2.0.0</li>
<li>dotenv-rails 0.11.1</li>
</ul>


<h2>簡単な役割解説</h2>

<p>provider は doorkeeper gem を入れている rails アプリ側で認証や認可を受け持ちます。
(OAuth の仕様的には認証と認可が別々のサーバーのこともあります。)</p>

<p>ここでいう OAuth クライアントは devise + omniauth + omniauth-oauth2 を使った rails アプリのことです。
ブラウザーなどのユーザー側にあるクライアントではなく、ユーザーから見れば、これもサーバーです。</p>

<p>詳しいことは OAuth 2.0 の仕様を調べてください。</p>

<h2>大まかな流れ</h2>

<ol>
<li><code>lib/omniauth/strategies/doorkeeper.rb</code> 作成</li>
<li><code>config/initializers/devise.rb</code> で <code>config.omniauth :doorkeeper, ...</code></li>
<li><code>app/controllers/users/omniauth_callbacks_controller.rb</code> 作成
(<code>uid</code> でユーザーを自動作成したり、 <code>access_token</code> (<code>credentials.token</code>) を保存したり)</li>
<li><code>config/routes.rb</code> に設定</li>
<li><code>user</code> に <code>provider</code> を追加</li>
<li><code>app/models/user.rb</code> で <code>devise :omniauthable</code> や <code>uid</code> を使った処理を実装</li>
<li><code>OAuth2::AccessToken</code> を生成</li>
<li>それを使って API アクセス</li>
</ol>


<p><code>access_token</code> を session に保存するかデータベースに保存するかは
アプリケーションのポリシー次第になります。
このアプリでは session に保存しています。</p>

<p>別途 callback uri として <code>http://localhost:3000/users/auth/doorkeeper/callback</code> のような URL を指定して
doorkeeper 側の <code>oauth/applications</code> に登録しておく必要があります。</p>

<h2><code>lib/omniauth/strategies/doorkeeper.rb</code> 作成</h2>

<p>例として
<a href="https://github.com/doorkeeper-gem/doorkeeper-devise-client" title="Dookreeper Devise+Omniauth Client">Dookreeper Devise+Omniauth Client</a>
と比較して <code>info</code> に <code>name</code> を増やしています。</p>

<p>コントローラーを <code>users</code> の下の <code>Users::OmniauthCallbacksController</code> にしたので、
戻り先の <code>authorize_path</code> は <code>'/oauth/authorize'</code> ではなく <code>'/users/oauth/authorize'</code> になっています。</p>

<p>info のハッシュはサーバーから受け取れていて、後の処理でもっと欲しい情報があれば自由に増やせます。</p>

<p>```ruby lib/omniauth/strategies/doorkeeper.rb
module OmniAuth
  module Strategies</p>

<pre><code>class Doorkeeper &lt; OmniAuth::Strategies::OAuth2
  option :name, :doorkeeper

  option :client_options, {
    site: 'http://localhost:4000',
    authorize_path: '/users/oauth/authorize'
  }

  uid do
    raw_info['id']
  end

  info do
    {
      email: raw_info['email'],
      name: raw_info['name'],
    }
  end

  def raw_info
    @raw_info ||= access_token.get('/api/v1/me.json').parsed || {}
  end
end
</code></pre>

<p>  end
end
```</p>

<h2><code>config/initializers/devise.rb</code> で設定</h2>

<p><a href="https://github.com/doorkeeper-gem/doorkeeper-devise-client">サンプルアプリ</a>
では</p>

<p><code>ruby config/initializers/devise.rb
  config.omniauth :doorkeeper,  DOORKEEPER_APP_ID, DOORKEEPER_APP_SECRET, :client_options =&gt;  {:site =&gt; DOORKEEPER_APP_URL}
</code></p>

<p>となっていました。</p>

<p><code>scope</code> も追加すると以下のようになります。
<code>dotenv</code> を使って <code>ENV</code> から取るようにしました。</p>

<p><code>ruby config/initializers/devise.rb
  config.omniauth :doorkeeper, ENV['DOORKEEPER_APP_ID'], ENV['DOORKEEPER_APP_SECRET'], client_options: {site: ENV['DOORKEEPER_APP_URL'] }, scope: 'public write'
</code></p>

<p><code>scope</code> は <code>'public,write'</code> だと <code>The requested scope is invalid, unknown, or malformed.</code> というエラーになってしまったので、
<code>,</code> 区切りではなくスペース区切りにしています。</p>

<h2><code>app/controllers/users/omniauth_callbacks_controller.rb</code> 作成</h2>

<p>callback で認証結果を受け取る部分を作成します。
ここで認証結果を受け取って、ユーザーを必要に応じてひも付けたり、
後で API アクセスに使うアクセストークンを保存したりします。</p>

<p>認証に失敗した時はログイン画面 (あれば) か <code>root_path</code> に戻すようにしています。</p>

<p>```ruby app/controllers/users/omniauth_callbacks_controller.rb
class Users::OmniauthCallbacksController &lt; Devise::OmniauthCallbacksController
  # <a href="https://github.com/plataformatec/devise/issues/2432">https://github.com/plataformatec/devise/issues/2432</a>
  protect_from_forgery except: :doorkeeper
  skip_filter :auto_authenticate_omniauth_user!, only: :doorkeeper</p>

<p>  def doorkeeper</p>

<pre><code># You need to implement the method below in your model (e.g. app/models/user.rb)
oauth_data = request.env['omniauth.auth']
@user = User.find_or_create_for_doorkeeper_oauth(oauth_data)
session[:doorkeeper_token] = oauth_data['credentials']['token']

if @user.persisted?
  sign_in_and_redirect @user, :event =&gt; :authentication #this will throw if @user is not activated
  if is_navigational_format?
    set_flash_message(:notice, :success, kind: ENV['DOORKEEPER_APP_NAME'] || 'Doorkeeper')
    # hide flash message after auto sign in
    #flash.delete(:notice)
  end
else
  session['devise.doorkeeper_data'] = request.env['omniauth.auth']
  if respond_to?(:new_user_registration_url)
    redirect_to new_user_registration_url
  else
    redirect_to root_url
  end
end
</code></pre>

<p>  end</p>

<p>  def after_omniauth_failure_path_for(scope)</p>

<pre><code>if respond_to?(:new_session_path)
  new_session_path(scope)
else
  root_path
end
</code></pre>

<p>  end
end
```</p>

<p>自動ログイン後のメッセージが不要なら <code>set_flash_message</code> の部分を <code>flash.delete(:notice)</code> に置き換えます。
「Doorkeeper でログインしました」だとどのサイトか区別がつかないので、
<code>ENV['DOORKEEPER_APP_NAME']</code> で表示用の名前を設定できるようにしています。</p>

<h2><code>config/routes.rb</code> に設定</h2>

<p><code>config/routes.rb</code> で <code>omniauth_callbacks</code> として独自のものを使うように設定します。</p>

<p>今回は認証必須なので不要ですが、
例として <code>sign_in</code> と <code>sign_out</code> の URL も入れました。
実際に試してみるとすぐに自動ログインで再ログインしてしまいます。</p>

<p><code>sign_out</code> が <code>get</code> か <code>delete</code> か違うことがあるので、
<code>sign_out_via</code> を使ってどちらでも対応できるようにしました。</p>

<p>```ruby config/routes.rb
  devise_for :users, controllers: { omniauth_callbacks: &lsquo;users/omniauth_callbacks&rsquo; }
  devise_scope :user do</p>

<pre><code>get 'sign_in',  to: 'devise/sessions#new',     as: :new_user_session
__send__ Devise.sign_out_via, 'sign_out', to: 'devise/sessions#destroy', as: :destroy_user_session
</code></pre>

<p>  end
```</p>

<h2>timeoutable 設定</h2>

<p>SSO 的に使うのは
OAuth 2.0 の本来の目的ではないので、
ログアウトは難しい問題です。
たとえば
doorkeeper
と連携するアプリが複数あるときにまとめてログアウト出来ないなどの問題があります。</p>

<p>そのため、このアプリでは一定時間で再ログインが必要になるように <code>timeoutable</code> を使って、
こまめに認証し直すようにしてログアウト問題を緩和しています。</p>

<p>その副作用として入力に時間のかかるフォームがあると入力途中でタイムアウトしてしまって
投稿に失敗するなどの問題も起きるので、その点を考慮しておく必要があります。</p>

<p><code>ruby config/initializers/devise.rb
  # Default is 30 minutes.
  config.timeout_in = 1.minutes if Rails.env.development?
  config.expire_auth_token_on_timeout = true
</code></p>

<h2>app/models/user.rb に実装</h2>

<p><code>find_or_create_for_doorkeeper_oauth</code> の実装は <code>concerns</code> に分けてみました。
<code>omniauthable</code> に <code>omniauth_providers</code> も設定して余計な route が生成されないようにしています。
<code>timeoutable</code> も入れています。</p>

<p><code>ruby app/models/user.rb
  devise :omniauthable, omniauth_providers: [:doorkeeper]
  devise :timeoutable
  include DoorkeeperOauthFinder
</code></p>

<p>ログインしたときに <code>name</code> や <code>email</code> が変わっていたら反映するようにしています。</p>

<p><code>id</code> を統一したいのなら、 <code>create</code> のときに <code>id</code> まで指定すると
doorkeeper gem による OAuth provider 側とユーザーの ID を統一できます。</p>

<p>SSO 的に使うのならパスワードは不要なので、
ここではコメントアウトしています。</p>

<p>```ruby app/models/concerns/doorkeeper_oauth_finder.rb
module DoorkeeperOauthFinder
  extend ActiveSupport::Concern</p>

<p>  module ClassMethods</p>

<pre><code>def find_or_create_for_doorkeeper_oauth(oauth_data)
  uid = oauth_data.uid.to_s
  id = uid.to_i
  user = self.where(provider: oauth_data.provider, uid: uid).first
  if user
    user.name = oauth_data.info.name
    user.email = oauth_data.info.email
    user.save! if user.changed?
  else
    user = self.create!({
      id: id, # use same id
      name: oauth_data.info.name,
      provider: oauth_data.provider,
      uid: uid,
      email: oauth_data.info.email,
      #password: Devise.friendly_token[0,20]
    })
  end
  user
end
</code></pre>

<p>  end
end
```</p>

<p>データベースの migration の方でも削除して unique index の制約なども不要なものは外しておきます。</p>

<p>```ruby db/migrate/*_devise_create_users.rb</p>

<pre><code>  ## Database authenticatable
  t.string :email,              null: false, default: ""
  # t.string :encrypted_password, null: false, default: ""
</code></pre>

<p>```</p>

<p>代わりに <code>provider</code> と <code>uid</code> と <code>name</code> を追加しました。
このアプリは Doorkeeper 専用なので、直接 <code>users</code> に追加していますが、
複数プロバイダに対応するには <code>provider</code> と <code>uid</code> の組を別テーブルにします。</p>

<p>```ruby db/migrate/*_add_omniauth_columns_to_users.rb
class AddOmniauthColumnsToUsers &lt; ActiveRecord::Migration
  def change</p>

<pre><code>add_column :users, :provider, :string
add_column :users, :uid, :string
add_column :users, :name, :string
add_index :users, [:provider, :uid], unique: true
</code></pre>

<p>  end
end
```</p>

<h2><code>OAuth2::AccessToken</code> を生成</h2>

<p><code>OAuth2::Client</code> と保存しておいた <code>access_token</code> を引数にして <code>OAuth2::AccessToken</code> を生成します。
ここでは <code>concerns</code> に分けて必要なコントローラーでだけ <code>include DoorkeeperApiV1</code> するようにしました。
全体で使いたいのなら <code>ApplicationController</code> に <code>include</code> すれば良いと思います。</p>

<p>```ruby app/controllers/concerns/doorkeeper_api_v1.rb
module DoorkeeperApiV1
  private</p>

<p>  def access_token</p>

<pre><code>return @access_token if defined?(@access_token)
config = Devise.omniauth_configs[:doorkeeper]
strategy = config.strategy_class.new(*config.args)
token = session[:doorkeeper_token]
@access_token = OAuth2::AccessToken.new(strategy.client, token)
</code></pre>

<p>  end</p>

<p>  def get_me</p>

<pre><code>access_token.get("/api/v1/me.json").parsed
</code></pre>

<p>  end</p>

<p>  def get_microposts</p>

<pre><code>access_token.get("/api/v1/microposts.json").parsed
</code></pre>

<p>  end</p>

<p>  MICROPOST_CONTENT_MAX_LENGTH = 140</p>

<p>  def post_micropost(micropost)</p>

<pre><code>micropost[:content] = micropost[:content].truncate(MICROPOST_CONTENT_MAX_LENGTH)
access_token.post("/api/v1/microposts", params: { micropost: micropost }).parsed
</code></pre>

<p>  end
end
```</p>

<p>使い方は <code>get_me</code> などを呼び出すだけなので省略します。</p>

<h2>ログインを強制する</h2>

<p>常に Doorkeeper の方でログインさせておきたいアプリの場合は、
User クラスを使っている場合の devise での戻り先の <code>session[:user_return_to]</code> に URL を保存しておいて、
<code>user_omniauth_authorize_path(:doorkeeper)</code> に強制的にリダイレクトしています。
<code>main_app.</code> をつけているのは route で mount している engine の中で問題が起きたことがあったためです。</p>

<p><code>ruby app/controllers/application_controller.rb
  include AuthDoorkeeper
  before_action :auto_authenticate_omniauth_user!
</code></p>

<p>```ruby app/controllers/concerns/auth_doorkeeper.rb
module AuthDoorkeeper
  private</p>

<p>  def auto_authenticate_omniauth_user!</p>

<pre><code>return if current_user
session[:user_return_to] = request.original_url
redirect_to main_app.user_omniauth_authorize_path(:doorkeeper)
</code></pre>

<p>  end
end
```</p>

<h2>テストについて</h2>

<p>API 呼び出しの部分の対処が出来ていなくて、まだテストが通る状態には出来ていません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apt-cacher-ngでliveイメージ作成を繰り返す時の無駄なダウンロードを減らす]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-14-apt-cacher-ng.html"/>
    <updated>2014-07-14T23:53:14+09:00</updated>
    <id>http://blog.n-z.jp/blog/apt-cacher-ng</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/znz/rubylive-builder" title="rubylive-builder">rubylive-builder</a>
で
<a href="https://github.com/znz/rubylive" title="RubyLive">RubyLive</a>
という Debian wheezy ベースの Live イメージを作成するときに
<code>apt-get update</code> などで何度も無駄にダウンロードしてしまうので、
<code>apt-cacher-ng</code> で Live イメージ作成を繰り返す時の無駄なダウンロードを減らすことにしました。</p>

<!--more-->


<h2>Vagrant の provision でインストール</h2>

<p>Vagrantfile では</p>

<p>```ruby Vagrantfile
  config.vm.provision :shell do |shell|</p>

<pre><code>shell.path = "provision.sh"
</code></pre>

<p>  end
```</p>

<p>のようにシェルスクリプトでプロビジョニングしているだけだったので、
その中で以下のようにインストールして設定するようにしました。</p>

<p><code>bash provision.sh
apt-get install -y apt-cacher-ng
echo 'Acquire::http::Proxy "http://localhost:3142/";' &gt;/etc/apt/apt.conf.d/02proxy
</code></p>

<p>Vagrantfile で以下のようにポートフォワーディングを設定していれば
<a href="http://gihyo.jp/admin/serial/01/ubuntu-recipe/0315" title="第315回　apt-cacher-ngを使ってAPT用キャッシュプロキシの構築：Ubuntu Weekly Recipe｜gihyo.jp … 技術評論社">第315回　apt-cacher-ngを使ってAPT用キャッシュプロキシの構築：Ubuntu Weekly Recipe｜gihyo.jp … 技術評論社</a>
の2ページ目に説明があるようにヒット率などを確認できます。</p>

<p><code>ruby Vagrantfile
  # apt-cacher-ng
  config.vm.network "forwarded_port", guest: 3142, host: 3142
</code></p>

<h2>rake コマンドで環境変数を渡す</h2>

<p><code>APT_HTTP_PROXY=http://localhost:3142 rake</code> でも良かったのですが、
rake コマンドは引数の <code>FOO=bar</code> を <code>ENV</code> に設定してくれるので、
<code>rake APT_HTTP_PROXY=http://localhost:3142</code> で渡して、
Rakefile の中では以下のように受け取って <code>lb config</code> に渡しました。</p>

<p>```ruby Rakefile
desc &ldquo;config RubyLive&rdquo;
task :config => [:clean] do
  sh &lsquo;lb config&rsquo;
  if ENV[&lsquo;APT_HTTP_PROXY&rsquo;]</p>

<pre><code>sh "lb config --apt-http-proxy #{ENV['APT_HTTP_PROXY']}"
</code></pre>

<p>  end
end
```</p>

<h2>live-build で apt-cacher-ng を使う</h2>

<p>既に出てきたように
<code>lb config</code> の <code>--apt-http-proxy</code> オプションや <code>--apt-ftp-proxy</code> オプションで指定すると
Live イメージ作成の時に proxy を使ってくれるようになります。
今回は apt-line に <code>http</code> しか使っていないので
<code>--apt-http-proxy</code> だけ指定しています。</p>

<p>もちろん、作成後の Live イメージには proxy 設定は残りません。</p>

<h2>感想</h2>

<p>live-build は cache ディレクトリにも、かなりキャッシュしてくれるのですが、
<code>apt-get update</code> などの proxy じゃないとキャッシュしにくいものもあるので、
どんな場合でもダウンロード量削減に役に立ちそうだと思いました。</p>
]]></content>
  </entry>
  
</feed>
