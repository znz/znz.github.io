<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2014-01-12T15:30:08+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RubyMotionのOSXアプリの起動エラー]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-28-rubymotion-error.html"/>
    <updated>2013-12-28T18:55:18+09:00</updated>
    <id>http://blog.n-z.jp/blog/rubymotion-error</id>
    <content type="html"><![CDATA[<p>最近 RubyMotion で作っている OSX アプリが
<code>LSOpenURLsWithRole() failed with error -10810</code>
などで起動しないことがあったので原因を調べてみました。</p>

<!--more-->


<h2>LSOpenURLsWithRole() failed with error -10810</h2>

<h3>よくある原因</h3>

<p><code>Hello.app/Contents/MacOS/Hello</code>
のような実行ファイルの実体に実行属性が外れているというのが
よくある原因のようで、
<a href="http://owncloud.org/">ownCloud</a>
経由で同期したアプリが実行できなかったときは
これが原因でした。</p>

<h3>別の原因</h3>

<p>実行属性も問題なくて悩んでいたときに
コンソール (Console.app) のログを見てみると</p>

<p><code>
2013/12/28 10:39:17.963 open[85406]: spawn_via_launchd() failed, errno=22 label=com.yourcompany.Hello.44032 path=.../Hello/build/MacOSX-10.9-Development/Hello.app/Contents/MacOS/Hello flags=0 : LaunchApplicationClient.cp #1168 LaunchApplicationViaLaunchDJobLabel() q=com.apple.main-thread
</code>
のようなログが出ていたので、
<code>LaunchApplicationViaLaunchDJobLabel</code>
で検索してみたところ、
<a href="http://portingteam.com/topic/9723-mavericks-problem-opening-fresh-wrapper/">Mavericks problem opening fresh wrapper</a>
という話が見つかって、
そこに書いてあった</p>

<p><code>
launchctl remove $(launchctl list | grep wineskin | awk '{ print $3 }')
</code></p>

<p>という手順を参考にして解決しました。</p>

<p><code>Hello</code> が2個残っていて、
<code>$()</code> だとダメだったので個別に <code>launchctl remove</code> しました。</p>

<p><code>
% launchctl list | grep Hello
-   2   com.yourcompany.Hello.44032
-   0   com.yourcompany.Hello.53008
%  launchctl remove $(launchctl list | awk '/Hello/{print $3}')
usage: launchctl remove &lt;job label&gt;
zsh: exit 1     launchctl remove $(launchctl list | awk '/Hello/{print $3}')
%  echo launchctl remove $(launchctl list | awk '/Hello/{print $3}')
launchctl remove com.yourcompany.Hello.44032 com.yourcompany.Hello.53008
%  launchctl remove com.yourcompany.Hello.44032
%  launchctl remove com.yourcompany.Hello.53008
%  open -a Hello
</code></p>

<h3>その他</h3>

<p>その他の対象方法も含めて
<a href="http://www.thexlab.com/faqs/error-10810.html">Error -10810 Openng Applictions or Relaunching Finder</a>
にいろいろ書いてあるようです。
(英語で長かったのでちゃんと読んでません。)</p>

<h2>MacBookPro6,2 で EXC_BAD_INSTRUCTION (SIGILL) になって起動しない</h2>

<p>未解決です。</p>

<p><a href="https://github.com/MohawkApps/Hacker-Bar/issues/36">EXC_BAD_INSTRUCTION crash in App Store version&hellip;</a>
に似た話があって、
RubyMotion のバグっぽいという話のようです。</p>

<p><code>motion create --template=osx HelloOSX</code>
で作成しただけのものでも
<a href="https://gist.github.com/znz/8158061#file-helloosx-report-txt">クラッシュ</a>
して起動しませんでした。</p>

<p>RubyMotion を入れている自分の MacBook Air の環境の問題かどうかを切り分けるために
<a href="http://shin1x1.github.io/vagrantx/">VagrantX</a>
も試してみましたが、
<a href="https://gist.github.com/znz/8158061#file-vagrantx-report-txt">同じくクラッシュ</a>
して起動しませんでした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 6 回 RubyMotion もくもく会 in Osaka に参加した]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-26-rubymotion-mokumoku-osaka.html"/>
    <updated>2013-12-26T23:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/rubymotion-mokumoku-osaka</id>
    <content type="html"><![CDATA[<p>第 1 回から第 5 回にも参加した RubyMotion もくもく会 in Osaka の
<a href="http://connpass.com/event/4211/">第 6 回 RubyMotion もくもく会 in Osaka</a>
に参加してきました。</p>

<p>次回の
<a href="http://connpass.com/event/4560/">第 7 回 RubyMotion もくもく会 in Osaka</a>
は 1/22(水) になりました。</p>

<!--more-->


<h2>話に出たもの</h2>

<p>話に出てきたサイトなどのメモです。</p>

<ul>
<li><a href="http://shin1x1.github.io/vagrantx/">http://shin1x1.github.io/vagrantx/</a>

<ul>
<li>URL が小文字に変わっていました。</li>
</ul>
</li>
<li><a href="https://www.cocoacontrols.com/">Cocoa Controls</a></li>
<li><a href="http://getpocket.com/">Pocket</a></li>
<li><a href="http://71squared.com/ja/particledesigner">Particle Designer</a></li>
<li>UIMotionEffect で視差効果が簡単に実装できる</li>
<li>All Cast という Android アプリで Apple TV に AirPlay できる</li>
</ul>


<h2>やっていたこと</h2>

<p>今回は前回作り始めていたデフォルトブラウザを乗っ取って、
Firefox とか Chrome とか Safari とかに起動し分けられる
OSX アプリの作成の続きをやっていました。</p>

<p>今回の最後ではスクリーンショットのようになりました。</p>

<p><img src="/images/2013-12-26-hello.png" title="&ldquo;screenshot&rdquo; &ldquo;作成途中のアプリのスクリーンショット&rdquo;" ></p>

<p>適当に作った Hello.app に動作確認用のメソッドを付け足していただけなので、
まだタイトルは Hello のままになっています。</p>

<h3>URL 受け取り問題</h3>

<p>LimeChat で URL をクリックしたときなどに受け取るのは
前回調べていた <code>LSSetDefaultHandlerForURLScheme</code> での
デフォルトブラウザ設定とあわせて、</p>

<p>```ruby</p>

<pre><code>NSAppleEventManager.sharedAppleEventManager.setEventHandler(
  self,
  andSelector: :'handleGetURLEvent:withReplyEvent:',
  forEventClass: KInternetEventClass,
  andEventID: KAEGetURL)
</code></pre>

<p>```</p>

<p>でイベントを受け取ると Hello.app 起動中は受け取れたのですが、
起動していない時の URL クリックのイベントを受け取れない問題は
結局解決できませんでした。</p>

<p><code>open -a Hello --args URL</code>
というなら
<code>NSProcessInfo.processInfo.arguments</code>
で受け取れるのですが、
LimeChat などでの URL クリックで起動された時や
<code>open -a Hello URL</code>
という起動方法だと受け取り方がわかりませんでした。</p>

<p>他のブラウザの起動も
<code>open -a 'Google Chrome' http://localhost:4000/ --args -incognito</code>
のように URL は args ではない方法で渡さないと開けませんでした。</p>

<h3><code>keyDirectObject</code> がない問題と前面に出てこない問題</h3>

<p>URL の受け取り部分は今のところ、以下のようにしています。</p>

<p>```ruby
  def handleGetURLEvent(event, withReplyEvent: replyEvent)</p>

<pre><code>keyDirectObject = '----'.unpack('L')[0]
urlStr = event.paramDescriptorForKeyword(keyDirectObject).stringValue
@text.stringValue = urlStr

Process.spawn("osascript", "-e", &lt;&lt;-SCRIPT)
</code></pre>

<p>tell Application &ldquo;#{NSBundle.mainBundle.infoDictionary[&lsquo;CFBundleName&rsquo;]}&rdquo;
  activate
end tell</p>

<pre><code>SCRIPT
</code></pre>

<p>  end
```</p>

<p>最初の問題として、
<code>keyDirectObject</code> が RubyMotion にはなさそうだったので、
値を調べて <code>unpack</code> で同等の値を生成するようにしました。
この部分は前回から今回までの間に調査して作成済みだったので、
詳しい調査方法は忘れてしまいましたが、
引数のオブジェクトを調べて見つけたような気がします。</p>

<p>前面に出てこない問題は
今回のもくもく会の間に対処しました。</p>

<p>前面に持ってくる方法がどういう API を呼べばよいのかわからず、
AppleScript を使った方法は情報があったので、
とりあえず <code>osascript</code> を呼び出してしまうことにしました。</p>

<p>最初は <code>spawn</code> ではなく <code>system</code> を使ってしまったら、
デッドロックしてしまって強制終了するしかなくなってしまったので、
<code>Process.spawn</code> を使いました。</p>

<h2>まとめ</h2>

<p>今回は作りたいものが決まっていて、しっかりもくもく出来ました。</p>

<p>起動時に URL が受け取れない問題は
自分が使うだけなら
URL を 2 回クリックするという方法で
回避できるのですが、なんとかしたいところです。</p>

<p><code>keyDirectObject</code> と <code>osascript</code> を使っているところは
他に方法がなければ
今のままでも実用上は困らないと感じました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DOCKER indexのTrusted Buildsで複数バージョンのrubyを試せるimageを作ってみた]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-19-docker-trusted-builds.html"/>
    <updated>2013-12-19T23:02:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/docker-trusted-builds</id>
    <content type="html"><![CDATA[<p><a href="https://index.docker.io/">DOCKER index</a>
には
<a href="http://blog.docker.io/2013/11/introducing-trusted-builds/">Trusted Builds</a>
という機能があり、
Docker index の方で
image の作成をしてくれます。</p>

<p>image の作成方法は GitHub に Dockerfile を公開して、
それを指定します。</p>

<p>今回はそれを使って複数バージョンの ruby を試せる image を作ってみました。</p>

<!--more-->


<h2>Dockerfile の動作確認</h2>

<p><code>docker build</code> への Dockerfile の指定方法は</p>

<pre><code>docker build DockerfileのあるディレクトリへのパスやURL
</code></pre>

<p>という方法と</p>

<pre><code>docker build - &lt; Dockerfile
</code></pre>

<p>のように <code>-</code> を指定して標準入力から渡す方法があります。</p>

<p>違いとしては
パスや URL の指定だとファイル名が Dockerfile 固定という制限があり、
<code>-</code> の方だと <code>ADD</code> が使えない (基準となるディレクトリがわからないため)
という制限があるようです。
(詳しく調べていないだけなので他にもあると思います。)</p>

<p>そこで、</p>

<pre><code>docker build -t local/rubys .
</code></pre>

<p>または</p>

<pre><code>docker build -t local/rubys - &lt; Dockerfile
</code></pre>

<p>のようにして動作確認します。</p>

<h2>DOCKER index のアカウント登録</h2>

<p>英小文字か数字で4文字から30文字という制限があったので、
<code>znzj</code> というアカウントにしました。</p>

<p>メールアドレスとパスワードを設定して、
メールの確認が済んだらアカウントの作成は完了です。</p>

<p>最近はサービスごとにメールアドレスを分けていて、
アイコンが gravatar のデフォルトになってしまっていたので、
User Settings から Gravatar email も設定しました。</p>

<p>ここはメールアドレスの確認がなかったので、
他人のアイコンでも使えてしまうように見えたのですが、
良いのでしょうか。
ちょっと考えてみましたが、
画像をコピーして使えば同じようなものなので、
気にするほどのことではなさそうに思いました。</p>

<h2>GitHub のアカウントとの連携</h2>

<p>hook の登録のため、ということで多少の書き込み権限も要求されるので、
許可したくない場合は Trusted builds は使えません。</p>

<h2>Trusted Builds の追加</h2>

<p>ログイン中に
<a href="https://index.docker.io/builds/">Trusted Builds</a>
のページの <code>+Add New</code> から、
GitHub レポジトリを選択します。
ここでは <a href="https://github.com/znz/docker-rubys">https://github.com/znz/docker-rubys</a> を選択しました。</p>

<ol>
<li>Default Branch は <code>master</code> のまま</li>
<li>Repo name も <code>znzj/docker-rubys</code> のまま (<code>/</code> の右の部分は英小文字か数字か <code>-</code> か <code>.</code> で 3 文字から 30 文字)</li>
<li>Docker Tag Name も <code>latest</code> のまま</li>
<li>Dockerfile Location は <code>/</code> から <code>rubys/</code> に変更</li>
<li>Active にはチェックをいれたまま</li>
</ol>


<p>という状態で作成しました。</p>

<p><code>Dockerfile</code> の push とどっちが先が良いのかわからなかったので、
<code>Dockerfile</code> なしで追加してしまったら、
初回は <code>Dockerfile</code> が見つからないという理由で失敗してしまったので、
先に <code>Dockerfile</code> を push してから追加するもののようです。</p>

<h2>イメージの使用</h2>

<p>しばらくまつと Trusted Builds のページで
Status が Pending から Building に変わって、
最終的に Done になってビルドできて使えるようになるので、</p>

<pre><code>docker pull znzj/docker-rubys
</code></pre>

<p>でダウンロードします。</p>

<p>ダウンロードが完了したら、</p>

<pre><code>docker run -i -t znzj/docker-rubys
</code></pre>

<p>で <code>/bin/bash -l</code> を起動します。
(<code>CMD</code> で指定されています。)</p>

<p>bash で</p>

<pre><code>rbenv versions
</code></pre>

<p>で入っている ruby のバージョンを確認したり、</p>

<pre><code>rbenv each ruby -v
</code></pre>

<p>や</p>

<pre><code>rbenv each -v gem list
</code></pre>

<p>などのように
<a href="https://github.com/chriseppstein/rbenv-each">rbenv each</a>
を使って、
それぞれのバージョンの ruby の環境でコマンドを実行できるようにしています。</p>

<p>ホスト側とのファイルのやり取りはどうするのが良いのか
まだ調べていないので、
とりあえず vim でファイルを作成するか、
wget でダウンロードすることを想定しています。</p>

<h2>abuse?</h2>

<p><code>GitHub: Add Trusted Build</code>
のところに
<code>Anyone who abuses the build system, will have their accounts disabled. If you are unsure what might be considered abuse, please ask before you build.</code>
という注意書きがあって、
ビルドするぐらいなら大丈夫かと思っていたのですが、
他の Trusted Builds をみるとインストールしたり
ファイルを追加したりしているだけのものが
多いので心配になってしまいました。
さらに探してみると
<a href="https://index.docker.io/u/sameersbn/gitlab/">https://index.docker.io/u/sameersbn/gitlab/</a>
で ruby を make しているものもあったので、
ビルドはダメということもなさそうでした。</p>

<p>しかし、頻繁にビルドして負荷をかけるのもよくなさそうなので、
trunk の nightly build などをしようと思ったら、
ローカルで作成して <code>docker push</code> する方がよさそうに感じました。</p>

<h2>aufs の制限</h2>

<p><a href="https://github.com/dotcloud/docker/issues/332">https://github.com/dotcloud/docker/issues/332</a>
によると aufs は重ねられる数に限界 (40ぐらい?) があるようなので、
<code>RUN</code> コマンドは出来るだけまとめて減らした方が良いのかもしれません。</p>

<p><a href="https://index.docker.io/u/truongsinh/nodejs/">https://index.docker.io/u/truongsinh/nodejs/</a>
のように <code>&amp;&amp;</code> でつなげて 1 個の <code>RUN</code> にまとめている例もありました。</p>

<p>aufs 以外が主流になるかもしれないので、
この辺りは Dockerfile の読みやすさや
<code>docker history</code> でわかれていた方が良いのかなど、
利点や欠点を考えつつ、
ベストプラクティスが決まっていくまで
試行錯誤するのが良さそうです。</p>

<h2>まとめ</h2>

<p>DOCKER index には Trusted Builds という向こう側で
<code>docker build</code> してくれる仕組みがあるので、
<code>docker push</code> とうまく使い分けて
公開可能なイメージはどんどん公開すると良いのではないでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyMotionとRubyのバージョン]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-15-rubymotion-ruby-version.html"/>
    <updated>2013-12-15T14:49:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/rubymotion-ruby-version</id>
    <content type="html"><![CDATA[<p>今のところ RubyMotion は毎月のもくもく会以外ではほとんど触れていないので、
RubyMotion と Ruby のバージョンの関係と言う小ネタです。</p>

<p>この投稿は
<a href="http://qiita.com/advent-calendar/2013/rubymotion">RubyMotion Advent Calendar 2013</a>
の12日目の記事です。</p>

<!--more-->


<h2>RUBY_DESCRIPTION 確認</h2>

<p>まず <code>Rakefile</code> の先頭で <code>RUBY_DESCRIPTION</code> を入れて、
普通の <code>ruby</code> コマンドのバージョンを表示して、
次に開発環境のプロンプトでも確認してみました。</p>

<p>```console
% head -n2 Rakefile</p>

<h1>&ndash;<em>&ndash; coding: utf-8 &ndash;</em>&ndash;</h1>

<p>p RUBY_DESCRIPTION
% rake
&ldquo;ruby 2.0.0p353 (2013-11-22 revision 43784) [x86_64-darwin12.5.0]&rdquo;</p>

<pre><code> Build ./build/MacOSX-10.8-Development
</code></pre>

<p>   Compile ./app/app_delegate.rb
   Compile ./app/menu.rb</p>

<pre><code>Create ./build/MacOSX-10.8-Development/Hello.app/Contents
Create ./build/MacOSX-10.8-Development/Hello.app/Contents/MacOS
  Link ./build/MacOSX-10.8-Development/Hello.app/Contents/MacOS/Hello
Create ./build/MacOSX-10.8-Development/Hello.app/Contents/PkgInfo
Create ./build/MacOSX-10.8-Development/Hello.app/Contents/Info.plist
  Copy ./resources/Credits.rtf
Create ./build/MacOSX-10.8-Development/Hello.dSYM
   Run ./build/MacOSX-10.8-Development/Hello.app/Contents/MacOS/Hello
</code></pre>

<p>(main)> RUBY_DESCRIPTION
=> &ldquo;RubyMotion (ruby 1.9.2) [universal-darwin13.0, x86_64]&rdquo;
(main)> exit
```</p>

<p>外側は 2.0.0 なのに RubyMotion の方は 1.9.2 でした。</p>

<h2>まとめ</h2>

<p>調べたきっかけはデバッグ用に <code>File.write</code>
(<a href="http://docs.ruby-lang.org/ja/2.0.0/class/IO.html#S_WRITE">IO.write</a>)
が使えなかったからでした。
それは結局普通に <code>File.open</code> して書き込むことにしましたが、
開発環境側の Ruby のバージョンを変えても生成されるアプリ側の
Ruby のバージョンには影響しないという話でした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[upstart-socket-bridgeとrubyを組み合わせる]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-14-upstart-socket-bridge-with-ruby.html"/>
    <updated>2013-12-14T00:45:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/upstart-socket-bridge-with-ruby</id>
    <content type="html"><![CDATA[<p><a href="http://gihyo.jp/admin/clip/01/ubuntu-topics/201312/06">Ubuntu Weekly Topics 2013年12月6日号</a>
の「その他のニュース」で紹介されていた
「upstart-socket-bridgeをxinetdライクなソケット待ち受け管理機構として扱う
<a href="http://cheesehead-techblog.blogspot.jp/2013/12/upstart-socket-bridge.html">アプリケーションの作り方</a>
。」
が python3 で書かれていて、
同じことが ruby で実装できるのか気になったので、
IRC でちょっと助言を受けつつ移植してみました。</p>

<!--more-->


<h2>試した環境</h2>

<ul>
<li>amd64 の Ubuntu 13.10 (saucy)</li>
<li><code>/usr/bin/ruby</code> は <code>ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]</code></li>
</ul>


<h2>ruby で試す</h2>

<p>必須なのはソケット周りだけですが、
デバッグ用のメッセージをファイルに残すようにして
動作確認していたので、
その部分も残しています。</p>

<p>```ruby /tmp/test-service.rb
 #!/usr/bin/ruby
 require &lsquo;socket&rsquo;
 open(&ldquo;/tmp/test.log&rdquo;, &ldquo;w&rdquo;) do |f|
   ENV.each do |key, value|</p>

<pre><code> f.puts "#{key}=#{value}"
</code></pre>

<p>   end
   begin</p>

<pre><code> serv_socket = Socket.for_fd(ENV["UPSTART_FDS"].to_i)
 client_socket, client_addrinfo = serv_socket.accept
 message = client_socket.recv(1024)
 f.puts message
 client_socket.send("I got your message: #{message}", 0)
 client_socket.close
</code></pre>

<p>   rescue Exception => e</p>

<pre><code> f.puts e.inspect
 f.puts e.backtrace
</code></pre>

<p>   end
   f.puts &ldquo;finished&rdquo;
 end
```</p>

<p>バグとしては
<code>for_fd</code> の引数の <code>to_i</code> を忘れていたり、
<code>send</code> の引数が足りなかったりしました。</p>

<p><code>text /etc/init/socket-test.conf
 description "upstart-socket-bridge test"
 start on socket PROTO=inet PORT=34567 ADDR=127.0.0.1  # 34567 番ポートで待ち受け
 setuid exampleuser                                    # root ではなく exampleuser で動作
 exec /usr/bin/ruby /tmp/test-service.rb               # サービス起動
</code></p>

<p><code>nc</code> コマンドで接続して動作確認します。</p>

<p><code>console
 $ nc localhost 34567
 Hello Ruby
 I got your message: Hello Ruby
</code></p>

<p>最後にテストで作成したファイルを削除しておきます。</p>

<p><code>console
 $ sudo rm /etc/init/socket-test.conf  # ブリッジとの接続解除
 $ rm /tmp/test-service.rb             # テストサービス削除
 $ rm /tmp/test.log                    # ログファイル削除
</code></p>

<h2>まとめ</h2>

<p>python3 の <code>socket.fromfd</code> に相当するのは
ruby だと <code>BasicSocket.for_fd</code> で、
<code>BasicSocket</code> クラスには <code>accept</code> がないので、
<code>BasicSocket</code> クラスを継承している <code>Socket</code> クラスの
<code>Socket#for_fd</code> を使いました。</p>

<p><code>inetd</code> や <code>xinetd</code> だと標準入出力にソケットをつないでくれて、
サービスは簡単にかけるのに、
<code>upstart</code> だと <code>accept</code> して <code>accept</code> から返ってきたソケットを
<code>close</code> するまでがサービス側でやらないといけないようになっていて、
ちょっと面倒に感じました。</p>

<p>たまたま目についたプログラムを移植してみただけで、
深追いはしていないのですが、
どういう利点があるものなのか、
調べてみるのも良いのかもしれません。</p>
]]></content>
  </entry>
  
</feed>
