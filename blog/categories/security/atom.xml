<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: security | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2017-01-08T18:29:16+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sshでed25519鍵を使うようにした]]></title>
    <link href="http://blog.n-z.jp/blog/2016-12-04-ssh-ed25519.html"/>
    <updated>2016-12-04T14:25:40+09:00</updated>
    <id>http://blog.n-z.jp/blog/ssh-ed25519</id>
    <content type="html"><![CDATA[<p>ssh で使っている鍵が RSA 2048 ビットでちょっと古くなってきているということもあり、
OpenSSH 6.5 で追加された ed25519 鍵に更新することにしました。</p>

<!--more-->


<h2>鍵の種類</h2>

<p><a href="http://jnst.hateblo.jp/entry/2014/12/15/200542" title="GitHubでEd25519鍵をつかう">GitHubでEd25519鍵をつかう</a>
の説明が詳しいですが、他のサイトでも調べた情報によると</p>

<ul>
<li>RSA の 2048 ビットが今の <code>ssh-keygen</code> でのデフォルトなので主流</li>
<li>RSA や ECDSA は <code>ssh-keygen</code> に <code>-b</code> でビット数が指定できる</li>
<li>ECDSA の 521 ビットは 512 の間違いではない</li>
<li>ed25519はビット数が指定出来ない</li>
<li>OpenSSH のssh-keygenは1024bitのDSA鍵しか作れない (<a href="http://d.hatena.ne.jp/hnw/20140705" title="GitHubユーザーのSSH鍵6万個を調べてみた">GitHubユーザーのSSH鍵6万個を調べてみた</a>)</li>
<li>DSA 鍵は弱いので使うべきではない</li>
<li>ed25519はECDSAより署名生成/検証のパフォーマンスが良い</li>
</ul>


<p>などの情報がありました。</p>

<p>ビット数で悩まなくて良いのと、パフォーマンスが良いという情報があったので、
ed25519 を使うことにしました。</p>

<h2>主な環境</h2>

<p>OpenSSH のバージョンは <code>ssh -V</code> で調べました。</p>

<ul>
<li>OS X El Captitan 10.11.6 の OpenSSH_6.9p1, LibreSSL 2.1.8</li>
<li>Ubuntu 14.04.5 LTS (trusty) の OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.8, OpenSSL 1.0.1f 6 Jan 2014</li>
<li>Debian GNU/Linux 8.6 (jessie) の OpenSSH_6.7p1 Debian-5+deb8u3, OpenSSL 1.0.1t  3 May 2016</li>
</ul>


<h2>バージョン情報</h2>

<p>Debian は <a href="https://packages.debian.org/openssh-server">https://packages.debian.org/openssh-server</a> によると wheezy (oldstable) は 1:6.0p1-4+deb7u6 で対応してなさそう (wheezy-backports が 1:6.6p1-4~bpo70+1 なので backports を使えば対応できそう) で、
jessie (stable) は 1:6.7p1-5+deb8u3 なので、今の安定版以降なら問題なく ed25519 が使えそうです。</p>

<p>Ubuntu は <a href="http://packages.ubuntu.com/openssh-server">http://packages.ubuntu.com/openssh-server</a> によると precise (12.04LTS) が 1:5.9p1-5ubuntu1.10 で対応してなさそうでしたが、
trusty (14.04LTS) が 1:6.6p1-2ubuntu2.8 で、
現在主流のバージョンでは問題なく使えそうでした。</p>

<h2>鍵生成</h2>

<p>vagrant 環境で鍵を生成して比較してみたところ、
ed25519 は公開鍵が RSA と比べてかなり短いことがわかりました。
ついでに比較してみたところ、 ECDSA よりも短いということがわかりました。</p>

<pre><code>%  ssh-keygen -t ed25519
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/vagrant/.ssh/id_ed25519):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/vagrant/.ssh/id_ed25519.
Your public key has been saved in /home/vagrant/.ssh/id_ed25519.pub.
The key fingerprint is:
SHA256:tlGs9kP67mLZzd9lh1/UJY2R/vZc1Q1GA9gyADsRGlw vagrant@yakkety64
The key's randomart image is:
+--[ED25519 256]--+
|   ...Eo.. o.o+. |
|    .o o .+ . += |
|    . o   oo oo.=|
|       . o    ..*|
|        S .    .+|
|       o *     o+|
|        oooo  .oB|
|        +...o  +*|
|       . ++  .. o|
+----[SHA256]-----+
%  cat ~/.ssh/id_ed25519.pub
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGvN6KKrqsvbFOfLclK/fYIDye6Lms7NhOn0yYNkjMza vagrant@yakkety64
%  ssh-keygen -t ecdsa
Generating public/private ecdsa key pair.
Enter file in which to save the key (/home/vagrant/.ssh/id_ecdsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/vagrant/.ssh/id_ecdsa.
Your public key has been saved in /home/vagrant/.ssh/id_ecdsa.pub.
The key fingerprint is:
SHA256:DebC1pOk6EEL5MVGP0PIziMdAmzgmqAYJl/C14DuSOM vagrant@yakkety64
The key's randomart image is:
+---[ECDSA 256]---+
|=..=+..          |
|.*o.*=           |
|=+=*+.= +        |
|B*o*=+ O +       |
|Boo.+.= S .      |
|.E.. o . .       |
|    .            |
|                 |
|                 |
+----[SHA256]-----+
%  cat ~/.ssh/id_ecdsa.pub
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCQeG28rZh/SX9MBfKsnltv+hpr41CAT4CZZ9YsmsjVRdb3iKsYq4K4SNwfiVGNaIjKAcuDnaJbk50zOoa8V/Tc= vagrant@yakkety64
%  ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/vagrant/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/vagrant/.ssh/id_rsa.
Your public key has been saved in /home/vagrant/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:sR7WZK2npMgv8lRZrhofejURfuEs04VJv0quu3xtLiw vagrant@yakkety64
The key's randomart image is:
+---[RSA 2048]----+
|           ..o   |
|          ..+..  |
|        ..+=.o.  |
|         X=.=  . |
|        S ==o .  |
|     . = =o= .   |
|      = =..oo.   |
|    ...*.oE.+ o  |
|     o+oo == +.  |
+----[SHA256]-----+
%  cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCnSyvz7oShBRgD8q91eG4WtdJ83cPJfQAtSKEiE8ELHhqRulL6liPz/jqqpMjQpp/3e3QS8OoxGnuXGgHdkly4cd2UdnWxqbz4oN6ig64rYK/ZshQp5FyKb5L3Ksr+3mkhzxPHQVbSZWa8YoaCEzbteVbdFTXUMO/HFPFTL9s2HHyJoDlzUT0XdyovN6WQ2SEbx6pLudsvhZiaiqrPEHLl4ltq33tGcIMFjeu8XvW3d8jTmuAw0KrL7U3bD20n0xsKj9XBigew9K0PjJQ6QKyNUpXXB94jWv+hpkatHlw0NJm/XUQiHDtWaMCTRB8KDSrFarRbYL5ErfHuCePmYerR vagrant@yakkety64
</code></pre>

<h2>サービスに登録</h2>

<p>二要素認証の時はちょっと楽しい面もありましたが、
ssh の鍵の変更は面倒なだけでした。</p>

<p>GitHub, BitBucket, Heroku など、試したところはすべて ed25519 の公開鍵に対応していました。</p>

<h2>IdentityFile 更新</h2>

<p><code>~/.ssh/config</code> で余計な鍵を試さないように</p>

<pre><code>    IdentitiesOnly yes
    IdentityFile ~/.ssh/id_rsa
</code></pre>

<p>のような設定を入れている場合は</p>

<pre><code>    IdentitiesOnly yes
    IdentityFile ~/.ssh/id_ed25519
</code></pre>

<p>に変更する必要がありました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2要素認証を設定し直した]]></title>
    <link href="http://blog.n-z.jp/blog/2016-09-25-update-2fa.html"/>
    <updated>2016-09-25T22:59:39+09:00</updated>
    <id>http://blog.n-z.jp/blog/update-2fa</id>
    <content type="html"><![CDATA[<p>Google Authenticator を入れているデバイスを買い換えたので、2要素認証 (2FA: two-factor authentication) (サービスによっては MFA: Multi-factor authentication) を設定し直してみました。</p>

<!--more-->


<h2>2要素認証一般の話</h2>

<ul>
<li>今回使用しているのは TOTP という RFC にもなっている規格なので Google に依存しているわけではありません</li>
<li><a href="https://support.apple.com/ja-jp/HT204915" title="Apple ID の 2 ファクタ認証">Apple ID の 2 ファクタ認証</a> は TOTP ではなさそうです</li>
<li><a href="https://itunes.apple.com/jp/app/google-authenticator/id388497605?mt=8" title="Google Authenticator">Google Authenticator</a> (iOS) や <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;amp;hl=ja" title="Google 認証システム">Google 認証システム</a> (Android) がよく使われている気がします</li>
<li>Google 依存を避けたいのなら <a href="http://www.iij.ad.jp/smartkey/" title="IIJ SmartKey">IIJ SmartKey</a> や Microsoft Authenticator というのもあるようです</li>
<li>TOTP は QR コードかテキスト入力した秘密情報と時刻を元に認証用の数字を生成しているだけなので、複数の端末・アプリに同時に設定することも可能です (当然ですが、紛失した時のリスクは増加します)</li>
</ul>


<h2>github.com</h2>

<ul>
<li>ログインしておく</li>
<li>右上の自分のアイコンをクリックして Settings をクリック</li>
<li>Security をクリック</li>
<li>Two-factor authentication の Edit をクリック</li>
<li>パスワードの確認が入る</li>
<li>Reconfigure two-factor authentication をクリック</li>
<li>リカバリーコードと fallback SMS 設定には影響がないという説明を確認</li>
<li><a href="https://help.github.com/articles/configuring-two-factor-authentication-via-a-totp-mobile-app/">https://help.github.com/articles/configuring-two-factor-authentication-via-a-totp-mobile-app/</a> に対応アプリの説明あり</li>
<li>Set up using an app をクリック</li>
<li>QR コードをアプリでスキャン</li>
<li>アプリに表示されている6桁の数字を入力して Enable two-factor authentication をクリック</li>
</ul>


<h2>Google アカウント</h2>

<ul>
<li>ログインしておく</li>
<li><a href="https://myaccount.google.com/">https://myaccount.google.com/</a> から「Google へのログイン」をクリック</li>
<li>「2 段階認証プロセス」をクリック</li>
<li>パスワードを再入力</li>
<li>2 段階認証の確認コードを入力</li>
<li>「2 つ目の手順」の「認証システム アプリ （デフォルト）」のペンのアイコンをクリック</li>
<li>「登録された認証システム アプリ」ポップアップが出てきたので「変更」をクリック</li>
<li>「お使いのスマートフォンの種類」で「Android」が選択されていたのでそのまま「次へ」をクリック (iPhone を選ぶとたぶん説明が違う)</li>
<li>QR コードをアプリでスキャン</li>
<li>「次へ」をクリック</li>
<li>アプリに表示されている6桁の数字を入力して「確認」をクリック</li>
<li>「完了」をクリック</li>
</ul>


<h2>Evernote</h2>

<ul>
<li>ログインする</li>
<li>左下のアイコンから「設定」を開く</li>
<li>「セキュリティ概要」を開く</li>
<li>「2 段階認証が有効です」になっているので「設定を管理」をクリック</li>
<li>再設定はなさそうなので「2 段階認証を無効化」で一度無効化</li>
<li>「2 段階認証を無効化しますか？」が出てきたので「確認」をクリック</li>
<li>「2 段階認証が有効化されていません」になったので「有効化」をクリック</li>
<li>説明が出てくるので「続ける」をクリック</li>
<li>重要事項が出てくるのでさらに「続ける」をクリック</li>
<li>メールアドレスを確認が出てくるので「確認用Eメールを送信する」をクリック</li>
<li>メールを確認して確認コードを入力して「続ける」をクリック</li>
<li>「携帯電話番号を入力」で「日本 (+81)」のまま「90-xxxx-yyyy」のように入力して「続ける」をクリック</li>
<li>SMS で確認コードが届くので確認コードを入力して「続ける」をクリック</li>
<li>「（任意）バックアップ用電話番号を設定」が出てくるので左下の「スキップ」をクリック</li>
<li>「Google 認証システムを入手する」の説明が出てくるので「iOS で続行」をクリック (一番上にあったので)</li>
<li>QR コードをアプリでスキャン</li>
<li>アプリに表示されている6桁の数字を入力して「続ける」をクリック</li>
<li>「バックアップコード」が表示されるのでコピーするなり印刷するなりして安全な場所に保存 (個人的には gpg で暗号化したファイルに保存している)</li>
<li>「続ける」をクリック</li>
<li>「バックアップコードを入力」でバックアップコードのひとつを入力して「セットアップを完了」(ここで入力しても無効にはならない)</li>
<li>「2 段階認証のセットアップが完了しました」の説明が出てくるので「完了」をクリック</li>
<li>「2 段階認証が有効です」になっているので、必要なら「設定を管理」からアプリケーション用パスワードを再設定していく必要がありそう (使っていなかったので不明)</li>
</ul>


<h2>live.jp</h2>

<ul>
<li>ログインする</li>
<li>右上のアカウント画像から「アカウントの表示」をクリック</li>
<li>上のところから「セキュリティとプライバシー」をクリック</li>
<li>「アカウント セキュリティ」の「その他のセキュリティ設定」をクリック</li>
<li>「認証アプリ」から「本人確認アプリをセットアップ」をクリック</li>
<li>「認証アプリの設定」に入るので「アプリをインストールするモバイル デバイス」から「iPhone、iPad、または iPod touch」を選択して「次へ」をクリック</li>
<li>Microsoft Authenticator で「個人のアカウント」を追加</li>
<li>同様に Android の設定の場合</li>
<li>「認証アプリの設定」に入るので「アプリをインストールするモバイル デバイス」から「Android」を選択して「次へ」をクリック</li>
<li>Microsoft Authenticator で「個人のアカウント」を追加</li>
<li>同様に TOTP アプリの場合</li>
<li>「認証アプリの設定」で「その他」を選択して「次へ」をクリック</li>
<li>「この設定を行うと、以前に認証アプリを使って生成し、設定したコードがすべて無効になります。続行してもよろしいですか?」という確認が出てくるので「次へ」をクリック</li>
<li>QR コードをアプリでスキャン</li>
<li>「アプリによって生成されたコード」にアプリに表示されている6桁の数字を入力して「次へ」をクリック</li>
</ul>


<p>ログイン時に通知で許可するか拒否するか出てくるようになりました。
「その他」で TOTP の設定をするとそちらが優先されるようになりましたが、どちらが優先されるかは最後にどちらを使ったかで決まるようです。</p>

<p>TOTP から Microsoft Authenticator への通知への切り替えは「Microsoft アカウント アプリに本人確認要求を送ります。」でできて、通知から TOTP への切り替えは「問題が発生した場合」をクリックすると出てくる「セキュリティ コードを入力してください」でできるようです。</p>

<p>Microsoft Authenticator の方は通知で認証できたり、表示されているのが 8 桁だったりして、
Microsoft のアカウントの認証に対しては TOTP で一般的な 6 桁ではないので、
他の方式なのかもしれないと思って、ちょっと調べてみたのですが、
よくわかりませんでした。</p>

<h2>Dropbox</h2>

<ul>
<li>ログインする</li>
<li>右上のアカウントのところから「設定」をクリック</li>
<li>「セキュリティ」タブをクリック</li>
<li>「2 段階認証」の「主要」の「認証アプリ」の「編集」をクリック</li>
<li>パスワードを入力して「次へ」をクリック</li>
<li>「モバイル アプリを使用」を選んだまま「次へ」をクリック</li>
<li>QR コードをアプリでスキャン</li>
<li>「次へ」をクリック</li>
<li>対応アプリについては <a href="https://www.dropbox.com/help/363#2fa-apps">https://www.dropbox.com/help/363#2fa-apps</a> に説明あり</li>
<li>アプリに表示されている6桁の数字を入力して「確認」をクリック</li>
<li>「予備の携帯番号 （オプション）」に「日本 (+81)」と「90xxxxyyyy」のように入力されていたのでそのまま「次へ」をクリック</li>
</ul>


<p>セキュリティの画面に戻って設定完了しました。</p>

<h2>amazon.com</h2>

<p>root-account-mfa-device とだけ出ていて、何のものなのかわかりにくかったのですが、
Amazon Product Advertising API で使っている amazon.com のものでした。</p>

<p>Amazon Product Advertising API で使っているだけなので、AWS の無料期間を始めないように注意しながら探しました。</p>

<ul>
<li><a href="https://console.aws.amazon.com/iam/home?#security_credential">https://console.aws.amazon.com/iam/home?#security_credential</a> の「Multi-Factor Authentication（MFA）」</li>
<li>「再同期」は意味がなかったので「無効化」してから「MFA の有効化」をしなおしました</li>
<li>「仮想 MFA デバイス」を選んで「次のステップ」</li>
<li>対応アプリの説明は <a href="https://aws.amazon.com/jp/iam/details/mfa/">https://aws.amazon.com/jp/iam/details/mfa/</a></li>
<li>説明を読んで「次のステップ」</li>
<li>QR コードをアプリでスキャン</li>
<li>アプリに表示されている6桁の数字を「認証コード1」に入力して、しばらく待って表示が変わったら「認証コード2」に入力して「仮想 MFA の有効化」</li>
<li>「MFA デバイスは正常に関連付けられました。」と出るので「完了」</li>
</ul>


<h2>さくらの会員メニュー</h2>

<ul>
<li>ログインする</li>
<li>説明ページ: <a href="https://help.sakura.ad.jp/hc/ja/articles/206057222">https://help.sakura.ad.jp/hc/ja/articles/206057222</a></li>
<li>「2段階認証の設定」をクリックする (わかりにくいがタイトルっぽいところがリンクにもなっている)</li>
<li>「※QRコードを発行・表示できるのは一度のみです。紛失した場合、一度設定を「無効」にする必要があります。」とあるので一度「無効」にして「設定変更」をクリック</li>
<li>確認が出るので「無効化」をクリック</li>
<li>再び「有効」にして「設定変更」をクリック</li>
<li>「2段階認証設定」をクリック</li>
<li>「QRコードを発行する」をクリック</li>
<li>QR コードをアプリでスキャン</li>
<li>「認証コード入力画面へ」をクリック</li>
<li>認証コードを入力して「ログイン(認証)」をクリック</li>
<li>「QRコード発行済み」になっていれば2FAは設定完了</li>
<li>さらに「バックアップコードを作成」をクリック</li>
<li>「現在のバックアップコードを表示する」をクリック</li>
<li>バックアップコードを安全な場所に保管</li>
</ul>


<h2>libpam-google-authenticator</h2>

<ul>
<li>ログインする</li>
<li><code>google-authenticator</code> コマンドを実行して <code>.google_authenticator</code> ファイルを上書きする</li>
<li>途中で表示される QR コードをアプリでスキャン</li>
<li>emergency scratch codes (バックアップコード) も再発行されるので安全な場所に控えておく</li>
</ul>


<h2>まとめ</h2>

<p>再設定機能があるサービスは再設定がしやすくて良かったのですが、そういう機能がないところは一時的に無効にしてセキュリティレベルが下がってしまうのが気になりました。</p>

<p>どちらが良いのかはわかりませんが、再設定によってバックアップコードが影響を受けないところと再発行のところがあるのも気になりました。</p>

<p>二要素認証 (多要素認証) はセキュリティにとって重要なものなので、デバイスの買い替えなどの適当なタイミングで再設定できたのは良い機会だったのかと思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenSSL/GnuTLS での CSR の作り方]]></title>
    <link href="http://blog.n-z.jp/blog/2014-04-16-new-csr.html"/>
    <updated>2014-04-16T10:09:24+09:00</updated>
    <id>http://blog.n-z.jp/blog/new-csr</id>
    <content type="html"><![CDATA[<p>サーバー証明書を発行してもらう時などに毎回調べつつ CSR を作成しているので、
GnuTLS と OpenSSL を使った方法をまとめてみました。</p>

<!--more-->


<h2>パッケージインストール</h2>

<p>OpenSSL の方は入っていることが多いと思いますが、入っていなければ <code>openssl</code> パッケージをいれておきます。</p>

<p>GnuTLS の方は Debian や Ubuntu の場合は <code>gnutls-bin</code> パッケージに <code>gnutls-cli</code> コマンドなどが入っています。
RHEL などでは <code>gnutls-utils</code> というパッケージに入っているらしいです。</p>

<h2>certtool コマンド</h2>

<p><code>certtool</code> コマンドは Mac OS X にもありますが、 GnuTLS のものとは別物です。
ここで説明しているのは GnuTLS の <code>certtool</code> コマンドです。</p>

<h2>秘密鍵作成</h2>

<p>秘密鍵の生成はランダムな情報を元に生成するので、ビット数やエントロピーの量に応じて時間がかかります。
デスクトップマシンなどではマウスを動かすなどの方法でエントロピーを増やすことが出来るかもしれません。</p>

<p>作成されるファイルのパーミッションなどを考えると暗号化しないなら GnuTLS の
<code>certtool --generate-privkey --bits 4096 --outfile example.key</code>
の方法がオススメです。</p>

<h3>GnuTLS</h3>

<p>GnuTLS の <code>certtool</code> コマンドでは <code>--generate-privkey</code> で秘密鍵を作成できます。
<code>--bits</code> で鍵のビット数を指定しないと squeeze だと 2048 ビット、 precise や wheezy だと 2432 ビットになりました。
ファイルのパーミッションも <code>-rw-------</code> (600) で作成されるので、そのまま使えます。</p>

<pre><code class="console gnutls">$ certtool --generate-privkey --outfile example-tls.key
Generating a 2432 bit RSA private key...
</code></pre>

<pre><code class="console gnutls">$ certtool --generate-privkey --bits 4096 --outfile example-tls.key
Generating a 4096 bit RSA private key...
</code></pre>

<h3>OpenSSL</h3>

<p>OpenSSL では <code>genrsa</code> サブコマンドで生成します。
OpenSSL 1.0.0 では <code>genpkey</code> サブコマンドになっているようですが、
<code>genrsa</code> もまだ使えるので、以下は <code>genrsa</code> だけ書いています。</p>

<p>ビット数を指定しないと squeeze だと 1024 ビット、 precise や wheezy だと 512 ビットになりました。
また、そのままだとパーミッションが <code>-rw-rw-r--</code> (664) で生成されるので、あらかじめパーミッションを設定したファイルを用意しておいて上書きさせるか、すぐに <code>chmod</code> で変更しておいた方が良さそうです。</p>

<pre><code class="console openssl">$ touch example-ssl.key
$ chmod 600 example-ssl.key
$ openssl genrsa -out example-ssl.key
Generating RSA private key, 512 bit long modulus
....++++++++++++
.........................++++++++++++
e is 65537 (0x10001)
</code></pre>

<pre><code class="console openssl">$ touch example-ssl.key
$ chmod 600 example-ssl.key
$ openssl genrsa -out example-ssl.key 4096
Generating RSA private key, 4096 bit long modulus
......................................................++
...........++
e is 65537 (0x10001)
</code></pre>

<p>ネット上見つかる情報では <code>-des3</code> などで生成したファイルを一度暗号化して、
サーバーの起動時に不要になるようにすぐに外すような例もあるようですが、
そんなことをするぐらいなら最初から暗号化せずに生成すれば良いと思います。</p>

<p>暗号化した状態のファイルを別途バックアップするなどの目的があるのなら、
意味があると思いますが、
暗号化した状態のファイルを残さないのなら単なる無駄だと思います。</p>

<h2>秘密鍵の内容確認</h2>

<p>秘密鍵の内容を確認することはあまりないと思いますが、
<code>openssl rsa -in example.key -text -noout</code>
の方法がオススメです。</p>

<h3>OpenSSL</h3>

<p>OpenSSL で秘密鍵の内容を確認するには <code>rsa</code> サブコマンドを使います。
<code>-text</code> で内容全体の表示で <code>-noout</code> は <code>-----BEGIN RSA PRIVATE KEY-----</code> から <code>-----END RSA PRIVATE KEY-----</code> を表示しないという意味です。
秘密鍵本体の前にテキストの説明がついたものも元の秘密鍵と同様に扱えるようなので、
デフォルトでは元の内容も出力するようになっているのだと思います。</p>

<pre><code class="console openssl">$ openssl rsa -in example-ssl.key -text -noout
Private-Key: (4096 bit)
modulus:
    00:cb:35:ec:f6:00:5a:75:d7:55:14:f8:55:91:1a:
    (略)
publicExponent: 65537 (0x10001)
privateExponent:
    4d:86:de:47:a0:2c:e2:e6:6b:2c:5b:ed:f1:35:10:
    (略)
prime1:
    00:ef:49:b3:f8:4c:1e:a9:13:a9:fb:86:7e:80:7a:
    (略)
prime2:
    00:d9:67:2f:e1:4c:13:78:fa:dd:2b:7a:3e:f5:68:
    (略)
exponent1:
    00:ba:18:ee:ff:a7:6b:9d:01:2f:0c:f0:0f:88:29:
    (略)
exponent2:
    52:93:94:27:32:5b:4f:1f:92:74:9a:39:61:c3:ae:
    (略)
coefficient:
    44:e9:a2:de:87:e7:2d:f0:57:58:d6:fc:85:20:df:
    (略)
</code></pre>

<h3>GnuTLS</h3>

<p>GnuTLS の <code>certtool</code> で秘密鍵の内容を確認するには <code>-k</code> (<code>--key-info</code>) を使います。
<code>openssl</code> の <code>-noout</code> 相当のオプションは見つけられませんでした。</p>

<pre><code class="console gnutls">$ certtool -k --infile example-tls.key
Public Key Info:
        Public Key Algorithm: RSA
        Key Security Level: High
modulus:
        00:da:45:da:ca:13:ac:59:43:55:87:68:04:16:1a:
        (略)
public exponent:
        01:00:01:
private exponent:
        3c:5b:18:96:cc:3d:da:28:fe:5b:84:ed:ac:56:e2:
        (略)
prime1:
        00:dc:f3:92:13:d5:c7:cf:bc:9f:76:b3:f6:a2:60:
        (略)
prime2:
        00:fc:e5:83:0e:2e:d4:a1:be:37:bf:05:6e:c3:d3:
        (略)
coefficient:
        63:74:e3:95:9e:d6:6c:7d:d9:2d:ad:45:f8:0b:1a:
        (略)
exp1:
        00:a1:1d:a7:9e:79:1c:2b:da:42:79:bf:7f:10:26:
        (略)
exp2:
        00:b3:be:9c:ab:53:f5:a5:10:01:a7:2f:41:4e:c5:
        (略)
        c4:31:

Public Key ID: 45:44:BC:C4:BB:95:24:97:5D:C2:95:BF:27:95:02:2C:50:09:9E:35

-----BEGIN RSA PRIVATE KEY-----
(略)
-----END RSA PRIVATE KEY-----
</code></pre>

<h2>CSR 作成と内容確認</h2>

<p>OpenSSL は <code>openssl req</code> で作成も内容の確認も出来ます。
GnuTLS の <code>certtool</code> は <code>-q</code> (<code>--generate-request</code>) で作成して
<code>--crq-info</code> で内容を確認できます。</p>

<p>以下の例ではそれぞれで作成して、両方で内容を確認しています。</p>

<h3>OpenSSL</h3>

<p>OpenSSL では <code>C</code> と <code>ST</code> と <code>O</code> にデフォルト値が入っていて、
対話的に作成しつつ空欄にしたい時は
別途 <code>openssl.cnf</code> を用意する必要がありそうです。</p>

<pre><code class="console openssl">$ openssl req -new -key example-ssl.key -out example-ssl.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:JP
State or Province Name (full name) [Some-State]:Osaka
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:ssl.example.jp
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
$ openssl req -in example-ssl.csr -text -noout
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: C=JP, ST=Osaka, O=Internet Widgits Pty Ltd, CN=ssl.example.jp
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (4096 bit)
                Modulus:
                    00:cb:35:ec:f6:00:5a:75:d7:55:14:f8:55:91:1a:
                    (略)
                Exponent: 65537 (0x10001)
        Attributes:
            a0:00
    Signature Algorithm: sha1WithRSAEncryption
         4f:1a:a7:57:9f:88:f3:17:23:aa:51:12:11:ff:c0:24:31:4c:
         (略)
$ certtool --crq-info --infile example-ssl.csr
PKCS #10 Certificate Request Information:
        Version: 1
        Subject: C=JP,ST=Osaka,O=Internet Widgits Pty Ltd,CN=ssl.example.jp
        Subject Public Key Algorithm: RSA
                Modulus (bits 4096):
                        cb:35:ec:f6:00:5a:75:d7:55:14:f8:55:91:1a:9b:83
                        (略)
                Exponent:
                        01:00:01
Other Information:
        Public Key Id:
                c14459bdb79e6b71e6303e4ffd9c7ab43dc9b9df

-----BEGIN NEW CERTIFICATE REQUEST-----
(略)
-----END NEW CERTIFICATE REQUEST-----
</code></pre>

<h3>GnuTLS</h3>

<p>GnuTLS ではテンプレートファイルを作成しておいて <code>--template</code> で指定する方法が多いようですが、
対話的にも作成できました。
<code>Subject</code> を <code>CN</code> だけにするのは OpenSSL より簡単に出来たのですが、
<code>Requested Extensions</code> が設定されるようなので、
不要な場合には困りそうです。</p>

<pre><code class="console gnutls">$ certtool -q --load-privkey example-tls.key --outfile example-tls.csr
Generating a PKCS #10 certificate request...
Country name (2 chars):
Organization name:
Organizational unit name:
Locality name:
State or province name:
Common name: tls.example.jp
UID:
Enter a dnsName of the subject of the certificate:
Enter the IP address of the subject of the certificate:
Enter the e-mail of the subject of the certificate:
Enter a challenge password:
Does the certificate belong to an authority? (y/N):
Will the certificate be used for signing (DHE and RSA-EXPORT ciphersuites)? (y/N):
Will the certificate be used for encryption (RSA ciphersuites)? (y/N):
Is this a TLS web client certificate? (y/N):
Is this also a TLS web server certificate? (y/N):
$ openssl req -in example-tls.csr -text -noout
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: CN=tls.example.jp
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (4096 bit)
                Modulus:
                    00:da:45:da:ca:13:ac:59:43:55:87:68:04:16:1a:
                    (略)
                Exponent: 65537 (0x10001)
        Attributes:
        Requested Extensions:
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Key Usage: critical
                Digital Signature
    Signature Algorithm: sha1WithRSAEncryption
         cb:71:d2:c9:a2:97:14:74:f0:63:69:6b:36:31:ff:ce:f2:a0:
         (略)
$ certtool --crq-info --infile example-tls.csr
PKCS #10 Certificate Request Information:
        Version: 1
        Subject: CN=tls.example.jp
        Subject Public Key Algorithm: RSA
                Modulus (bits 4096):
                        da:45:da:ca:13:ac:59:43:55:87:68:04:16:1a:09:41
                        (略)
                Exponent:
                        01:00:01
        Attributes:
                Extensions:
                        Basic Constraints (critical):
                                Certificate Authority (CA): FALSE
                        Key Usage (critical):
                                Digital signature.
Other Information:
        Public Key Id:
                4544bcc4bb9524975dc295bf2795022c50099e35

-----BEGIN NEW CERTIFICATE REQUEST-----
(略)
-----END NEW CERTIFICATE REQUEST-----
</code></pre>

<h2>まとめて作成</h2>

<p>CSR の生成の時に秘密鍵を指定しないと、
CSR と一緒に秘密鍵を生成できるようです。</p>

<h3>OpenSSL</h3>

<p><code>openssl req -new</code> で <code>-key</code> の代わりに <code>-newkey</code> などを指定すると CSR と一緒に秘密鍵も生成できます。
この場合もそのままだとパーミッションが <code>-rw-rw-r--</code> (664) になるようなので、注意が必要です。
<code>-nodes</code> を付けないと暗号化するためのパスフレーズを要求されます。</p>

<pre><code class="console openssl">$ openssl req -new -newkey rsa:4096 -nodes -keyout server.key -out server.csr
Generating a 4096 bit RSA private key
.............................................................................................................................................................................................................................................................................................................................................++
......++
writing new private key to 'server.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:JP
State or Province Name (full name) [Some-State]:Osaka
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:ssl.example.jp
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
</code></pre>

<h3>GnuTLS</h3>

<p><code>certtool -q</code> で <code>--load-privkey</code> を指定しないと秘密鍵も一緒に生成するようです。
出力は <code>--outfile</code> で指定したファイルにまとめて入ってしまって、
使い勝手は良くないので、個別に生成した方が良さそうです。</p>

<pre><code class="console gnutls">$ certtool -q --outfile out.txt
Generating a PKCS #10 certificate request...
Generating a 2432 bit RSA private key...
Country name (2 chars):
Organization name:
Organizational unit name:
Locality name:
State or province name:
Common name: tls.example.jp
UID:
Enter a dnsName of the subject of the certificate:
Enter the IP address of the subject of the certificate:
Enter the e-mail of the subject of the certificate:
Enter a challenge password:
Does the certificate belong to an authority? (y/N):
Will the certificate be used for signing (DHE and RSA-EXPORT ciphersuites)? (y/N):
Will the certificate be used for encryption (RSA ciphersuites)? (y/N):
Is this a TLS web client certificate? (y/N):
Is this also a TLS web server certificate? (y/N):
$ cat out.txt
-----BEGIN RSA PRIVATE KEY-----
(略)
-----END RSA PRIVATE KEY-----
PKCS #10 Certificate Request Information:
        Version: 1
        Subject: CN=tls.example.jp
        Subject Public Key Algorithm: RSA
                Modulus (bits 2432):
                        f4:ff:66:e8:c6:19:ab:7b:39:e3:72:ff:ee:13:fa:cf
                        (略)
                Exponent:
                        01:00:01
        Attributes:
                Extensions:
                        Basic Constraints (critical):
                                Certificate Authority (CA): FALSE
                        Key Usage (critical):
                                Digital signature.
Other Information:
        Public Key Id:
                61c9cef12d691e3373f71ad3a82d1ac4c4b71793

-----BEGIN NEW CERTIFICATE REQUEST-----
(略)
-----END NEW CERTIFICATE REQUEST-----
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CVE-2014-0160 での Cookie 漏洩]]></title>
    <link href="http://blog.n-z.jp/blog/2014-04-09-cve-2014-0160.html"/>
    <updated>2014-04-09T23:55:46+09:00</updated>
    <id>http://blog.n-z.jp/blog/cve-2014-0160</id>
    <content type="html"><![CDATA[<p>影響範囲の一例として
<a href="https://www.mattslifebytes.com/?p=533">Hijacking user sessions with the Heartbleed vulnerability</a>
の実際にどういうデータが抜き取られてしまうのか、という例で
<code>JSESSIONID</code>
が見えているように Cookie が漏洩している可能性があります。</p>

<!--more-->


<h2>考えられる攻撃シナリオ</h2>

<p><a href="http://www.exploit-db.com/exploits/32745/">OpenSSL TLS Heartbeat Extension - Memory Disclosure</a>
を自分のサーバーに試した時に
<code>mod-spdy-beta</code>
が原因で脆弱性が残ったままになっていて、
Rails アプリの Cookie が見えていました。</p>

<p>そこで考えたのは上記のブログに書いてあるようにセッションハイジャックが可能だということでした。</p>

<p>悪い状況を考えると、
脆弱性の情報が公開されてから対策がされるまでの間に
全世界の Web サーバーに Heartbleed の攻撃を仕掛けておいて、
後でログを調べて、こういう Cookie のような情報があれば
それを使って別途セッションハイジャックなどの別の攻撃をする、
という可能性があります。</p>

<h2>Rails での対処方法案</h2>

<p><code>config/initializers/secret_token.rb</code> の <code>secret_token</code> を再生成して設定し直すという方法が考えられます。
その際、ログインしているユーザーのセッションが無効になったり、
Remember me で覚えさせていても忘れられたりするということが起きるので、
ユーザーへの影響を考えて実施する必要がありそうです。</p>

<p>また、データベースへ保存するデータの暗号化の鍵としても使っていたら、
読めなくなってしまうので、そういう用途にも使っていたら、
別の方法で既存の Cookie を無効にするしかなさそうです。</p>

<h2>secure 属性を付けていても無関係</h2>

<p>クライアントとの通信内容の残骸が漏洩してしまうので、
Cookie に secure 属性を付けていても防げません。</p>

<h2>アプリケーションサーバーが別プロセスでも無関係</h2>

<p>apache+passenger や nginx+php-fpm のようにアプリケーションサーバーとフロントエンドの Web サーバーが別プロセスにわかれていても、
HTTPS 向けに暗号化する前の平文のデータがフロントエンドの Web サーバーに残っていて、そこの情報が漏洩してしまうので、
Cookie のようなクライアントに返す情報は影響を受けて漏洩している可能性があります。</p>

<p>バックエンドのサーバーでしか読み込んでいなくて、フロントエンドには渡していない情報はこの経路では漏洩しません。</p>

<p>例えば、典型的な Rails アプリの構成ではデータベースサーバーへ接続するためのユーザー名やパスワードはクライアントには渡さないので、この経路では漏洩しません。</p>

<h2>フロントエンドサーバーの秘密鍵</h2>

<p>既に情報収集していれば知って可能性が高いと思いますが、
フロントエンドサーバーのプロセスが読み込んでいる情報にあたる SSL/TLS の秘密鍵は漏洩している可能性があります。</p>

<p>きちんとした対処としては
<a href="http://d.hatena.ne.jp/nekoruri/20140408/heartbleed">CVE-2014-0160 OpenSSL Heartbleed 脆弱性まとめ - めもおきば</a>
にも書いてあるように</p>

<ol>
<li><em>秘密鍵から作り直して</em> 証明書を再発行</li>
<li>過去の証明書を <em>失効</em></li>
</ol>


<p>の両方が必要です。</p>

<h2>余談</h2>

<p>SPDY とか使いたいから HTTPS にしてるだけで HTTP で通信してても良いような内容しか扱ってないサーバーなら (VirtualHost の他のホストも含めてという条件付きで)、放置でも良いのかもしれませんが、少なくとも次の証明書の更新の時には秘密鍵を作り直した方が良いように思います。</p>

<h2>まとめ</h2>

<p>外部から SSL/TLS 接続を受けるプロセスが持っている情報が漏洩している可能性がある、ということで、具体例として Cookie について少し詳しく考えてみました。</p>

<p>簡単に言えば、脆弱性のある状態でクライアントと通信している内容はすべて漏洩している可能性がある、つまり HTTPS で通信していても HTTP と同じような機密性しかなかった可能性がある、と考えるのが良さそうです。</p>

<p>つまりクライアントから送った情報も漏洩の可能性があるので、
Heartbleed 脆弱性が残っているサーバーにはクレジットカード番号などの情報は
送らない方が良い、ということになります。</p>

<p>関連する話なので一緒に書いてしまったので、ちょっと紛らわしいですが、
サーバーの秘密鍵の漏洩の可能性もフロントエンドサーバーの管理者は別途対応する必要があります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CVE-2014-0160 の OpenSSL の脆弱性対応]]></title>
    <link href="http://blog.n-z.jp/blog/2014-04-08-cve-2014-0160.html"/>
    <updated>2014-04-08T13:22:28+09:00</updated>
    <id>http://blog.n-z.jp/blog/cve-2014-0160</id>
    <content type="html"><![CDATA[<p><a href="http://heartbleed.com/">Heartbleed</a>
によると今回の OpenSSL の脆弱性は影響が大きそうなので、
OpenSSL の更新をして再起動だけでも早めにした方が良さそうです。</p>

<p>再起動が必要なものは Debian なら
<a href="http://blog.n-z.jp/blog/2013-12-06-checkrestart.html">debian-goodiesのcheckrestartで再起動が必要なプロセスを調べる</a>
のがオススメです。
Ubuntu なら libssl の更新は OS 自体を再起動した方が良いと思います。</p>

<p>秘密鍵を再生成した方が良いという話もあるようですが、
そこまでの対処は続報を待ってからでも良いかもしれません。</p>

<!--more-->


<h2><code>mod_spdy</code> にも影響</h2>

<p>(<code>mod_spdy</code> について 2014-04-09 に追記)</p>

<p><a href="https://groups.google.com/forum/#!topic/mod-spdy-discuss/EwCowyS1KTU">mod_spdy</a>
も影響を受けるので、
<code>mod-spdy-beta</code> パッケージの <code>0.9.4.1-r397</code> 以前を入れている場合は最新版 (2014-04-09 リリースの <code>0.9.4.2-r413</code> 以降) に更新する必要があります。</p>

<p><code>mod-spdy-beta</code> に含まれる <code>mod_ssl_with_npn.so</code> は改変した <code>libssl</code> を静的リンクしているようなので、
システム側の OpenSSL が 0.9.8 系などのディストリビューション (wheezy など) でも以下のようになっていて、脆弱性の影響を受けます。</p>

<pre><code>$ ldd /usr/lib/apache2/modules/mod_ssl.so
        linux-vdso.so.1 =&gt;  (0x00007fff25b9a000)
        libssl.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007f6ae2d93000)
        libcrypto.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007f6ae299c000)
        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f6ae277f000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6ae23f4000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f6ae21f0000)
        libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f6ae1fd8000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f6ae322d000)
$ ldd /usr/lib/apache2/modules/mod_ssl_with_npn.so
        linux-vdso.so.1 =&gt;  (0x00007fff825ff000)
        librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f8704d4e000)
        libcrypt.so.1 =&gt; /lib/x86_64-linux-gnu/libcrypt.so.1 (0x00007f8704b17000)
        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f87048fa000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f87046f6000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f870436b000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f8705367000)
</code></pre>

<h2>影響を受ける OpenSSL のバージョン</h2>

<p>Heartbleed の <code>What versions of the OpenSSL are affected?</code>
によると、影響を受けるのは OpenSSL 1.0.1 から 1.0.1f で、
OpenSSL 1.0.0 系や OpenSSL 0.9.8 系という古いバージョンは
影響がないようです。</p>

<h2>Debian や Ubuntu への影響</h2>

<p>他の OS も含めた情報は
Heartbleed の <code>How about operating systems?</code>
にまとまっているので、
Debian と Ubuntu に付いてもう少し調べてみました。</p>

<p>Heartbleed にも書いてありますが、
<a href="https://www.debian.org/security/2014/dsa-2896">Debian &ndash; Security Information &ndash; DSA-2896-1 openssl</a>
によると Debian は oldstable (squeeze) は影響がなくて、
stable (wheezy) だと影響があるようです。
つまりまだ wheezy に上げていないサーバーは大丈夫でした。</p>

<p><a href="http://www.ubuntu.com/usn/usn-2165-1/">USN-2165-1: OpenSSL vulnerabilities | Ubuntu</a>
によると Ubuntu は</p>

<ul>
<li>Ubuntu 13.10 (saucy)</li>
<li>Ubuntu 12.10 (quantal)</li>
<li>Ubuntu 12.04 LTS (precise)</li>
</ul>


<p>にセキュリティアップデートが出ているようです。
10.04 LTS lucid は openssl が古いので影響がなくて、
13.04 (raring) は
<a href="http://www.ubuntu.com/info/release-end-of-life">サポート終了</a>
しているので、セキュリティアップデートは出ていないようです。
ついでに
<a href="http://distrowatch.com/table.php?distribution=ubuntu">DistroWatch.com: Ubuntu</a>
でもう少し調べてみると 1.0.1 になったのが 12.04 からなので、
11.10 以前は影響がないようです。</p>

<h2>攻撃を受けたかどうかの確認はできない</h2>

<p>Heartbleed に
<code>Can I detect if someone has exploited this against me?</code>
<code>Exploitation of this bug leaves no traces of anything abnormal happening to the logs.</code>
と書いてあって、
「このバグを突かれても何か変なことがあったというログは残らない」
ということのようなので、
普通は攻撃を受けたかどうか確認できないということのようです。</p>

<h2>秘密鍵は再生成するべき</h2>

<p>というわけで、
<a href="https://www.debian.org/security/2014/dsa-2896">DSA-2896</a>
に
<code>to the currently available information, private keys should be considered as compromised and regenerated as soon as possible.</code>
と書いてあるように、
秘密鍵は出来るだけ早く再生成した方が良いようです。</p>

<h2>openssh-server の鍵の再生成</h2>

<p>2014-04-08 追記:
<a href="http://undeadly.org/cgi?action=article&amp;sid=20140408063423">OpenSSH は影響を受けない</a>
ようです。
(2014-04-09 23:55 追記: SSH の通信部分で OpenSSL を使っていないので、直接は影響を受けないというだけで、 PAM で LDAPS を使っている場合などは当然影響を受けます。)</p>

<p>サーバー側では <code>/etc/ssh/ssh_host_*</code> を削除して <code>dpkg-reconfigure openssh-server</code> で再生成するのが良さそうです。</p>

<pre><code>% sudo rm /etc/ssh/ssh_host_*
% sudo dpkg-reconfigure openssh-server
Creating SSH2 RSA key; this may take some time ...
Creating SSH2 DSA key; this may take some time ...
Creating SSH2 ECDSA key; this may take some time ...
ssh stop/waiting
ssh start/running, process 7230
% sudo service ssh restart
ssh stop/waiting
ssh start/running, process 7339
</code></pre>

<p>クライアント側では、
<code>HashKnownHosts no</code>
を設定していれば
<code>~/.ssh/known_hosts</code>
ファイルを直接編集しても良いのですが、
設定していないと、どの行がどのホストかわからないので、
<code>ssh-keygen -R foo.example.jp</code>
のように削除すると良さそうです。</p>

<p>場合によっては
<code>ssh-keygen -R 192.168.1.2</code>
のように IP アドレス側の削除や
<code>ssh-keygen -R '[foo.example.jp]:3843'</code>
のようにポート番号付きでの指定が必要かもしれません。</p>

<p><code>UserKnownHostsFile</code> で <code>known_hosts</code> ファイルを分割しているときは
<code>ssh-keygen -R foo.example.jp -f ~/.ssh/foo.known_hosts</code> のように
<code>UserKnownHostsFile</code> を指定する必要があります。</p>

<h2>その他のサーバーの鍵の再生成</h2>

<p>apache2 とかの Web サーバーなら
初回の設定と同様に再生成すれば良さそうですが、
証明書の再発行も必要なので、
気軽には出来ないということで、
しばらく様子見中です。</p>

<p>OpenVPN はサーバーの鍵は再生成した方が良さそうですが、
CA まで再生成する必要があるのかどうかがわからないので
様子見中です。</p>

<p>以前の Debian での修正ミスで脆弱な鍵しか生成できなくなっていた問題の修正のときの
<a href="https://www.debian.org/security/key-rollover/">Debian &ndash; 鍵のロールオーバー</a>
が参考になるかもしれませんが、
今回はサーバー外からでも鍵が抜き出せてしまうという問題のようなので、
LAN 内のサーバーなど、そのサーバーにアクセスできる環境に攻撃者が入れる時点で問題がある環境なら、
アップデートを適用して再起動して今後鍵を抜き取られる可能性をなくしてから、
ゆっくり続報を待ってから対処を考えるということでも良いと思います。</p>

<h2>参考リンク</h2>

<p>2014-04-09 参考リンクを追加</p>

<ul>
<li><a href="http://d.hatena.ne.jp/nekoruri/20140408/heartbleed">CVE-2014-0160 OpenSSL Heartbleed 脆弱性まとめ - めもおきば</a>

<ul>
<li>このリンク先が日本語としては一番情報がまとまっているようです。</li>
</ul>
</li>
<li><a href="http://jvn.jp/vu/JVNVU94401838/">JVNVU#94401838: OpenSSL の heartbeat 拡張に情報漏えいの脆弱性</a>

<ul>
<li>ベンダ情報とか CVSS とか。</li>
</ul>
</li>
<li><a href="http://heartbleed.com/">Heartbleed Bug</a>

<ul>
<li>英語だけど Google Chrome の翻訳機能でもだいたい読めます。</li>
</ul>
</li>
<li><a href="http://www.exploit-db.com/exploits/32745/">OpenSSL TLS Heartbeat Extension - Memory Disclosure</a>

<ul>
<li>実際に情報が抜き出せるチェックツールで、これをみて他のツールの誤検知ではなく <code>mod_spdy</code> が原因だと気付きました。</li>
</ul>
</li>
<li><a href="https://groups.google.com/forum/#!topic/mod-spdy-discuss/0yAGH8BHfQo">CVE-2014-0160 / heartbleed openssl bug &amp; mod_spdy - Google グループ</a>

<ul>
<li><code>mod_spdy</code> の対応の話 (英語) です。日本時間の 2014-04-09 02:00 時点ではまだ対応中で修正版のリリースはされていないようです。</li>
</ul>
</li>
<li><a href="https://groups.google.com/forum/#!msg/mod-spdy-discuss/EwCowyS1KTU/uGm4586P_CQJ">New mod_spdy binary bugfix release (v0.9.4.2) - SECURITY FIX</a>

<ul>
<li>日本時間の 2014-04-09 09:00 時点ではリリースされていました。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
