<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: shell | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2017-11-26T21:52:24+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[bash で PATH を配列に分解の続き]]></title>
    <link href="http://blog.n-z.jp/blog/2016-10-07-bash-path-to-array-again.html"/>
    <updated>2016-10-07T21:39:31+09:00</updated>
    <id>http://blog.n-z.jp/blog/bash-path-to-array-again</id>
    <content type="html"><![CDATA[<p>zsh だと <code>PATH</code> と同期している配列変数として <code>path</code> があるのですが、
bash にはそういうものがなくて困ったので、分解する方法を考えてみた話の続きです。
末尾の空文字列や改行に対応しました。</p>

<!--more-->


<h2>昨日の方法の問題点</h2>

<p><a href="/blog/2016-10-06-bash-path-to-array.html">昨日の記事</a> に書きましたが、末尾の空文字列の処理に問題がありました。
また、書いていませんでしたが、改行に対応できていませんでした。</p>

<h2>末尾対応</h2>

<p><code>PATH= bash -c 'ls'</code> を <code>/bin</code> やそれ以外で実行してみたら
空の <code>PATH</code> はカレントディレクトリのみと同じ意味のようなので、
「<a href="https://twitter.com/fixedpoint_jp/status/784229832930369536">末尾の空文字列に対応するために、PATHにの最後に:を追加した文字列をreadすればいい?</a>」
という指摘のように末尾に <code>:</code> を追加する方法で良さそうでした。</p>

<p>つまり、以下のようになります。</p>

<pre><code class="console">% bash -c 'PATH=/bin:; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin" [1]="")'
% bash -c 'PATH=/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin")'
% bash -c 'PATH=; IFS=: read -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="")'
</code></pre>

<p>「PATH自体が空だった場合は振舞いが変わるけど。」という話もありましたが、
<code>PATH</code> 探索を再現できれば良いということを考えると空の場合も問題なさそうでした。</p>

<pre><code class="console">% bash -c 'PATH=; ls'
bash: ls: No such file or directory
% cd /bin
% bash -c 'PATH=; ls /bin/bash'
/bin/bash
</code></pre>

<h2>改行対応</h2>

<p>いろいろ試していると改行を含む <code>PATH</code> を扱えないことに気づいたのですが、
<code>-d $'\0'</code> (以下の例ではコマンドラインのエスケープでひどいことになっていますが) を
指定して区切り文字を変えると here string の末尾に付く改行も入力の一部として
扱われてしまうのでうまくいかないようでしたが、末尾の要素を <code>unset</code> で削除することで
良い感じになりました。</p>

<p><code>$'\0'</code> は NUL 文字で C 言語での終端文字なので、普通は <code>PATH</code> の途中に入らないことが期待できるので、ありえない文字として指定しています。</p>

<pre><code class="console">% bash -c 'PATH=/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; declare -p path'
declare -a path='([0]="/bin" [1]="
")'
% bash -c 'PATH=/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; unset path[-1]; declare -p path'
declare -a path='([0]="/bin")'
% bash -c 'PATH=/foo$'"'"'\n'"'"'bar:/bin; IFS=: read -d $'"'"'\0'"'"' -r -a path &lt;&lt;&lt;"$PATH:"; unset path[-1]; declare -p path'
declare -a path='([0]="/foo
bar" [1]="/bin")'
</code></pre>

<p>わかりやすいようにファイルにして実行すると以下のような感じです。</p>

<pre><code class="console">% cat /tmp/p.bash
PATH=/foo$'\n'bar:/bin
IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
declare -p path
PATH=/foo$'\n'bar:/bin:
IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
declare -p path
% bash /tmp/p.bash
declare -a path='([0]="/foo
bar" [1]="/bin")'
declare -a path='([0]="/foo
bar" [1]="/bin" [2]="")'
</code></pre>

<h2>他の処理例</h2>

<p><code>/etc/group</code> くらいのデータになると awk などを使った方が良いと思いますが、
<code>/etc/group</code> (末尾に空文字列が入ることがある) のパースも良い感じにできるようです。</p>

<p>設定されていない状態でも構わなかったり、
末尾に空文字列が入らないことがわかっている <code>/etc/passwd</code> などの場合は
bash の組み込みコマンドだけでいけそうです。</p>

<pre><code class="console">% cat /tmp/t.bash
#!/bin/bash
sed 's/$/:/' /etc/group | while IFS=: read -r -a group; do
  declare -p group
done
% bash /tmp/t.bash
declare -a group='([0]="root" [1]="x" [2]="0" [3]="")'
declare -a group='([0]="daemon" [1]="x" [2]="1" [3]="")'
declare -a group='([0]="bin" [1]="x" [2]="2" [3]="")'
declare -a group='([0]="sys" [1]="x" [2]="3" [3]="")'
declare -a group='([0]="adm" [1]="x" [2]="4" [3]="syslog,vagrant")'
(略)
declare -a group='([0]="lpadmin" [1]="x" [2]="114" [3]="vagrant")'
declare -a group='([0]="sambashare" [1]="x" [2]="115" [3]="vagrant")'
declare -a group='([0]="vboxsf" [1]="x" [2]="999" [3]="")'
declare -a group='([0]="scanner" [1]="x" [2]="116" [3]="")'
declare -a group='([0]="colord" [1]="x" [2]="117" [3]="")'
</code></pre>

<h2>まとめ</h2>

<p>最終的には</p>

<pre><code class="bash">IFS=: read -d $'\0' -r -a path &lt;&lt;&lt;"$PATH:"
unset path[-1]
</code></pre>

<p>で <code>PATH</code> を配列に変換できることがわかりました。</p>

<p>入力データに改行がないとわかっているなら <code>-d $'\0'</code> などは省略できるので、
入力データの性質に応じて適度に手を抜きつつ処理をするのが良いのではないでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash で PATH を配列に分解]]></title>
    <link href="http://blog.n-z.jp/blog/2016-10-06-bash-path-to-array.html"/>
    <updated>2016-10-06T23:50:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/bash-path-to-array</id>
    <content type="html"><![CDATA[<p>zsh だと <code>PATH</code> と同期している配列変数として <code>path</code> があるのですが、
bash にはそういうものがなくて困ったので、分解する方法を考えてみました。</p>

<!--more-->


<h2>結論</h2>

<p>先に結論を書いておくと、最終的には <code>IFS=: read -r -a path &lt;&lt;&lt;"$PATH"</code> という方法で分解できました。</p>

<p>2016-10-07 追記: 詳細は<a href="/blog/2016-10-07-bash-path-to-array-again.html">続き</a> に書きましたが、改行などに対応できていませんでした。</p>

<pre><code class="console">% bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
</code></pre>

<p>のように動作確認できます。</p>

<p>declare で表示というのは <a href="http://yonchu.hatenablog.com/entry/2013/07/09/230656" title="シェルスクリプトのデバッグは typeset または declare を使うと良いかも - よんちゅBlog">シェルスクリプトのデバッグは typeset または declare を使うと良いかも - よんちゅBlog</a> を参考にしました。</p>

<h2><code>-r</code> オプション</h2>

<p><code>-r</code> オプションは <code>read</code> コマンドを使うときの定石ですが、具体的には <code>\:</code> のような並びがあるときに影響がありました。</p>

<pre><code class="console">% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="/tmp/foo\\" [2]="/tmp/bar")'
% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="/tmp/foo:/tmp/bar")'
</code></pre>

<p>実際のパスの挙動は <code>-r</code> がある場合と同じようでした。</p>

<pre><code class="console">% mkdir /tmp/foo\\
% echo echo hoge &gt; /tmp/foo\\/hoge
% chmod +x /tmp/foo\\/hoge
% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -a path &lt;&lt;&lt;"$PATH"; for p in "${path[@]}"; do test -x "$p/hoge" &amp;&amp; "$p/hoge"; done'
PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; for p in "${path[@]}"; do test -x "$p/hoge" &amp;&amp; "$p/hoge"; done'
hoge
% PATH="/bin:/tmp/foo\:/tmp/bar" hoge
hoge
</code></pre>

<h2><code>-d</code> オプション</h2>

<p><code>-d</code> オプションというのもあったので試してみたのですが、そこで完全に読み込み終了になってしまって、期待した動作にはなりませんでした。</p>

<pre><code class="console">% PATH="/bin:/tmp/foo\:/tmp/bar" bash -c 'read -d : -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin")'
</code></pre>

<h2><code>-a</code> オプション</h2>

<p><code>-a</code> オプションはこのように複数の変数を指定する代わりにひとつの変数を指定して配列を代入してくれるオプションでした。</p>

<p><code>-a</code> オプションがないと指定した変数のうち、最後に残り全て入ってしまうようです。</p>

<pre><code class="console">PATH="/bin:/tmp/foo\:/tmp/bar:/tmp/baz" bash -c 'IFS=: read -r path1 path2 path3 &lt;&lt;&lt;"$PATH"; declare -p path1 path2 path3'
declare -- path1="/bin"
declare -- path2="/tmp/foo\\"
declare -- path3="/tmp/bar:/tmp/baz"
</code></pre>

<h2>here string</h2>

<p><code>&lt;&lt;&lt;word</code> は <code>echo word |</code> のようなもので、標準入力に <code>word</code> を渡してくれる機能です。</p>

<h2>IFS</h2>

<p><code>read</code> などの単語区切りです。
デフォルトは空白、タブ、改行です。</p>

<p>ずっと変えてしまうと影響が大きすぎるので、 <code>read</code> の行だけ変更するようにしています。</p>

<p>また、このやり方を使うことで空白の入ったディレクトリを含むパスもうまく扱えます。</p>

<h2>カレントディレクトリを表す空のパスの扱い</h2>

<p>頭や途中に入った空文字列 (カレントディレクトリを表す) は扱えたのですが、末尾にある場合はうまくいきませんでした。</p>

<p>セキュリティ上の問題もあるので、普通は設定しないと思うので、対応しなくても問題はないと思いますが、完全に変換したい場合は特別扱いを追加する必要がありそうでした。</p>

<pre><code class="console">%  bash -c 'PATH=:/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="" [1]="/bin")'
%  bash -c 'PATH=/bin::/bin; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin" [1]="" [2]="/bin")'
%  bash -c 'PATH=/bin:; IFS=: read -r -a path &lt;&lt;&lt;"$PATH"; declare -p path'
declare -a path='([0]="/bin")'
</code></pre>

<h2>まとめ</h2>

<p>zsh には元から <code>path</code> があるし、 <code>/bin/sh</code> には配列がないので bash 限定ではありますが、
<code>IFS=: read -r -a path &lt;&lt;&lt;"$PATH"</code> で実用上問題なく変換できるということがわかったので、必要な時には使うと良いのではないでしょうか。</p>

<p>2016-10-07 追記: 末尾の空文字列や改行に対応した<a href="/blog/2016-10-07-bash-path-to-array-again.html">続き</a>を書きました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ターミナルでの文字幅を調べる]]></title>
    <link href="http://blog.n-z.jp/blog/2014-10-07-char-width-in-terminal.html"/>
    <updated>2014-10-07T20:10:20+09:00</updated>
    <id>http://blog.n-z.jp/blog/char-width-in-terminal</id>
    <content type="html"><![CDATA[<p><a href="http://uwabami.junkhub.org/log/20141007.html#p01" title="マルチバイト文字列の幅を 2 としてカウントする">マルチバイト文字列の幅を 2 としてカウントする</a>
という話を見て、
端末に実際の幅を問い合わせてみればいいのではないかと思って試してみました。</p>

<!--more-->


<h2>実行例</h2>

<p>こんな感じでできました。
zsh と bash で動作確認しています。
端末は
<a href="http://iterm2.com/" title="iTerm2">iTerm2</a>
で動作確認しています。</p>

<pre><code>% echo -ne '日本語\e[6n'; read -d';' a; read -dR a; printf '\e[M\r'; echo $[a-1]
6
% echo -ne 'abc日本語\e[6n'; read -d';' a; read -dR a; printf '\e[M\r'; echo $[a-1]
9
</code></pre>

<h2>スクリプト化</h2>

<p>実行ファイルにするならこんな感じになります。</p>

<pre><code>#!/bin/bash
echo -ne "$*"'\e[6n'; read -d';' a; read -dR a; printf '\e[M\r'; echo $[a-1]
</code></pre>

<h2>解説</h2>

<p>実装としては実際に表示して、カーソル位置を端末に問い合わせて、表示を消去して、桁を取り出して 1 引いています。</p>

<p>エスケープシーケンスなどに関しては、
<a href="http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html" title="対応制御シーケンス">対応制御シーケンス</a>
を参考にしてください。</p>

<ol>
<li>まず文字列を表示しています。</li>
<li><code>CSI Ps n</code> (DSR) を使ってカーソルの位置を報告させています。</li>
<li><code>CSI r ; c R</code> という応答のうち、 <code>;</code> までを捨てて、 <code>c</code> だけ変数 <code>a</code> に取り込んでいます。</li>
<li><code>CSI Ps M</code> (DL) でカーソル行に表示された内容を消去しています。</li>
<li><code>CR</code> で行頭にカーソルを戻しています。</li>
<li>カーソル位置なので 文字数+1 になっているので、1 引いて表示しています。</li>
</ol>


<h2>追記</h2>

<p>実装の説明でわかると思いますが、1行を超える長さは調べられません。がんばるなら適当に区切って文字ごととかで調べてください。</p>

<p>実行開始時にカーソルは行頭にしておく必要があり、実行後にカーソル行は消えます。
スクリプト中に入れるには使いにくいと思います。</p>

<p>半分ネタなので、あんまりがんばっていません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GOPATHとghqの設定を変更した話とgitconfigのコマンドでの設定の話]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-05-ghq-gitconfig.html"/>
    <updated>2014-07-05T09:55:07+09:00</updated>
    <id>http://blog.n-z.jp/blog/ghq-gitconfig</id>
    <content type="html"><![CDATA[<p><a href="http://blog.kentarok.org/entry/2014/06/03/135300" title="ghqを使ったローカルリポジトリの統一的・効率的な管理について - delirious thoughts">ghqを使ったローカルリポジトリの統一的・効率的な管理について - delirious thoughts</a>
を参考にして、
go と ghq で同じディレクトリを使っていたのですが、
go で自動で追加ダウンロードされたものと
自分でダウンロードしたものが混ざるとわかりにくいと思ったので、
分けることにしました。</p>

<!--more-->


<h2>対象バージョン</h2>

<ul>
<li>go version go1.3 darwin/amd64</li>
<li>git verseion 2.0.0</li>
<li>Mercurial Distributed SCM (version 3.0.1)</li>
<li>ghq version HEAD (2014-06-27 が最新コミットの状態)</li>
</ul>


<h2>go などのインストール</h2>

<p><a href="http://brew.sh/">Homebrew</a> を使って
<code>brew install go --cross-compile-common</code>
でインストールしました。</p>

<p>git と mercurial もインストールしておきました。</p>

<h2>シェルの設定 (GOPATH など)</h2>

<p>bash と zsh の共通の設定として
<a href="https://github.com/znz/dot-shell/blob/bb84c5aefc83eab5ce1841508abd726ee9db6577/profile.d/50gopath.sh" title="50gopath.sh">50gopath.sh</a>
で以下のように設定しています。</p>

<p>統合している時は go とか git とかの意味をかねて g だけにしていましたが、
今は go 専用にしています。</p>

<pre><code class="sh 50gopath.sh">    if [ -z "${GOPATH:-}" ]; then
        export GOPATH=$HOME/g
        PATH=$PATH:$GOPATH/bin
    fi
</code></pre>

<p>その後に zsh 専用の追加設定で
<a href="https://github.com/znz/dot-shell/blob/bb84c5aefc83eab5ce1841508abd726ee9db6577/profile.d/50gopath.zsh" title="50gopath.zsh">50gopath.zsh</a>
で以下のように設定しています。</p>

<p>GOPATH が PATH のように <code>:</code> 区切りで複数になる可能性を考慮してしまったのですが、
<a href="http://golang.org/doc/code.html#GOPATH" title="The GOPATH environment variable">The GOPATH environment variable</a>
をみるとそういうことはなさそうなので、
<code>${^${(s/:/)GOPATH}}</code> は単純に <code>${GOPATH}</code> でも良さそうです。</p>

<p>そして fpath に <code>_ghq</code> のパスを追加して <code>ghq</code> の引数を補完できるようにしています。</p>

<pre><code class="sh 50gopath.zsh">    path=( $path ${^${(s/:/)GOPATH}}/bin(N) )
    fpath=( $fpath ${^${(s/:/)GOPATH}}/src/*/*/ghq/zsh(N) )
</code></pre>

<h2>ghq のインストール</h2>

<p><code>go get -v github.com/motemen/ghq</code>
でインストールしました。</p>

<h3><code>https://</code> の要不要</h3>

<p><code>ghq get</code> では <code>github.com</code> から書く時は <code>https://</code> が必須なのですが、
こちらは <code>https://</code> は不要というか、
むしろ付けるとエラーになりました。</p>

<h2>.gitconfig の設定</h2>

<p><a href="https://github.com/znz/dot-shell/blob/bb84c5aefc83eab5ce1841508abd726ee9db6577/git-config.sh" title="git-config.sh">git-config.sh</a>
で <code>user.name</code> や <code>user.email</code> 以外の共通のものはまとめて設定しています。</p>

<h3>コマンドでの設定の追加削除</h3>

<p>詳細はドキュメントをみてもらうとして、まとめておくと以下のようになります。</p>

<ul>
<li>単独の設定 : <code>git config --global section.key value</code></li>
<li>複数設定 : <code>git config --global section.key value</code> の後で <code>git config --global --add section.key value</code></li>
<li>複数設定削除 : <code>git config --global --unset-all section.key</code> (ただしセクションが空になっても残る)</li>
<li>セクションごと削除 : <code>git config --global --remove-section セクション</code></li>
</ul>


<h3>ghq の設定</h3>

<p><code>ghq.root</code> を <code>--unset-all</code> だけすると git-config.sh を実行する度に
ghq セクション、つまり <code>[ghq]</code> の行が増えていってしまったので、
<code>--remove-section</code> を使いました。
他に <code>ghq</code> セクションに設定を入れていたら、
それも消えてしまうので注意してください。</p>

<pre><code class="sh">    # ghq section
    git config --global --remove-section "ghq" || :
    GHQ_ROOT="ghq.root"
    #git config --global --unset-all "$GHQ_ROOT" || :
    git config --global "$GHQ_ROOT" "$HOME/s"
    git config --global --add "$GHQ_ROOT" "$HOME/g/src"
</code></pre>

<p>これで <code>ghq get</code> は <code>$HOME/s</code> に入って
<code>ghq look</code> では両方見えるようになりました。</p>

<h3>github の URL 統一の話</h3>

<p>github の URL は https に統一して、
gitconfig の設定で
push は ssh プロトコル、
pull などは git プロトコル (昔は Git Read-Only と書いてあった URL)
を使うようにしています。</p>

<pre><code class="sh">    # github upload
    GITHUB_URL_PREFIX="url.git@github.com:"
    git config --global --remove-section "$GITHUB_URL_PREFIX" || :
    git config --global "$GITHUB_URL_PREFIX".pushInsteadOf "git://github.com/"
    git config --global --add "$GITHUB_URL_PREFIX".pushInsteadOf "https://github.com/"
    # gist upload
    git config --global "url.git@gist.github.com:".pushInsteadOf "https://gist.github.com/$(git config github.user)/"
    # github download
    git config --global url."git://github.com/".insteadOf "https://github.com/"
</code></pre>

<p>詳細は
<a href="http://blog.n-z.jp/blog/2013-11-28-git-insteadof.html" title="githubでhttpsのURLを指定してもgitプロトコルやssh経由にする方法">githubでhttpsのURLを指定してもgitプロトコルやssh経由にする方法</a>
を参照してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[シェルで glob 結果を事前に確認する方法]]></title>
    <link href="http://blog.n-z.jp/blog/2014-06-21-confirm-glob.html"/>
    <updated>2014-06-21T13:16:56+09:00</updated>
    <id>http://blog.n-z.jp/blog/confirm-glob</id>
    <content type="html"><![CDATA[<p><code>rm *~</code> のつもりで <code>rm * ~</code> (半角スペースが混ざっている) のように実行してしまうような間違いをすると危険です。</p>

<p>その対策として <code>tcsh</code> には <code>rmstar</code> という設定があったり
<code>zsh</code> には <code>RM_STAR_SILENT</code> や <code>RM_STAR_WAIT</code> という設定があるのですが、
ちゃんと展開結果を確認してからコマンドを実行する方が安全です。</p>

<p>また <code>rm</code> 以外でも展開結果を事前に確認できると便利なことが多いです。</p>

<!--more-->


<h2>展開結果の確認方法</h2>

<p><code>bash</code> や <code>zsh</code> の一般的なキー割り当てだと <code>C-x g</code> (Control を押しながら x を押して Control を離して g) で展開結果を確認できます。</p>

<p>Tab キーだとコマンドライン中に展開されてしまいますが、
<code>C-x g</code> だと確認だけ出来ます。</p>

<h3>bash の場合</h3>

<p>たとえば <code>bash</code> なら以下のように展開結果が出て、
プロンプトの行が出てきます。</p>

<pre><code class="console bash">    $ echo /etc/host*&lt;C-x&gt;g
    host.conf    hostname     hosts        hosts.allow  hosts.deny
    $ echo /etc/host*
</code></pre>

<h3>zsh の場合</h3>

<p><code>zsh</code> ならプロンプトの行の下に展開結果が出てきます。</p>

<pre><code class="console zsh">    % echo /etc/host*
    /etc/host.conf    /etc/hostname     /etc/hosts        /etc/hosts.allow  /etc/hosts.deny
</code></pre>

<h2>Tab キーの動作</h2>

<p>比較のため Tab キーでの動作例も載せておきます。</p>

<h3>bash の場合</h3>

<p>実際には同じ行でしたが、最初の展開結果に置き換わりました。</p>

<pre><code class="console bash">    $ echo /etc/host*&lt;tab&gt;
    $ echo /etc/host.conf
</code></pre>

<h3>zsh の場合</h3>

<p>こちらも実際には同じ行ですが、すべての展開結果に置き換わりました。</p>

<pre><code class="console zsh">    % echo /etc/host*&lt;tab&gt;
    % echo /etc/host.conf /etc/hostname /etc/hosts /etc/hosts.allow /etc/hosts.deny
</code></pre>

<p>glob で指定しにくい一部のファイルだけ除外するなど、展開された方が便利な時は
Tab キーで展開してからコマンドラインを編集して実行することもあります。</p>

<h2>まとめ</h2>

<p>一般的な bash 環境ならどこでも使えて、
複雑な glob の展開結果の確認にも便利なので、
<code>C-x g</code> は非常にオススメです。</p>
]]></content>
  </entry>
  
</feed>
