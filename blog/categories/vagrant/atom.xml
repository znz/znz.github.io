<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vagrant | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/vagrant/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2014-08-11T19:53:16+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vagrant Cloudでboxを公開してみた]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-21-vagrantcloud-box.html"/>
    <updated>2014-07-21T15:52:35+09:00</updated>
    <id>http://blog.n-z.jp/blog/vagrantcloud-box</id>
    <content type="html"><![CDATA[<p><a href="http://blog.n-z.jp/blog/2014-07-18-wheezy-from-vagrant-cloud.html" title="Vagrant CloudからWheezyを入れてみた">Vagrant CloudからWheezyを入れてみた</a>で公開されているものを使ってみたので、
今回は
<a href="https://vagrantcloud.com/">Vagrant Cloud</a>
で日本語で日本向けの Box の公開も試してみました。</p>

<!--more-->


<h2>手順概要</h2>

<ol>
<li><a href="https://vagrantcloud.com/">https://vagrantcloud.com/</a> にログイン</li>
<li><a href="https://vagrantcloud.com/boxes/new">Create Box</a> で作成</li>
<li>Create new version でバージョンを作成</li>
<li>Create new provider でバージョンに対応する provider を作成</li>
<li>無料アカウントだと Upload は使えないようなので URL を指定</li>
<li>バージョンの編集で Release すると公開</li>
</ol>


<h2>登録される情報</h2>

<p>ユーザーアカウントに複数の Box が対応していて、
Box に複数のバージョンが対応していて、
バージョンに複数の provider (VirtualBox とか VMware とか) が対応している、
という構造になっているようです。</p>

<p>バージョンは Release するまでは公開されないようです。</p>

<p>古いバージョンは Revoke で破棄できるようなので、
box を置く URL を使い回すなら Revoke してから
ファイルを置き換えて新しいバージョンを登録するのが
良さそうに思いました。</p>

<h2>作成した box の packer テンプレート</h2>

<p><a href="https://github.com/znz/packer-templates">packer-templates</a>
で公開しています。</p>

<p>使い方は</p>

<pre><code>git clone https://github.com/znz/packer-templates
cd debian-7.6.0-amd64-ja_jp
packer build debian-7.6.0-amd64-ja_jp.json
</code></pre>

<p>で <code>debian-7.6.0-amd64-ja_jp_virtualbox.box</code> が作成できます。
試した環境では1時間ぐらいかかりました。</p>

<h2>使用方法</h2>

<p><code>vagrant init znzj/debian-7.6.0-amd64-ja_jp</code>
のように <code>vagrant init</code> の引数に <code>ユーザー名/BOX名</code> を指定して
<code>Vagrantfile</code> を作成すると
<code>config.vm.box = "znzj/debian-7.6.0-amd64-ja_jp"</code>
と指定されていて <code>vagrant up</code> で自動ダウンロードされて使えます。</p>

<h2>登録した URL の扱い</h2>

<p>box は URL で登録したので、
<code>https://vagrantcloud.com/znzj/debian-7.6.0-amd64-ja_jp/version/1/provider/virtualbox.box</code>
のように <code>vagrantcloud.com</code> の URL に見えるところからダウンロードしようとした時、
リダイレクトされて登録した URL からのダウンロードになるようです。</p>

<p><code>vagrantcloud</code> 側でキャッシュなどをしてくれるわけではないようなので、
置き場所には注意する必要がありそうです。</p>

<p>今回は需要も多くなさそうで、
日本向けということで
さくらのVPS
に置いてみました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant CloudからWheezyを入れてみた]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-18-wheezy-from-vagrant-cloud.html"/>
    <updated>2014-07-18T21:30:25+09:00</updated>
    <id>http://blog.n-z.jp/blog/wheezy-from-vagrant-cloud</id>
    <content type="html"><![CDATA[<p>Debian 7.6 がリリースされたので、新しい box がないか探してみたところ、
<a href="http://www.vagrantbox.es/" title="A list of base boxes for Vagrant - Vagrantbox.es">A list of base boxes for Vagrant - Vagrantbox.es</a>
から探すのではなく
<a href="https://vagrantcloud.com/">Vagrant Cloud</a>
を使えば良いということがわかりました。</p>

<!--more-->


<h2>動作確認バージョン</h2>

<ul>
<li>VirtualBox 4.3.12</li>
<li>Vagrant 1.6.3</li>
<li><a href="https://vagrantcloud.com/ffuenf/debian-7.6.0-amd64" title="Debian Wheezy 7.6.0 x86_64">Debian Wheezy 7.6.0 x86_64</a> 0.0.27</li>
</ul>


<h2>書き換え</h2>

<p>古い box は</p>

<pre><code>  config.vm.box = ENV["VM_BOX"] || "opscode_debian-7.4_chef-provisionerless"
  config.vm.box_url = ENV["VM_BOX_URL"] || "http://opscode-vm-bento.s3.amazonaws.com/vagrant/virtualbox/opscode_debian-7.4_chef-provisionerless.box"
</code></pre>

<p>と指定していたのを
<a href="https://github.com/ffuenf/vagrant-boxes" title="ffuenf/vagrant-boxes">ffuenf/vagrant-boxes</a>
からリンクされている
<a href="https://vagrantcloud.com/ffuenf/debian-7.6.0-amd64" title="ffuenf/debian-7.6.0-amd64">ffuenf/debian-7.6.0-amd64</a>
の説明通り <code>vagrant init ffuenf/debian-7.6.0-amd64</code> で作成された
<code>Vagrantfile</code> を参考にして、</p>

<pre><code>  config.vm.box = "ffuenf/debian-7.6.0-amd64"
</code></pre>

<p>に書き換えました。</p>

<p>以前の box を使っている 古い VM を <code>vagrant destroy</code> ですべて破棄した後、
<code>vagrant box remove opscode_debian-7.4_chef-provisionerless</code>
で box も削除しました。</p>

<h2>余談</h2>

<p><code>vagrant box outdated</code> や <code>vagrant box update</code> の使い方がわからなかったのですが、
<code>box_url</code> でダウンロードしてきた box で使うものではなく Vagrant Cloud から
ダウンロードしてきた box で使うものだったようです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apt-cacher-ngでliveイメージ作成を繰り返す時の無駄なダウンロードを減らす]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-14-apt-cacher-ng.html"/>
    <updated>2014-07-14T23:53:14+09:00</updated>
    <id>http://blog.n-z.jp/blog/apt-cacher-ng</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/znz/rubylive-builder" title="rubylive-builder">rubylive-builder</a>
で
<a href="https://github.com/znz/rubylive" title="RubyLive">RubyLive</a>
という Debian wheezy ベースの Live イメージを作成するときに
<code>apt-get update</code> などで何度も無駄にダウンロードしてしまうので、
<code>apt-cacher-ng</code> で Live イメージ作成を繰り返す時の無駄なダウンロードを減らすことにしました。</p>

<!--more-->


<h2>Vagrant の provision でインストール</h2>

<p>Vagrantfile では</p>

<pre><code class="ruby Vagrantfile">  config.vm.provision :shell do |shell|
    shell.path = "provision.sh"
  end
</code></pre>

<p>のようにシェルスクリプトでプロビジョニングしているだけだったので、
その中で以下のようにインストールして設定するようにしました。</p>

<pre><code class="bash provision.sh">apt-get install -y apt-cacher-ng
echo 'Acquire::http::Proxy "http://localhost:3142/";' &gt;/etc/apt/apt.conf.d/02proxy
</code></pre>

<p>Vagrantfile で以下のようにポートフォワーディングを設定していれば
<a href="http://gihyo.jp/admin/serial/01/ubuntu-recipe/0315" title="第315回　apt-cacher-ngを使ってAPT用キャッシュプロキシの構築：Ubuntu Weekly Recipe｜gihyo.jp … 技術評論社">第315回　apt-cacher-ngを使ってAPT用キャッシュプロキシの構築：Ubuntu Weekly Recipe｜gihyo.jp … 技術評論社</a>
の2ページ目に説明があるようにヒット率などを確認できます。</p>

<pre><code class="ruby Vagrantfile">  # apt-cacher-ng
  config.vm.network "forwarded_port", guest: 3142, host: 3142
</code></pre>

<h2>rake コマンドで環境変数を渡す</h2>

<p><code>APT_HTTP_PROXY=http://localhost:3142 rake</code> でも良かったのですが、
rake コマンドは引数の <code>FOO=bar</code> を <code>ENV</code> に設定してくれるので、
<code>rake APT_HTTP_PROXY=http://localhost:3142</code> で渡して、
Rakefile の中では以下のように受け取って <code>lb config</code> に渡しました。</p>

<pre><code class="ruby Rakefile">desc "config RubyLive"
task :config =&gt; [:clean] do
  sh 'lb config'
  if ENV['APT_HTTP_PROXY']
    sh "lb config --apt-http-proxy #{ENV['APT_HTTP_PROXY']}"
  end
end
</code></pre>

<h2>live-build で apt-cacher-ng を使う</h2>

<p>既に出てきたように
<code>lb config</code> の <code>--apt-http-proxy</code> オプションや <code>--apt-ftp-proxy</code> オプションで指定すると
Live イメージ作成の時に proxy を使ってくれるようになります。
今回は apt-line に <code>http</code> しか使っていないので
<code>--apt-http-proxy</code> だけ指定しています。</p>

<p>もちろん、作成後の Live イメージには proxy 設定は残りません。</p>

<h2>感想</h2>

<p>live-build は cache ディレクトリにも、かなりキャッシュしてくれるのですが、
<code>apt-get update</code> などの proxy じゃないとキャッシュしにくいものもあるので、
どんな場合でもダウンロード量削減に役に立ちそうだと思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyLiveを仮想環境で作成]]></title>
    <link href="http://blog.n-z.jp/blog/2014-07-13-build-rubylive-on-vm.html"/>
    <updated>2014-07-13T09:35:02+09:00</updated>
    <id>http://blog.n-z.jp/blog/build-rubylive-on-vm</id>
    <content type="html"><![CDATA[<p>最近流行りの仮想環境を使ってクリーンな wheezy 環境で RubyLive を作成できるようにしました。</p>

<p>VirtualBox + Vagrant は特殊な制限のない仮想環境なので Live イメージが作成できたのですが、
docker は後述の制限のために作成できませんでした。</p>

<!--more-->


<h2>RubyLive を Vagrant で作成</h2>

<p>Vagrant を使ってクリーンな wheezy 環境で RubyLive の ISO を作成できるようにしました。
こちらは問題なく作成できました。</p>

<h3>動作確認バージョン</h3>

<ul>
<li>VirtualBox 4.3.12</li>
<li>Vagrant 1.6.3</li>
</ul>


<h3>使い方</h3>

<ul>
<li>VirtualBox と Vagrant をインストールしておきます。</li>
<li><code>git clone https://github.com/znz/rubylive-builder</code> で取得します。</li>
<li><code>cd rubylive-builder</code> で中に入ります。</li>
<li><code>VM_MEMORY=512 vagrant up</code> のように適当なメモリ容量を指定して起動します。 (指定なしなら 1024)

<ul>
<li>他の項目も環境変数である程度変更できるようにしています。</li>
<li>初回起動時は box をダウンロードするので非常に時間がかかります。</li>
<li>provision で live-build などの必要なパッケージをインストールしています。</li>
</ul>
</li>
<li><code>vagrant ssh</code> でゲストにログインします。</li>
<li><code>/vagrant/rubylive.sh</code> を実行すると <code>/home/vagrant/rubylive</code> で RubyLive のイメージを作成します。

<ul>
<li>実行するたびにタイムスタンプの入ったファイル名の ISO ファイルが作成されます。</li>
<li>ネットワークの速度やマシンスペックに影響を受けると思いますが、試した環境では約1時間かかりました。</li>
</ul>
</li>
<li>作成できた <code>/home/vagrant/rubylive/*.iso</code> を <code>/vagrant</code> にコピーまたは移動して、ホスト OS 側に取り出します。</li>
<li>取り出した ISO ファイルを使用します。</li>
</ul>


<p>なぜか
    chroot: failed to run command <code>/usr/bin/env': No such file or directory
で失敗することがありましたが、再度</code>/vagrant/rubylive.sh` を実行すれば問題なく作成できました。</p>

<h3>片付け方</h3>

<ul>
<li><code>vagrant destroy</code> で VM を破棄します。</li>
<li><code>git clone</code> した作業ディレクトリを削除します。</li>
<li>wheezy の box が不要なら <code>vagrant box remove opscode_debian-7.4_chef-provisionerless</code> で削除します。</li>
<li>Vagrant や VirtualBox も不要ならアンインストールします。</li>
</ul>


<h2>RubyLive を Docker で作成 (失敗)</h2>

<p>docker 環境の中では <code>chroot /rubylive/chroot mount -t proc proc /proc</code> が <code>EPERM</code> で失敗するため、作成できませんでした。</p>

<h3>動作確認バージョン</h3>

<ul>
<li>docker 1.1.1</li>
</ul>


<h3>試し方</h3>

<ul>
<li>docker をインストールしておきます。</li>
<li><code>git clone https://github.com/znz/rubylive-builder</code> で取得します。</li>
<li><code>docker build rubylive-builder</code> で作成に挑戦します。

<ul>
<li>または <code>cd rubylive-builder</code> で中に入って <code>docker build .</code> です。</li>
</ul>
</li>
<li><code>docker ps -a</code> で最近の CREATED の IMAGE を確認します。

<ul>
<li>もしくは <code>docker images</code> で確認します。</li>
<li>最後の失敗した後の状態は残っていないようでした。</li>
</ul>
</li>
<li><code>docker run -i -t --rm 4b8bc4523794 /bin/bash</code> のように中に入ります。

<ul>
<li>4b8bc4523794 のところは確認した IMAGE の ID にしてください。</li>
</ul>
</li>
<li><code>cd rubylive</code> で rubylive ディレクトリに入って <code>rake</code> で作成に再挑戦します。</li>
<li><code>less /rubylive/chroot/debootstrap/debootstrap.log</code> でログを確認したり、
<code>chroot /rubylive/chroot mount -t proc proc /proc</code> や
<code>mount -t proc proc /rubylive/chroot/proc</code> を直接実行してみたりして
原因を確認します。</li>
</ul>


<h3>失敗部分のメッセージ</h3>

<pre><code>W: Failure trying to run: chroot /rubylive/chroot mount -t proc proc /proc
W: See /rubylive/chroot/debootstrap/debootstrap.log for details
P: Begin unmounting filesystems...
P: Saving caches...
/usr/bin/env: apt-get: No such file or directory
rake aborted!
Command failed with status (1): [sudo lb build...]
</code></pre>

<p><code>/rubylive/chroot/debootstrap/debootstrap.log</code> をみると <code>mount: permission denied</code> と出ていました。</p>

<h3>Dockerfile 直接指定 (失敗)</h3>

<p><code>docker build https://raw.githubusercontent.com/znz/rubylive-builder/master/Dockerfile</code>
のように直接 URL を指定する方法は
<code>sources.list</code> を国内ミラーに差し替える部分が失敗して使えませんでした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant の Multi VM 間で IPsec を試した]]></title>
    <link href="http://blog.n-z.jp/blog/2014-06-04-vagrant-multivm-ipsec-demo.html"/>
    <updated>2014-06-04T22:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/vagrant-multivm-ipsec-demo</id>
    <content type="html"><![CDATA[<p>正常に IPsec の暗号化通信ができているときの racoon のログなどを確認したかったので、
Vagrant と ansible で
IPsec で通信できる Multi VM 環境を作ってみました。</p>

<p>playbook は
<a href="https://github.com/znz/ansible-playbook-ipsec-demo">https://github.com/znz/ansible-playbook-ipsec-demo</a>
で公開しています。</p>

<!--more-->


<h2>動作確認バージョン</h2>

<ul>
<li>ホスト OS : Mac OS X 10.9.3</li>
<li>VirtualBox 4.3.12</li>
<li>Vagrant 1.6.3</li>
<li>ansible 1.6.2</li>
<li>ゲスト OS : Ubuntu 14.04 &times; 2</li>
</ul>


<p>Ubuntu は <a href="https://cloud-images.ubuntu.com/vagrant/trusty/current/">https://cloud-images.ubuntu.com/vagrant/trusty/current/</a> のイメージを使ったので、
daily build の状態によっては動作が変わっているかもしれません。</p>

<h2>ホストオンリーネットワーク</h2>

<p>使った後は</p>

<ul>
<li>vboxnet1 (192.168.50.1/24)</li>
<li>vboxnet2 (192.168.11.1/24)</li>
<li>vboxnet3 (192.168.12.1/24)</li>
</ul>


<p>が勝手に増えているので、不要なら設定で消しておくと良いと思います。</p>

<p>ネットワークとしては以下のように 192.168.50.0/24 の部分で IPsec 接続をして、
192.168.11.11 と 192.168.12.12 をつなぐ、という感じにしています。
デフォルトの eth0 は外部への接続用としてそのままにしています。</p>

<pre><code>192.168.11.11 (vm1:eth2)
       |
192.168.50.11 (vm1:eth1)
       |
192.168.50.12 (vm2:eth1)
       |
192.168.12.12 (vm2:eth2)
</code></pre>

<h2>準備</h2>

<p>Usage に書いてあるように準備をしておきます。
先日作った <code>ja_jp</code> role は git submodule にしているので、</p>

<pre><code>% git submodule init
% git submodule update
</code></pre>

<p>で取得する必要があります。</p>

<h2>試し方</h2>

<p><code>vagrant up</code>
すると
<code>/etc/ipsec-tools.conf</code>
と
<code>/etc/racoon/racoon.conf</code>
に設定が入っている状態になっているので、
始点アドレスを指定して
<code>ipsec-tools.conf</code>
に設定した経路を通るようにパケットを送ると
IPsec VPN がつながります。</p>

<p><code>ping</code> コマンドのように直接始点アドレスを指定するオプションがない場合は
<code>ping -I eth2 192.168.12.12</code> のように network interface で指定すれば
良いようです。</p>

<h2>動作確認</h2>

<p>以下のコマンドの出力が接続前後で変わることが確認できます。</p>

<ul>
<li><code>racoonctl -l show-sa isakmp</code></li>
<li><code>racoonctl -l show-sa ipsec</code></li>
<li><code>setkey -D</code></li>
</ul>


<p>racoon のログが <code>/var/log/syslog</code> に大量に出ているのを確認できます。
(<code>racoon.conf</code> で <code>log debug</code> にしているため)</p>

<h2>tshark でパケットの確認</h2>

<p><code>tshark</code> パッケージをインストールした後、
<code>sudo dpkg-reconfigure wireshark-common</code>
で一般ユーザーでも実行を許可するようにして、
実行を許可するユーザーを <code>wireshark</code> に追加します。</p>

<p>グループの追加を反映するためにログインし直すと、
<code>tshark -i eth1 -V 'port 500'</code>
などでパケットの確認ができるようになります。</p>

<p>暗号化されていて詳細はわかりませんが、
UDP の 500 番ポートで Informational のパケットが流れていることが確認できました。</p>

<p>GUI の wireshark の方では
<a href="http://ask.wireshark.org/questions/12019/how-can-i-decrypt-ikev1-andor-esp-packets">http://ask.wireshark.org/questions/12019/how-can-i-decrypt-ikev1-andor-esp-packets</a>
の方法で暗号化の解除もできるようです。</p>

<p>syslog の方で racoon のログをみると、
DPD のパケットらしいということが確認できました。
syslog の方で <code>#012</code> となっている部分がありますが、
これは rsyslog で改行が変換されたたもので空白として無視すれば良くて、
例えば</p>

<pre><code>Jun  4 17:54:43 vm1 racoon: DEBUG: new cookie:#012831d33d46e20f8e6
Jun  4 17:54:43 vm1 racoon: DEBUG: final encryption key computed:
Jun  4 17:54:43 vm1 racoon: DEBUG: #012932d361f fc62ddc2 6164d513 d40d211f b7364166 232cf490
</code></pre>

<p>というログなら cookie は <code>831d33d46e20f8e6</code> になります。</p>

<p>鍵は <code>932d361ffc62ddc26164d513d40d211fb7364166232cf490</code> になると思ったのですが、
これを
Edit -> Preferences -> Protocols -> ISAKMP -> IKEv1 Decryption Table:
に設定すれば良いはずなのですが、試したところ decrypt されなかったので、
あっているのかどうかはわかりませんでした。
cookie の方は他のログなどで確認できたので、あっているはずです。</p>
]]></content>
  </entry>
  
</feed>
