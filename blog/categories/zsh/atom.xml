<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: zsh | @znz blog]]></title>
  <link href="http://blog.n-z.jp/blog/categories/zsh/atom.xml" rel="self"/>
  <link href="http://blog.n-z.jp/"/>
  <updated>2013-12-09T23:55:31+09:00</updated>
  <id>http://blog.n-z.jp/</id>
  <author>
    <name><![CDATA[Kazuhiro NISHIYAMA]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[.zshrcの自動再コンパイル]]></title>
    <link href="http://blog.n-z.jp/blog/2013-12-10-auto-zshrc-recompile.html"/>
    <updated>2013-12-10T00:00:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/auto-zshrc-recompile</id>
    <content type="html"><![CDATA[<p>zsh のスクリプトは <code>zcompile</code> コマンドでコンパイルすることができます。
<code>.zshrc</code> も大きくなって読み込みに時間がかかるようになったらコンパイルすれば良さそうですが、
変更したときに手動でコンパイルし直すのは面倒なので、
自動で再コンパイルする設定を紹介します。</p>

<p>この投稿は
<a href="http://qiita.com/advent-calendar/2013/zsh">zsh Advent Calendar 2013</a>
の10日目の記事です。</p>

<!--more-->


<h2>設定方法</h2>

<p><code>.zshrc</code> の適当な場所に以下の設定を追加します。</p>

<p><code>sh
if [ ~/.zshrc -nt ~/.zshrc.zwc ]; then
   zcompile ~/.zshrc
fi
</code></p>

<p>これで <code>.zshrc.zwc</code> より <code>.zshrc</code> の方が新しい時に
<code>zcompile .zshrc</code> が自動で実行されます。</p>

<p><code>.zshrc.zwc</code> がある時だけ実行されるので、
最初に <code>zcompile ~/.zshrc</code> を手動で実行しておきます。</p>

<h2>読み込み順序</h2>

<p>zsh 自体が <code>file.zwc</code> よりも <code>file</code> の方が新しい時に
<code>file</code> の方を読み込むようになっているので、
<code>.zshrc</code> の方が新しくて <code>zcompile</code> し直していないときに
<code>.zshrc.zwc</code> が読み込まれて
古い設定のままになるということはありません。</p>

<h2>自動作成もする場合</h2>

<p>ファイルを分割していて <code>.zshrc</code> はコンパイルする必要がない環境では
何もしない挙動になってほしいので、
こうしていますが、
最初から自動作成してほしいのなら、
存在チェックも付けて以下のようにすれば良いと思います。</p>

<p><code>sh
if [ ! -f ~/.zshrc.zwc -o ~/.zshrc -nt ~/.zshrc.zwc ]; then
   zcompile ~/.zshrc
fi
</code></p>

<h2>まとめ</h2>

<p>ここでは <code>.zshrc</code> だけを対象にしましたが、
他にも自前の <code>fpath</code> のファイルなどで自動で再コンパイルしたいファイルがあれば
同様のことをするのがよいかもしれません。</p>

<p>あまり変更しないファイルなら更新チェックの無駄の方が大きいかもしれないので、
そのトレードオフは考えておく必要がありそうです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zshでcdの履歴管理に標準添付のcdrを使う]]></title>
    <link href="http://blog.n-z.jp/blog/2013-11-12-zsh-cdr.html"/>
    <updated>2013-11-12T01:16:00+09:00</updated>
    <id>http://blog.n-z.jp/blog/zsh-cdr</id>
    <content type="html"><![CDATA[<p>zsh は <code>cd -[TAB]</code> で補完できる directory stack が
<code>setopt autopushd</code> と組み合わせていると非常に便利なので、
<a href="https://github.com/znz/dot-shell/blob/c197f9e3232e8dca910be4ea4ae555cc60468692/profile.d/50dirstack.zsh">directory stack を自前で保存する仕組みを作った</a>り、
GNU screen の他の WINDOW のディレクトリに移動するための
<a href="https://github.com/znz/dot-shell/blob/523e3adaf9b776f05185acfb24bc19ef5f22c418/profile.d/70cds.zsh">cdsというコマンド</a>
を作ったりして、
現状でもあまり困っていませんでした。</p>

<p>しかし、 <code>zshcontrib(1)</code> に入っているものも試してみるのが
良さそうと思って試してみました。</p>

<!--more-->


<h2>ドキュメント</h2>

<p>ドキュメントは
<code>man zshcontrib</code> か、
<code>pager $^fpath/cdr(N)</code> で読めます。</p>

<h2>cdr コマンドの使い方</h2>

<p><code>cdr [TAB]</code> で補完して使ったり、
<code>cdr -l</code> で一覧を出したり、
<code>cdr -e</code> で一覧を編集したりできます。</p>

<p><code>cdr -e</code> の編集は <code>zle</code> なので、
<code>bindkey -e</code> なら、
普通のカーソル移動などの他に
ただの <code>Enter</code> だと編集終了になってしまうので、
<code>^[^M</code> (<code>ESC</code> に続けて <code>Enter</code>) で改行を入力して行を増やしたり分割したり
出来ることを知っておけば充分だと思います。</p>

<h2>設定全体</h2>

<p>全体としては以下のように設定してみました。</p>

<p>以降は設定内容を個別に解説していきます。</p>

<p><code>sh
if [[ -n $(echo ${^fpath}/chpwd_recent_dirs(N)) &amp;&amp; -n $(echo ${^fpath}/cdr(N)) ]]; then
autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
  add-zsh-hook chpwd chpwd_recent_dirs
  zstyle ':completion:*:*:cdr:*:*' menu selection
  zstyle ':completion:*' recent-dirs-insert both
  zstyle ':chpwd:*' recent-dirs-max 500
  zstyle ':chpwd:*' recent-dirs-default true
  zstyle ':chpwd:*' recent-dirs-file "${XDG_CACHE_HOME:-$HOME/.cache}/shell/chpwd-recent-dirs"
  zstyle ':chpwd:*' recent-dirs-pushd true
fi
</code></p>

<h2>使えるかどうかのガード条件</h2>

<p>昔、
zsh の設定を環境ごとに分岐させようとした時、
<code>is-at-least</code> は古い zsh で使えなかったのと、
バックポートで使える可能性があったり、
自前の <code>fpath</code> にファイルを追加した場合などを考慮して、
機能自体の存在をチェックするようにしています。</p>

<p>ruby で推奨されているやり方として、
<code>RUBY_VERSION</code> をチェックするのではなく、
機能の存在をチェックするべき、
という話があったことも影響しています。</p>

<p><code>sh
  if [[ -n $(echo ${^fpath}/chpwd_recent_dirs(N)) &amp;&amp; -n $(echo ${^fpath}/cdr(N)) ]]; then
</code>
Glob Qualifiers の <code>(N)</code> (<code>NULL_GLOB</code>) を使っている関係で、
一度 <code>echo</code> してから <code>-n</code> でチェックしています。
もっと簡潔に書ける方法があれば教えてください。</p>

<h2>autoload</h2>

<p><code>autoload -U</code>
と書いてある設定例もありますが、
ドキュメントにあったように
<code>autoload -Uz</code>
を使っています。</p>

<p><code>-z</code>
を付けないと
<code>KSH_AUTOLOAD</code>
の設定の影響を受けるそうなので、
基本的には <code>-z</code> を明示的に付けるのがおすすめのようです。</p>

<h2>add-zsh-hook</h2>

<p><code>chpwd_functions</code> への追加は</p>

<p><code>sh
typeset -ga chpwd_functions
chpwd_functions+=chpwd_recent_dirs
</code></p>

<p>としても良かったのですが、
念のため <code>typeset</code> するのが最近の zsh しか使わないのなら無駄に感じたのと、
<code>cdr</code> のドキュメントに書いてあったこともあり、
<code>add-zsh-hook</code>
を使ってみました。</p>

<h2>menu selection</h2>

<p>Web で設定例を見ると
<code>zstyle ':completion:*' menu select</code>
になっていることが多いのですが、
基本的に menu select は使っていなかったので、
<code>zshcontrib(1)</code> や
<code>${^fpath}/cdr(N)</code> に書いてあった通りに
<code>':completion:*'</code>
ではなく
<code>':completion:*:*:cdr:*:*'</code>
で、
値も
<code>select</code>
ではなく
<code>selection</code>
で設定しています。</p>

<p><code>sh
  zstyle ':completion:*:*:cdr:*:*' menu selection
</code></p>

<h2>recent-dirs-insert</h2>

<p>これは
<code>cdr [TAB]</code>
の挙動の設定で、
好みが分かれると思うので、
<code>always</code>, <code>fallback</code>, <code>both</code>
を一通り試してみるのをおすすめします。</p>

<p><code>both</code> だと通常の <code>cd</code> の補完にメニューから選ぶ補完候補に履歴が入っているという感じに見えました。
あまりうまく使えていないので、そのうち他の設定に変えて試してみようと思っています。</p>

<h2>recent-dirs-max</h2>

<p>設定を保存する最大数です。
デフォルト値は 20 です。</p>

<h2>recent-dirs-file</h2>

<p><a href="http://standards.freedesktop.org/basedir-spec/latest/index.html">XDG Base Directory Specification</a>
に合わせて <code>~/.cache</code> を使うようにしています。</p>

<p>他の部分で既に <code>mkdir -p</code> しているので、ここでは省略しています。</p>

<p><code>sh
  #mkdir -p "${XDG_CACHE_HOME:-$HOME/.cache}/shell"
  zstyle ':chpwd:*' recent-dirs-file "${XDG_CACHE_HOME:-$HOME/.cache}/shell/chpwd-recent-dirs"
</code></p>

<p>ドキュメントにあるように、
以下のような設定にして TTY ごとのファイルと
グローバルのファイルにわけるのも良いかもしれません。</p>

<p><code>sh
  zstyle recent-dirs-file ':chpwd:*' ~/.chpwd-recent-dirs-${TTY##*/} +
</code></p>

<h2>recent-dirs-pushd</h2>

<p>他の設定が影響していたのか、
何が原因だったのかは追求していないのですが、
<code>recent-dirs-pushd</code> を <code>true</code> にしないと
最初はうまく動かなかったのですが、
履歴がたまったからなのか、
なぜか今はこの設定に関係なくちゃんと動いているようです。</p>

<h2>recent-dirs-prune</h2>

<p>recent の一覧に追加しないディレクトリのパターンなどを設定できるようですが、
必要性を感じていないので、
まだ何も設定していません。</p>
]]></content>
  </entry>
  
</feed>
